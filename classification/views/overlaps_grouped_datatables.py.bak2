from django.db.models import QuerySet, Subquery, OuterRef, IntegerField
from django.db.models.aggregates import Count
from django.http import HttpRequest
from django.template.loader import render_to_string

from classification.enums import OverlapStatus, AlleleOriginBucket
from classification.models import ClassificationGrouping, ClassificationGroupingOverlapContribution, Overlap, \
    ClassificationResultValue
from snpdb.lab_picker import LabPickerData
from snpdb.views.datatable_view import DatatableConfig, DC, RichColumn, DatatableConfigQuerySetMode, CellData, SortOrder


class ClassificationGroupingOverlapsColumns(DatatableConfig[ClassificationGrouping]):

    def get_initial_queryset(self) -> QuerySet[DC]:
        qs = ClassificationGrouping.objects.annotate(
            discordance_count=Subquery(
                ClassificationGroupingOverlapContribution.objects.filter(
                    classification_grouping=OuterRef('pk'),
                    overlap__valid=True,
                    overlap__overlap_status__gte=OverlapStatus.TIER_1_VS_TIER_2_DIFFERENCES
                ).order_by().values('classification_grouping').annotate(count=Count('*')).values_list('count'),
                output_field=IntegerField()
            )
        ).filter(discordance_count__gte=1)

        if lab_selection_str := self.get_query_param("lab_selection"):
            lab_picker = LabPickerData.from_request(self.request, lab_selection_str)
            if not lab_picker.is_admin_mode:
                qs = qs.filter(lab__in=lab_picker.lab_ids)

        qs = qs.prefetch_related("classificationgroupingoverlapcontribution_set")
        return qs

    def render_chgvs(self, cell: CellData[ClassificationGrouping]):
        if c_hgvs := cell.obj.latest_allele_info.imported_c_hgvs_obj:
            json_obj = c_hgvs.to_json()
            json_obj["allele_id"] = cell.obj.allele_origin_grouping.allele_grouping.allele_id
            return json_obj
        else:
            return None

    def render_classification_grouping(self, cell: CellData[ClassificationGrouping]):
        c_hgvs_data = None
        if c_hgvs := cell.obj.latest_allele_info.imported_c_hgvs_obj:
            json_obj = c_hgvs.to_json()
            json_obj["allele_id"] = cell.obj.allele_origin_grouping.allele_grouping.allele_id
            c_hgvs_data = json_obj

        grouping_cell = render_to_string('classification/snippets/classification_grouping_cell.html',
                                {"cg": cell.obj},
                                request=self.request
                                )
        return [c_hgvs_data, grouping_cell]

    def _render_value(self, cell: CellData[ClassificationGrouping], value_type: ClassificationResultValue):
        overlaps = sorted(co.overlap for co in cell.obj.classificationgroupingoverlapcontribution_set.filter(
            overlap__valid=True,
            overlap__overlap_status__gte=OverlapStatus.SINGLE_SUBMITTER,
            overlap__value_type=value_type
        ))
        value: str
        if value_type == ClassificationResultValue.ONC_PATH:
            value = cell.obj.latest_cached_summary.get("pathogenicity", {}).get("classification")
        elif value_type == ClassificationResultValue.CLINICAL_SIGNIFICANCE:
            value = cell.obj.latest_cached_summary.get("somatic", {}).get("clinical_significance")
        else:
            value = "?"

        # TOD show new value as well per triage
        return render_to_string('classification/snippets/overlaps_cell.html',
                                {
                                    "overlaps": overlaps,
                                    "value": value,
                                    "value_type": value_type,
                                    "classification_grouping": cell.obj
                                },
                                request=self.request
                                )

    def render_onc_path(self, cell: CellData[ClassificationGrouping]):
        return self._render_value(cell, ClassificationResultValue.ONC_PATH)

    def render_clin_sig(self, cell: CellData[ClassificationGrouping]):
        if cell.obj.allele_origin_grouping.allele_origin_bucket == AlleleOriginBucket.GERMLINE:
            return ""

        return self._render_value(cell, ClassificationResultValue.CLINICAL_SIGNIFICANCE)

    # def render_overlaps(self, cell: CellData[ClassificationGrouping]):
    #     overlaps = sorted(co.overlap for co in cell.obj.classificationgroupingoverlapcontribution_set.filter(
    #         overlap__valid=True,
    #         overlap__overlap_status__gte=OverlapStatus.TIER_1_VS_TIER_2_DIFFERENCES)
    #     )
    #     return render_to_string('classification/snippets/overlaps_cell.html',
    #                             {"overlaps": overlaps},
    #                             request=self.request
    #                             )

    def __init__(self, request: HttpRequest):
        super().__init__(request)
        self.server_calculate_mode = DatatableConfigQuerySetMode.OBJECTS
        self.rich_columns = [
            # RichColumn(
            #     name="chgvs",
            #     label="Imported c.HGVS",
            #     renderer=self.render_chgvs,
            #     client_renderer='VCTable.format_hgvs',
            #     sort_keys=["latest_allele_info__grch38__genomic_sort"]
            # ),

            RichColumn(
                name="classification",
                label="Your Classification",
                client_renderer=RichColumn.client_renderer_combine([
                    'VCTable.format_hgvs',
                    'TableFormat.text'
                ]),
                renderer=self.render_classification_grouping,
                sort_keys=["latest_allele_info__grch38__genomic_sort"]
            ),

            RichColumn(
                name="onc_path",
                label="Onc-Path",
                renderer=self.render_onc_path
            ),

            RichColumn(
                name="clin_sig",
                label="Somatic Clinical Significance",
                renderer=self.render_clin_sig
            )
            # RichColumn(
            #     name="overlaps",
            #     label="Overlaps",
            #     renderer=self.render_overlaps,
            #     sort_keys=["discordance_count"],
            #     default_sort=SortOrder.DESC
            # )
        ]