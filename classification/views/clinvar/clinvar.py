#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Jul  6 12:17:19 2020 by generateDS.py version 2.35.13.
# Python 3.7.4 (default, Aug 13 2019, 15:17:50)  [Clang 4.0.1 (tags/RELEASE_401/final)]
#
# Command line options:
#   ('-o', 'clinvar.py')
#
# Command line arguments:
#   clinvar_submission.xsd
#
# Command line:
#   /opt/miniconda3/bin/generateDS.py -o "clinvar.py" clinvar_submission.xsd
#
# Current working directory (os.getcwd()):
#   clinvar
#
import os
import sys
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from itertools import zip_longest

try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_

Validate_simpletypes_ = True
SaveElementTreeNode = True
BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc


def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element


#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ImportError:

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))

#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')

        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name

            def utcoffset(self, dt):
                return self.__offset

            def tzname(self, dt):
                return self.__name

            def dst(self, dt):
                return None

        def gds_format_string(self, input_data, input_name=''):
            return input_data

        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data

        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data

        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)

        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data

        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival

        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value

        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer valuess')
            return values

        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')

        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_

        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value

        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values

        def gds_format_decimal(self, input_data, input_name=''):
            return ('%0.10f' % input_data).rstrip('0')

        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value

        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value

        def gds_format_decimal_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values

        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data

        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_

        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value

        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values

        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()

        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval

        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0,):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data

        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0,):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values

        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue

        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"),)
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt

        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue

        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()

        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue

        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1

        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()

        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None:
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))

        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))

        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))

        def gds_str_lower(self, instring):
            return instring.lower()

        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path

        Tag_strip_pattern_ = re_.compile(r'\{.*\}')

        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)

        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1

        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content

        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))

        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring

        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result

        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')

            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))

        def __ne__(self, other):
            return not self.__eq__(other)

        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass

        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass

        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None

        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass

        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""


    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None

#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None


#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name,))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline,)
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8

    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value

    def getCategory(self):
        return self.category

    def getContenttype(self, content_type):
        return self.content_type

    def getValue(self):
        return self.value

    def getName(self):
        return self.name

    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:  # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)

    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))

    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:  # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)

    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
              self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
              self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text

    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:  # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
                 optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional

    def set_name(self, name):
        self.name = name

    def get_name(self):
        return self.name

    def set_data_type(self, data_type):
        self.data_type = data_type

    def get_data_type_chain(self):
        return self.data_type

    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type

    def set_container(self, container):
        self.container = container

    def get_container(self):
        return self.container

    def set_child_attrs(self, child_attrs):
        self.child_attrs = child_attrs

    def get_child_attrs(self):
        return self.child_attrs

    def set_choice(self, choice):
        self.choice = choice

    def get_choice(self):
        return self.choice

    def set_optional(self, optional):
        self.optional = optional

    def get_optional(self):
        return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Data representation classes.
#


class AffectedStatusType(Enum):
    YES = 'yes'
    NO = 'no'
    UNKNOWN = 'unknown'
    NOTPROVIDED = 'not provided'
    NOTAPPLICABLE = 'not applicable'


class AssertionType(Enum):
    VARIATIONTODISEASE = 'variation to disease'
    VARIATIONTOINCLUDEDDISEASE = 'variation to included disease'
    VARIATIONINMODIFIERGENETODISEASE = 'variation in modifier gene to disease'


class ClinvarSubmissionAcctype(Enum):
    SCV = 'SCV'
    RCV = 'RCV'
    NCV = 'NCV'


class Commenttypelist(Enum):
    PUBLIC = 'public'
    INTERNALUSE = 'internal use'
    CONVERTED_BY_NCBI = 'ConvertedByNCBI'
    EXPLANATION_OF_INTERPRETATION = 'ExplanationOfInterpretation'
    PROCESSINGCOMMENT = 'processing comment'  # This is for internal use only.


class ElementValuetype(Enum):
    PREFERRED = 'Preferred'
    ALTERNATE = 'Alternate'
    MIM = 'MIM'
    INCLUDED = 'included'


class GenderType(Enum):
    """Gender should be used ONLY if explicit values are not
    available for number of males or females, and there
    is a need to indicate that the genders in the sample are
    known."""
    MALE = 'male'
    FEMALE = 'female'
    MIXED = 'mixed'


class Genotypesettypelist(Enum):
    DIPLOTYPE = 'Diplotype'
    COMPOUND_HETEROZYGOTE = 'CompoundHeterozygote'


class Indicationtypelist(Enum):
    INDICATION = 'Indication'


class MeasureAttributetype(Enum):
    HGVS = 'HGVS'
    NON_HGVS = 'NonHGVS'
    RS_NUMBER = 'rsNumber'
    LOCATION = 'Location'
    DESCRIPTION = 'Description'
    FUNCTIONAL_CONSEQUENCE = 'FunctionalConsequence'
    MOLECULAR_CONSEQUENCE = 'MolecularConsequence'
    PROTEIN_CHANGE_1_LETTER_CODE = 'ProteinChange1LetterCode'
    HGVSPREVIOUS = 'HGVS, previous'
    DB_VAR_VARIANT_REGION_ID = 'dbVarVariantRegionId'
    DB_VAR_VARIANT_CALL_ID = 'dbVarVariantCallId'
    ACTIVITY_LEVEL = 'ActivityLevel'
    ABSOLUTE_COPY_NUMBER = 'AbsoluteCopyNumber'
    REFERENCE_COPY_NUMBER = 'ReferenceCopyNumber'
    COPY_NUMBER_TUPLE = 'CopyNumberTuple'
    NUCLEOTIDE_CHANGE = 'NucleotideChange'
    COSMIC = 'COSMIC'
    SUBMITTER_VARIANT_ID = 'SubmitterVariantId'
    ISCN_COORDINATES = 'ISCNCoordinates'


class MeasureRelationshipAttributetype(Enum):
    HGVS = 'HGVS'
    GENOTYPE = 'genotype'
    GENERELATIONSHIPS = 'gene relationships'


class MeasureRelationshiptype(Enum):
    VARIANTINGENE = 'variant in gene'
    COOCCURRINGVARIANT = 'co-occurring variant'


class MeasureTraitAttributetype(Enum):
    MODE_OF_INHERITANCE = 'ModeOfInheritance'
    PENETRANCE = 'Penetrance'
    AGE_OF_ONSET = 'AgeOfOnset'
    CLINICAL_SIGNIFICANCE_HISTORY = 'ClinicalSignificanceHistory'
    SEVERITY_DESCRIPTION = 'SeverityDescription'
    ASSERTION_METHOD = 'AssertionMethod'


class MeasuresetAttributetype(Enum):
    LOCATION = 'Location'
    HGVS = 'HGVS'
    DESCRIPTION = 'Description'
    FUNCTIONAL_CONSEQUENCE = 'FunctionalConsequence'
    MOLECULAR_CONSEQUENCE = 'MolecularConsequence'
    ISCN_COORDINATES = 'ISCNCoordinates'


class Measuresettypelist(Enum):
    GENE = 'Gene'
    VARIANT = 'Variant'
    HAPLOTYPE = 'Haplotype'
    PHASEUNKNOWN = 'Phase unknown'
    DISTINCTCHROMOSOMES = 'Distinct chromosomes'


class Measuretype(Enum):
    GENE = 'Gene'
    VARIATION = 'Variation'
    INSERTION = 'Insertion'
    MOBILEELEMENTINSERTION = 'Mobile element insertion'
    NOVELSEQUENCEINSERTION = 'Novel sequence insertion'
    MICROSATELLITE = 'Microsatellite'
    DELETION = 'Deletion'
    SINGLENUCLEOTIDEVARIANT = 'single nucleotide variant'
    MULTIPLENUCLEOTIDEVARIATION = 'Multiple nucleotide variation'
    INDEL = 'Indel'
    DUPLICATION = 'Duplication'
    TANDEMDUPLICATION = 'Tandem duplication'
    COPYNUMBERLOSS = 'copy number loss'
    COPYNUMBERGAIN = 'copy number gain'
    PROTEINONLY = 'protein only'
    INVERSION = 'Inversion'
    TRANSLOCATION = 'Translocation'
    INTERCHROMOSOMALBREAKPOINT = 'Interchromosomal breakpoint'
    INTRACHROMOSOMALBREAKPOINT = 'Intrachromosomal breakpoint'
    COMPLEX = 'Complex'


class Methodtypelist(Enum):
    CURATION = 'curation'
    LITERATUREONLY = 'literature only'
    REFERENCEPOPULATION = 'reference population'
    PROVIDERINTERPRETATION = 'provider interpretation'
    PHENOTYPINGONLY = 'phenotyping only'
    CASECONTROL = 'case-control'
    CLINICALTESTING = 'clinical testing'
    INVITRO = 'in vitro'
    INVIVO = 'in vivo'
    RESEARCH = 'research'
    NOTPROVIDED = 'not provided'


class NameType15(Enum):
    """Need the full controlled list of
    certifications here and include an other."""
    CLIA = 'CLIA'
    CAP = 'CAP'
    NYCLEP = 'NY CLEP'
    AABB = 'AABB'
    EMQN = 'EMQN'
    CA_STATE_LICENSE = 'CA State License'
    MD_STATE_LICENSE = 'MD State License'
    LICENSEFOR_TENNESSEE = 'License for Tennessee'
    LICENSEFOR_FLORIDA = 'License for Florida'
    LICENSEFOR_MARYLAND = 'License for Maryland'


class NameType16(Enum):
    """Need the full controlled list of degrees here and
    include an other."""
    PH_D = 'PhD'
    MD = 'MD'
    MS = 'MS'
    BS = 'BS'


class NameType17(Enum):
    """Need the full controlled list of credentials here and
    include an other."""
    CGC = 'CGC'
    FACMG = 'FACMG'
    MTASCP = 'MT(ASCP)'


class ObsAttributetype(Enum):
    DESCRIPTION = 'Description'
    VARIANT_ALLELES = 'VariantAlleles'
    VARIANT_CHROMOSOMES = 'VariantChromosomes'
    SUBJECTS_WITH_VARIANT = 'SubjectsWithVariant'
    SUBJECTS_ONLY_VARIANT = 'SubjectsOnlyVariant'
    SUBJECTS_WITH_DIFFERENT_CAUSATIVE_VARIANT = 'SubjectsWithDifferentCausativeVariant'
    INDEPENDENT_OBSERVATIONS = 'IndependentObservations'
    SINGLE_HETEROZYGOTE = 'SingleHeterozygote'
    COMPOUND_HETEROZYGOTE = 'CompoundHeterozygote'
    HEMIZYGOTE = 'Hemizygote'
    HOMOZYGOTE = 'Homozygote'
    NUMBER_MOSAIC = 'NumberMosaic'
    OBSERVED_UNSPECIFIED = 'ObservedUnspecified'
    READ_ACCESSION = 'ReadAccession'
    ACTIVITY_LEVEL = 'ActivityLevel'
    SECONDARY_FINDING = 'SecondaryFinding'
    GENOTYPE_AND_MOI_CONSISTENT = 'GenotypeAndMOIConsistent'
    UNAFFECTED_FAMILY_MEMBER_WITH_CAUSATIVE_VARIANT = 'UnaffectedFamilyMemberWithCausativeVariant'
    COSEGREGATING_FAMILIES = 'CosegregatingFamilies'
    HET_PARENT_TRANSMIT_NORMAL_ALLELE = 'HetParentTransmitNormalAllele'
    INFORMATIVE_MEIOSES = 'InformativeMeioses'
    SAMPLE_LOCAL_ID = 'SampleLocalID'
    SUBMITTER_VARIANT_ID = 'SubmitterVariantId'
    SAMPLE_VARIANT_ID = 'SampleVariantID'


class ObsdecAttributetype(Enum):
    ALLELE_FREQUENCY = 'AlleleFrequency'


class OrganizationCategoryList(Enum):
    LAB = 'lab'
    LSDB = 'LSDB'
    CLINIC = 'clinic'
    RESOURCE = 'resource'
    CONSORTIUM = 'consortium'
    PATIENTREGISTRY = 'patient registry'
    OTHER = 'other'


class OrientationType(Enum):
    CIS = 'cis'
    TRANS = 'trans'
    UNKNOWN = 'unknown'


class OriginType(Enum):
    GERMLINE = 'germline'
    SOMATIC = 'somatic'
    DENOVO = 'de novo'
    UNKNOWN = 'unknown'
    NOTPROVIDED = 'not provided'
    INHERITED = 'inherited'
    MATERNAL = 'maternal'
    PATERNAL = 'paternal'
    UNIPARENTAL = 'uniparental'
    BIPARENTAL = 'biparental'
    NOTREPORTED = 'not-reported'
    TESTEDINCONCLUSIVE = 'tested-inconclusive'
    NOTAPPLICABLE = 'not applicable'
    EXPERIMENTALLYGENERATED = 'experimentally generated'


class PathogenicityPropertyType(Enum):
    THISVARIANTINAFEMALEISCAUSATIVE = 'this variant, in a female, is causative'
    THISVARIANTINAMALEISCAUSATIVE = 'this variant, in a male, is causative'
    THISVARIANTISCAUSATIVE = 'this variant is causative'
    THISVARIANTWHENINHERITEDFROMTHEFATHERISCAUSATIVE = 'this variant, when inherited from the father, is causative'
    THISVARIANTWHENINHERITEDFROMTHEMOTHERISCAUSATIVE = 'this variant, when inherited from the mother, is causative'


class RecordStatusType(Enum):
    """Record status is optional, because if not supplied it defaults
    to current."""
    NOVEL = 'novel'
    UPDATE = 'update'
    DELETE = 'delete'


class ReleaseStatusType(Enum):
    PUBLIC = 'public'
    HOLDUNTILPUBLISHED = 'hold until published'


class ResultTypeType(Enum):
    NUMBEROFOCCURRENCES = 'number of occurrences'
    PVALUE = 'p value'
    ODDSRATIO = 'odds ratio'
    VARIANTCALL = 'variant call'


class ReviewStatusType(Enum):
    NOASSERTIONPROVIDED = 'no assertion provided'
    NOASSERTIONCRITERIAPROVIDED = 'no assertion criteria provided'
    CRITERIAPROVIDEDSINGLESUBMITTER = 'criteria provided, single submitter'
    CRITERIAPROVIDEDMULTIPLESUBMITTERSNOCONFLICTS = 'criteria provided, multiple submitters, no conflicts'
    CRITERIAPROVIDEDCONFLICTINGINTERPRETATIONS = 'criteria provided, conflicting interpretations'
    REVIEWEDBYEXPERTPANEL = 'reviewed by expert panel'
    PRACTICEGUIDELINE = 'practice guideline'


class SeverityType(Enum):
    MILD = 'mild'
    MODERATE = 'moderate'
    SEVERE = 'severe'


class SourceTypeType(Enum):
    SUBMITTERGENERATED = 'submitter-generated'
    DATAMINING = 'data mining'
    DATAREVIEW = 'data review'


class StatusTypeList(Enum):
    NOVEL = 'novel'


class Strandtype(Enum):
    _ = '+'
    __1 = '-'


class TitleList(Enum):
    """Need the full controlled list of titles here."""
    LAB_DIRECTOR = 'Lab Director'
    LAB_ASSOCIATE_DIRECTOR = 'Lab Associate Director'
    MEDICAL_DIRECTOR = 'Medical Director'
    GENETIC_COUNSELOR = 'Genetic Counselor'
    NURSE = 'Nurse'
    RESEARCH_NURSE = 'Research Nurse'
    ADMINISTRATOR = 'Administrator'
    STAFF = 'Staff'
    PRINCIPAL_INVESTIGATOR = 'Principal Investigator'
    CONTACT = 'Contact'
    INFORMATICSSTAFF = 'Informatics staff'
    CEO = 'CEO'
    COORDINATOR = 'Coordinator'


class TraitAttributetype(Enum):
    DESCRIPTION = 'description'
    PREVALENCE = 'prevalence'


class TraitRelationshiptype(Enum):
    DISEASE = 'Disease'
    DRUG_RESPONSE = 'DrugResponse'
    DRUG_RESPONSE_AND_DISEASE = 'DrugResponseAndDisease'
    SUBPHENOTYPE = 'Subphenotype'
    BLOOD_GROUP = 'BloodGroup'
    FINDING = 'Finding'
    INFECTION_RESISTANCE = 'InfectionResistance'


class Traitsettypelist(Enum):
    """A trait set allows the submitter to provide one or
    more traits, either characterizing the assertion
    (//ClinvarSubmission/TraitSet)
    or the set of findings (clinical features) characteristic of an observation
    (//ObservedIn/TraitSet). Unless the type is TraitChoice, a
    submission of multiple values is asssumed to represent all values were
    always
    observed, i.e. asserted to be Pathogenic for the co-occurence of
    Disease A and Disease B. If a variant is identified to be Pathogenic for
    Disease A
    and also Pathogeneic for Disease B, these should be submitted as
    distinct ClinvarSubmissions, not as one ClinvarSubmission with a multi-
    member
    TraitSet. If, however, data are not currently available to represent
    distinct submissions, the TraitChoice can be used to indicate an assertion
    is
    about any one of the Traits in the TraitSet."""
    DISEASE = 'Disease'
    DRUG_RESPONSE = 'DrugResponse'
    FINDING = 'Finding'
    PHENOTYPE_INSTRUCTION = 'PhenotypeInstruction'
    TRAIT_CHOICE = 'TraitChoice'


class Traittypelist(Enum):
    DISEASE = 'Disease'
    DRUG_RESPONSE = 'DrugResponse'
    SUBPHENOTYPE = 'Subphenotype'
    BLOOD_GROUP = 'BloodGroup'
    FINDING = 'Finding'
    INFECTION_RESISTANCE = 'InfectionResistance'
    PHENOTYPE_INSTRUCTION = 'PhenotypeInstruction'
    NAMED_PROTEIN_VARIANT = 'NamedProteinVariant'


class ZygosityType(Enum):
    HOMOZYGOTE = 'Homozygote'
    SINGLEHETEROZYGOTE = 'Single heterozygote'
    COMPOUNDHETEROZYGOTE = 'Compound heterozygote'
    HEMIZYGOTE = 'Hemizygote'
    NOTPROVIDED = 'not provided'


class typeIdName(Enum):
    ID = 'id'
    NAME = 'name'


class typeMethodAttributeTypelist(Enum):
    CONTROLS_APPROPRIATE = 'ControlsAppropriate'
    METHOD_APPROPRIATE = 'MethodAppropriate'
    TEST_NAME = 'TestName'
    STRUCT_VAR_METHOD_TYPE = 'StructVarMethodType'
    PROBE_ACCESSION = 'ProbeAccession'


class typeObsMethodAttributeTypelist(Enum):
    METHOD_RESULT = 'MethodResult'
    TESTING_LABORATORY = 'TestingLaboratory'


class typeStatus(Enum):
    CURRENT = 'current'
    COMPLETEDANDRETIRED = 'completed and retired'
    DELETE = 'delete'
    INDEVELOPMENT = 'in development'
    RECLASSIFIED = 'reclassified'
    REJECT = 'reject'
    SECONDARY = 'secondary'
    SUPPRESSED = 'suppressed'
    UNDERREVIEW = 'under review'


class typeContactInfo(GeneratedsSuper):
    """Contact info - an address with email"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, email=None, phone=None, fax=None, Public=False, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.email = _cast(None, email)
        self.email_nsprefix_ = None
        self.phone = _cast(None, phone)
        self.phone_nsprefix_ = None
        self.fax = _cast(None, fax)
        self.fax_nsprefix_ = None
        self.Public = _cast(bool, Public)
        self.Public_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeContactInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeContactInfo.subclass:
            return typeContactInfo.subclass(*args_, **kwargs_)
        else:
            return typeContactInfo(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_email(self):
        return self.email

    def set_email(self, email):
        self.email = email

    def get_phone(self):
        return self.phone

    def set_phone(self, phone):
        self.phone = phone

    def get_fax(self):
        return self.fax

    def set_fax(self, fax):
        self.fax = fax

    def get_Public(self):
        return self.Public

    def set_Public(self, Public):
        self.Public = Public

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='typeContactInfo', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeContactInfo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='typeContactInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='typeContactInfo',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='typeContactInfo'):
        if self.email is not None and 'email' not in already_processed:
            already_processed.add('email')
            outfile.write(
                ' email=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.email), input_name='email')),))
        if self.phone is not None and 'phone' not in already_processed:
            already_processed.add('phone')
            outfile.write(
                ' phone=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.phone), input_name='phone')),))
        if self.fax is not None and 'fax' not in already_processed:
            already_processed.add('fax')
            outfile.write(
                ' fax=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fax), input_name='fax')),))
        if self.Public and 'Public' not in already_processed:
            already_processed.add('Public')
            outfile.write(' Public="%s"' % self.gds_format_boolean(self.Public, input_name='Public'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='typeContactInfo',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('email', node)
        if value is not None and 'email' not in already_processed:
            already_processed.add('email')
            self.email = value
        value = find_attr_value_('phone', node)
        if value is not None and 'phone' not in already_processed:
            already_processed.add('phone')
            self.phone = value
        value = find_attr_value_('fax', node)
        if value is not None and 'fax' not in already_processed:
            already_processed.add('fax')
            self.fax = value
        value = find_attr_value_('Public', node)
        if value is not None and 'Public' not in already_processed:
            already_processed.add('Public')
            if value in ('true', '1'):
                self.Public = True
            elif value in ('false', '0'):
                self.Public = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class typeContactInfo


class typeAccount(GeneratedsSuper):
    """Account - a person with logonLogon nameeRA,pda,NIH,ncbi/ftp-
    private,....."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, user_name=None, authority=None, GTRPersonId=None, Contact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.user_name = _cast(None, user_name)
        self.user_name_nsprefix_ = None
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.GTRPersonId = _cast(int, GTRPersonId)
        self.GTRPersonId_nsprefix_ = None
        self.Contact = Contact
        self.Contact_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeAccount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeAccount.subclass:
            return typeAccount.subclass(*args_, **kwargs_)
        else:
            return typeAccount(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Contact(self):
        return self.Contact

    def set_Contact(self, Contact):
        self.Contact = Contact

    def get_user_name(self):
        return self.user_name

    def set_user_name(self, user_name):
        self.user_name = user_name

    def get_authority(self):
        return self.authority

    def set_authority(self, authority):
        self.authority = authority

    def get_GTRPersonId(self):
        return self.GTRPersonId

    def set_GTRPersonId(self, GTRPersonId):
        self.GTRPersonId = GTRPersonId

    def hasContent_(self):
        if (
                self.Contact is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='typeAccount', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeAccount')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='typeAccount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='typeAccount',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='typeAccount'):
        if self.user_name is not None and 'user_name' not in already_processed:
            already_processed.add('user_name')
            outfile.write(' user_name=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.user_name), input_name='user_name')),))
        if self.authority is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            outfile.write(' authority=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.authority), input_name='authority')),))
        if self.GTRPersonId is not None and 'GTRPersonId' not in already_processed:
            already_processed.add('GTRPersonId')
            outfile.write(' GTRPersonId="%s"' % self.gds_format_integer(self.GTRPersonId, input_name='GTRPersonId'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='typeAccount',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Contact is not None:
            namespaceprefix_ = self.Contact_nsprefix_ + ':' if (UseCapturedNS_ and self.Contact_nsprefix_) else ''
            self.Contact.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Contact',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('user_name', node)
        if value is not None and 'user_name' not in already_processed:
            already_processed.add('user_name')
            self.user_name = value
        value = find_attr_value_('authority', node)
        if value is not None and 'authority' not in already_processed:
            already_processed.add('authority')
            self.authority = value
        value = find_attr_value_('GTRPersonId', node)
        if value is not None and 'GTRPersonId' not in already_processed:
            already_processed.add('GTRPersonId')
            self.GTRPersonId = self.gds_parse_integer(value, node, 'GTRPersonId')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Contact':
            obj_ = typeContactInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Contact = obj_
            obj_.original_tagname_ = 'Contact'


# end class typeAccount


class XrefType(GeneratedsSuper):
    """XRefs are used to represent references to data from external
    databases. These are stored in the ClinVar database to represent objects
    like
    GeneIDs in Gene or MIM numbers in OMIM, and are flexible enough to be used
    broadly.
    The db is the database name used for the external reference (e.g. 'Gene' or
    'OMIM')
    and the ID is that database identifier (e.g. the GeneID or MIM number). The
    type is
    optional and should be used if there are multiple types of identifiers from
    a
    database. For example, from OMIM we may get both MIM numbers and
    identifiers for
    allelic variants; those should be specified as the type for the XRef.
    Expect ID to
    not be provided only if this is used for submitting a URL on it's own. XSD
    does not
    permit choice for attributes so validation of these will need to be in
    another layer
    (XSLT)"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, db=None, type_=None, id=None, URL=None, cv_id=0, Status='current', gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.db = _cast(None, db)
        self.db_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.URL = _cast(None, URL)
        self.URL_nsprefix_ = None
        self.cv_id = _cast(int, cv_id)
        self.cv_id_nsprefix_ = None
        self.Status = _cast(None, Status)
        self.Status_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XrefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XrefType.subclass:
            return XrefType.subclass(*args_, **kwargs_)
        else:
            return XrefType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_db(self):
        return self.db

    def set_db(self, db):
        self.db = db

    def get_type(self):
        return self.type_

    def set_type(self, type_):
        self.type_ = type_

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_URL(self):
        return self.URL

    def set_URL(self, URL):
        self.URL = URL

    def get_cv_id(self):
        return self.cv_id

    def set_cv_id(self, cv_id):
        self.cv_id = cv_id

    def get_Status(self):
        return self.Status

    def set_Status(self, Status):
        self.Status = Status

    def validate_typeStatus(self, value):
        # Validate type typeStatus, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['current', 'completed and retired', 'delete', 'in development', 'reclassified', 'reject',
                            'secondary', 'suppressed', 'under review']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeStatus' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XrefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XrefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XrefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='XrefType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='XrefType'):
        if self.db is not None and 'db' not in already_processed:
            already_processed.add('db')
            outfile.write(' db=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.db), input_name='db')),))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(
                ' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')),))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')),))
        if self.URL is not None and 'URL' not in already_processed:
            already_processed.add('URL')
            outfile.write(
                ' URL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.URL), input_name='URL')),))
        if self.cv_id != 0 and 'cv_id' not in already_processed:
            already_processed.add('cv_id')
            outfile.write(' cv_id="%s"' % self.gds_format_integer(self.cv_id, input_name='cv_id'))
        if self.Status != "current" and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XrefType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('db', node)
        if value is not None and 'db' not in already_processed:
            already_processed.add('db')
            self.db = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('URL', node)
        if value is not None and 'URL' not in already_processed:
            already_processed.add('URL')
            self.URL = value
        value = find_attr_value_('cv_id', node)
        if value is not None and 'cv_id' not in already_processed:
            already_processed.add('cv_id')
            self.cv_id = self.gds_parse_integer(value, node, 'cv_id')
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
            self.validate_typeStatus(self.Status)  # validate type typeStatus

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class XrefType


class CommentType(GeneratedsSuper):
    """A free text comment to submit data (public) or to provide explanations
    for internal use."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, id=0, Status='current', CommentText=None, Type=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.Status = _cast(None, Status)
        self.Status_nsprefix_ = None
        self.CommentText = CommentText
        self.CommentText_nsprefix_ = None
        self.Type = Type
        self.Type_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommentType.subclass:
            return CommentType.subclass(*args_, **kwargs_)
        else:
            return CommentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_CommentText(self):
        return self.CommentText

    def set_CommentText(self, CommentText):
        self.CommentText = CommentText

    def get_Type(self):
        return self.Type

    def set_Type(self, Type):
        self.Type = Type

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_Status(self):
        return self.Status

    def set_Status(self, Status):
        self.Status = Status

    def validate_typeStatus(self, value):
        # Validate type typeStatus, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['current', 'completed and retired', 'delete', 'in development', 'reclassified', 'reject',
                            'secondary', 'suppressed', 'under review']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeStatus' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.CommentText is not None or
                self.Type is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CommentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CommentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CommentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CommentType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CommentType'):
        if self.id != 0 and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.Status != "current" and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CommentType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CommentText is not None:
            namespaceprefix_ = self.CommentText_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CommentText_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCommentText>%s</%sCommentText>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.CommentText), input_name='CommentText')), namespaceprefix_, eol_))
        if self.Type is not None:
            namespaceprefix_ = self.Type_nsprefix_ + ':' if (UseCapturedNS_ and self.Type_nsprefix_) else ''
            self.Type.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Type',
                             pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
            self.validate_typeStatus(self.Status)  # validate type typeStatus

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CommentText':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CommentText')
            value_ = self.gds_validate_string(value_, node, 'CommentText')
            self.CommentText = value_
            self.CommentText_nsprefix_ = child_.prefix
        elif nodeName_ == 'Type':
            obj_ = TypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Type = obj_
            obj_.original_tagname_ = 'Type'


# end class CommentType


class CitationType(GeneratedsSuper):
    """Citations provide the identifers or descriptions of a publication
    that supports a data element. The citation can be any of (1) the
    combination of a
    data source and the identifier used by that source (e.g. PubMed and PubMed
    UID), (2)
    a URL, or (3) a text title."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Rank=None, Abbrev=None, Status='current', cv_id=0, CitationType_member=None, ID=None, URL=None,
                 CitationText=None, Comment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Rank = _cast(int, Rank)
        self.Rank_nsprefix_ = None
        self.Abbrev = _cast(None, Abbrev)
        self.Abbrev_nsprefix_ = None
        self.Status = _cast(None, Status)
        self.Status_nsprefix_ = None
        self.cv_id = _cast(int, cv_id)
        self.cv_id_nsprefix_ = None
        self.CitationType = CitationType_member
        self.CitationType_nsprefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.URL = URL
        self.URL_nsprefix_ = None
        self.CitationText = CitationText
        self.CitationText_nsprefix_ = None
        self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CitationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CitationType.subclass:
            return CitationType.subclass(*args_, **kwargs_)
        else:
            return CitationType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_CitationType(self):
        return self.CitationType

    def set_CitationType(self, CitationType):
        self.CitationType = CitationType

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_URL(self):
        return self.URL

    def set_URL(self, URL):
        self.URL = URL

    def get_CitationText(self):
        return self.CitationText

    def set_CitationText(self, CitationText):
        self.CitationText = CitationText

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def get_Rank(self):
        return self.Rank

    def set_Rank(self, Rank):
        self.Rank = Rank

    def get_Abbrev(self):
        return self.Abbrev

    def set_Abbrev(self, Abbrev):
        self.Abbrev = Abbrev

    def get_Status(self):
        return self.Status

    def set_Status(self, Status):
        self.Status = Status

    def get_cv_id(self):
        return self.cv_id

    def set_cv_id(self, cv_id):
        self.cv_id = cv_id

    def validate_typeStatus(self, value):
        # Validate type typeStatus, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['current', 'completed and retired', 'delete', 'in development', 'reclassified', 'reject',
                            'secondary', 'suppressed', 'under review']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeStatus' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.CitationType is not None or
                self.ID is not None or
                self.URL is not None or
                self.CitationText is not None or
                self.Comment is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CitationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CitationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CitationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CitationType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CitationType'):
        if self.Rank is not None and 'Rank' not in already_processed:
            already_processed.add('Rank')
            outfile.write(' Rank="%s"' % self.gds_format_integer(self.Rank, input_name='Rank'))
        if self.Abbrev is not None and 'Abbrev' not in already_processed:
            already_processed.add('Abbrev')
            outfile.write(' Abbrev=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.Abbrev), input_name='Abbrev')),))
        if self.Status != "current" and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')),))
        if self.cv_id != 0 and 'cv_id' not in already_processed:
            already_processed.add('cv_id')
            outfile.write(' cv_id="%s"' % self.gds_format_integer(self.cv_id, input_name='cv_id'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CitationType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CitationType is not None:
            namespaceprefix_ = self.CitationType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CitationType_nsprefix_) else ''
            self.CitationType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CitationType',
                                     pretty_print=pretty_print)
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            self.ID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ID', pretty_print=pretty_print)
        if self.URL is not None:
            namespaceprefix_ = self.URL_nsprefix_ + ':' if (UseCapturedNS_ and self.URL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.URL), input_name='URL')),
            namespaceprefix_, eol_))
        if self.CitationText is not None:
            namespaceprefix_ = self.CitationText_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CitationText_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCitationText>%s</%sCitationText>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.CitationText), input_name='CitationText')), namespaceprefix_,
                                                                     eol_))
        if self.Comment is not None:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            self.Comment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Rank', node)
        if value is not None and 'Rank' not in already_processed:
            already_processed.add('Rank')
            self.Rank = self.gds_parse_integer(value, node, 'Rank')
        value = find_attr_value_('Abbrev', node)
        if value is not None and 'Abbrev' not in already_processed:
            already_processed.add('Abbrev')
            self.Abbrev = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
            self.validate_typeStatus(self.Status)  # validate type typeStatus
        value = find_attr_value_('cv_id', node)
        if value is not None and 'cv_id' not in already_processed:
            already_processed.add('cv_id')
            self.cv_id = self.gds_parse_integer(value, node, 'cv_id')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CitationType':
            obj_ = CitationTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CitationType = obj_
            obj_.original_tagname_ = 'CitationType'
        elif nodeName_ == 'ID':
            obj_ = IDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ID = obj_
            obj_.original_tagname_ = 'ID'
        elif nodeName_ == 'URL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'URL')
            value_ = self.gds_validate_string(value_, node, 'URL')
            self.URL = value_
            self.URL_nsprefix_ = child_.prefix
        elif nodeName_ == 'CitationText':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CitationText')
            value_ = self.gds_validate_string(value_, node, 'CitationText')
            self.CitationText = value_
            self.CitationText_nsprefix_ = child_.prefix
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'


# end class CitationType


class AttributeType(GeneratedsSuper):
    """The attribute is a general element to represent a defined set of data
    qualified by an enumerated set of types. For each attribute element, the
    value will
    be a character string and is optional. Source shall be used to store
    identifiers for
    supplied data from source other than the submitter (e.g. SequenceOntology).
    The data
    submitted where Type="variation" shall be validated against
    sequence_alternation in
    Sequence Ontology http://www.sequenceontology.org/. This is to be a generic
    version
    of AttributeType and should be used with extension when it is used to
    specify Type
    and its enumerations."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, integerValue=None, dateValue=None, source=None, Status='current', pubStat='3', id=None,
                 ncbi_id=None, id_status=None, uid=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.integerValue = _cast(int, integerValue)
        self.integerValue_nsprefix_ = None
        if isinstance(dateValue, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateValue, '%Y-%m-%d').date()
        else:
            initvalue_ = dateValue
        self.dateValue = initvalue_
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.Status = _cast(None, Status)
        self.Status_nsprefix_ = None
        self.pubStat = _cast(None, pubStat)
        self.pubStat_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeType.subclass:
            return AttributeType.subclass(*args_, **kwargs_)
        else:
            return AttributeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_integerValue(self):
        return self.integerValue

    def set_integerValue(self, integerValue):
        self.integerValue = integerValue

    def get_dateValue(self):
        return self.dateValue

    def set_dateValue(self, dateValue):
        self.dateValue = dateValue

    def get_source(self):
        return self.source

    def set_source(self, source):
        self.source = source

    def get_Status(self):
        return self.Status

    def set_Status(self, Status):
        self.Status = Status

    def get_pubStat(self):
        return self.pubStat

    def set_pubStat(self, pubStat):
        self.pubStat = pubStat

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeStatus(self, value):
        # Validate type typeStatus, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['current', 'completed and retired', 'delete', 'in development', 'reclassified', 'reject',
                            'secondary', 'suppressed', 'under review']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeStatus' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AttributeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AttributeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AttributeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AttributeType'):
        if self.integerValue is not None and 'integerValue' not in already_processed:
            already_processed.add('integerValue')
            outfile.write(' integerValue="%s"' % self.gds_format_integer(self.integerValue, input_name='integerValue'))
        if self.dateValue is not None and 'dateValue' not in already_processed:
            already_processed.add('dateValue')
            outfile.write(' dateValue="%s"' % self.gds_format_date(self.dateValue, input_name='dateValue'))
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')),))
        if self.Status != "current" and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')),))
        if self.pubStat != "3" and 'pubStat' not in already_processed:
            already_processed.add('pubStat')
            outfile.write(' pubStat=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.pubStat), input_name='pubStat')),))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('integerValue', node)
        if value is not None and 'integerValue' not in already_processed:
            already_processed.add('integerValue')
            self.integerValue = self.gds_parse_integer(value, node, 'integerValue')
        value = find_attr_value_('dateValue', node)
        if value is not None and 'dateValue' not in already_processed:
            already_processed.add('dateValue')
            try:
                self.dateValue = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (dateValue): %s' % exp)
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
            self.validate_typeStatus(self.Status)  # validate type typeStatus
        value = find_attr_value_('pubStat', node)
        if value is not None and 'pubStat' not in already_processed:
            already_processed.add('pubStat')
            self.pubStat = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class AttributeType


class AttributeBundleType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, AttributeType=None, Attribute=None, Citation=None, XRef=None, Comment=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.AttributeType = AttributeType
        self.AttributeType_nsprefix_ = None
        self.Attribute = Attribute
        self.Attribute_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeBundleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeBundleType.subclass:
            return AttributeBundleType.subclass(*args_, **kwargs_)
        else:
            return AttributeBundleType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AttributeType(self):
        return self.AttributeType

    def set_AttributeType(self, AttributeType):
        self.AttributeType = AttributeType

    def get_Attribute(self):
        return self.Attribute

    def set_Attribute(self, Attribute):
        self.Attribute = Attribute

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def hasContent_(self):
        if (
                self.AttributeType is not None or
                self.Attribute is not None or
                self.Citation or
                self.XRef or
                self.Comment is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeBundleType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AttributeBundleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AttributeBundleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AttributeBundleType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AttributeBundleType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeBundleType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AttributeType is not None:
            namespaceprefix_ = self.AttributeType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AttributeType_nsprefix_) else ''
            self.AttributeType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AttributeType',
                                      pretty_print=pretty_print)
        if self.Attribute is not None:
            namespaceprefix_ = self.Attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.Attribute_nsprefix_) else ''
            self.Attribute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Attribute',
                                  pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        if self.Comment is not None:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            self.Comment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AttributeType':
            obj_ = AttributeTypeType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AttributeType = obj_
            obj_.original_tagname_ = 'AttributeType'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'


# end class AttributeBundleType


class AttributeTypeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeTypeType.subclass:
            return AttributeTypeType.subclass(*args_, **kwargs_)
        else:
            return AttributeTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AttributeTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AttributeTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AttributeTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AttributeTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class AttributeTypeType


class SoftwareSet(GeneratedsSuper):
    """Structure to describe the name, version, and use of code used in a
    particular method."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, name=None, version=None, purpose=None, cv_id=0, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.purpose = _cast(None, purpose)
        self.purpose_nsprefix_ = None
        self.cv_id = _cast(int, cv_id)
        self.cv_id_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SoftwareSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SoftwareSet.subclass:
            return SoftwareSet.subclass(*args_, **kwargs_)
        else:
            return SoftwareSet(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_name(self):
        return self.name

    def set_name(self, name):
        self.name = name

    def get_version(self):
        return self.version

    def set_version(self, version):
        self.version = version

    def get_purpose(self):
        return self.purpose

    def set_purpose(self, purpose):
        self.purpose = purpose

    def get_cv_id(self):
        return self.cv_id

    def set_cv_id(self, cv_id):
        self.cv_id = cv_id

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SoftwareSet', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SoftwareSet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SoftwareSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SoftwareSet',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SoftwareSet'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(
                ' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')),))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')),))
        if self.purpose is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            outfile.write(' purpose=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.purpose), input_name='purpose')),))
        if self.cv_id != 0 and 'cv_id' not in already_processed:
            already_processed.add('cv_id')
            outfile.write(' cv_id="%s"' % self.gds_format_integer(self.cv_id, input_name='cv_id'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SoftwareSet',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('purpose', node)
        if value is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            self.purpose = value
        value = find_attr_value_('cv_id', node)
        if value is not None and 'cv_id' not in already_processed:
            already_processed.add('cv_id')
            self.cv_id = self.gds_parse_integer(value, node, 'cv_id')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class SoftwareSet


class FamilyInfo(GeneratedsSuper):
    """Structure to describe attributes of any family data in an observation.
    If the details of the number of families and the de-identified pedigree id
    are not
    available, use FamilyHistory to describe what type of family data is
    available. Can also be used to report 'Yes' or 'No' if there are no
    more details."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, NumFamilies=None, NumFamiliesWithVariant=None, NumFamiliesWithSegregationObserved=None,
                 PedigreeID=None, SegregationObserved=None, FamilyHistory=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NumFamilies = _cast(int, NumFamilies)
        self.NumFamilies_nsprefix_ = None
        self.NumFamiliesWithVariant = _cast(int, NumFamiliesWithVariant)
        self.NumFamiliesWithVariant_nsprefix_ = None
        self.NumFamiliesWithSegregationObserved = _cast(int, NumFamiliesWithSegregationObserved)
        self.NumFamiliesWithSegregationObserved_nsprefix_ = None
        self.PedigreeID = _cast(None, PedigreeID)
        self.PedigreeID_nsprefix_ = None
        self.SegregationObserved = _cast(None, SegregationObserved)
        self.SegregationObserved_nsprefix_ = None
        self.FamilyHistory = FamilyHistory
        self.FamilyHistory_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FamilyInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FamilyInfo.subclass:
            return FamilyInfo.subclass(*args_, **kwargs_)
        else:
            return FamilyInfo(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_FamilyHistory(self):
        return self.FamilyHistory

    def set_FamilyHistory(self, FamilyHistory):
        self.FamilyHistory = FamilyHistory

    def get_NumFamilies(self):
        return self.NumFamilies

    def set_NumFamilies(self, NumFamilies):
        self.NumFamilies = NumFamilies

    def get_NumFamiliesWithVariant(self):
        return self.NumFamiliesWithVariant

    def set_NumFamiliesWithVariant(self, NumFamiliesWithVariant):
        self.NumFamiliesWithVariant = NumFamiliesWithVariant

    def get_NumFamiliesWithSegregationObserved(self):
        return self.NumFamiliesWithSegregationObserved

    def set_NumFamiliesWithSegregationObserved(self, NumFamiliesWithSegregationObserved):
        self.NumFamiliesWithSegregationObserved = NumFamiliesWithSegregationObserved

    def get_PedigreeID(self):
        return self.PedigreeID

    def set_PedigreeID(self, PedigreeID):
        self.PedigreeID = PedigreeID

    def get_SegregationObserved(self):
        return self.SegregationObserved

    def set_SegregationObserved(self, SegregationObserved):
        self.SegregationObserved = SegregationObserved

    def hasContent_(self):
        if (
                self.FamilyHistory is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FamilyInfo', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FamilyInfo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FamilyInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FamilyInfo',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FamilyInfo'):
        if self.NumFamilies is not None and 'NumFamilies' not in already_processed:
            already_processed.add('NumFamilies')
            outfile.write(' NumFamilies="%s"' % self.gds_format_integer(self.NumFamilies, input_name='NumFamilies'))
        if self.NumFamiliesWithVariant is not None and 'NumFamiliesWithVariant' not in already_processed:
            already_processed.add('NumFamiliesWithVariant')
            outfile.write(' NumFamiliesWithVariant="%s"' % self.gds_format_integer(self.NumFamiliesWithVariant,
                                                                                   input_name='NumFamiliesWithVariant'))
        if self.NumFamiliesWithSegregationObserved is not None and 'NumFamiliesWithSegregationObserved' not in already_processed:
            already_processed.add('NumFamiliesWithSegregationObserved')
            outfile.write(' NumFamiliesWithSegregationObserved="%s"' % self.gds_format_integer(
                self.NumFamiliesWithSegregationObserved, input_name='NumFamiliesWithSegregationObserved'))
        if self.PedigreeID is not None and 'PedigreeID' not in already_processed:
            already_processed.add('PedigreeID')
            outfile.write(' PedigreeID=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.PedigreeID), input_name='PedigreeID')),))
        if self.SegregationObserved is not None and 'SegregationObserved' not in already_processed:
            already_processed.add('SegregationObserved')
            outfile.write(' SegregationObserved=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.SegregationObserved), input_name='SegregationObserved')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FamilyInfo',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FamilyHistory is not None:
            namespaceprefix_ = self.FamilyHistory_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.FamilyHistory_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFamilyHistory>%s</%sFamilyHistory>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.FamilyHistory), input_name='FamilyHistory')), namespaceprefix_,
                                                                       eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NumFamilies', node)
        if value is not None and 'NumFamilies' not in already_processed:
            already_processed.add('NumFamilies')
            self.NumFamilies = self.gds_parse_integer(value, node, 'NumFamilies')
        value = find_attr_value_('NumFamiliesWithVariant', node)
        if value is not None and 'NumFamiliesWithVariant' not in already_processed:
            already_processed.add('NumFamiliesWithVariant')
            self.NumFamiliesWithVariant = self.gds_parse_integer(value, node, 'NumFamiliesWithVariant')
        value = find_attr_value_('NumFamiliesWithSegregationObserved', node)
        if value is not None and 'NumFamiliesWithSegregationObserved' not in already_processed:
            already_processed.add('NumFamiliesWithSegregationObserved')
            self.NumFamiliesWithSegregationObserved = self.gds_parse_integer(value, node,
                                                                             'NumFamiliesWithSegregationObserved')
        value = find_attr_value_('PedigreeID', node)
        if value is not None and 'PedigreeID' not in already_processed:
            already_processed.add('PedigreeID')
            self.PedigreeID = value
        value = find_attr_value_('SegregationObserved', node)
        if value is not None and 'SegregationObserved' not in already_processed:
            already_processed.add('SegregationObserved')
            self.SegregationObserved = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FamilyHistory':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FamilyHistory')
            value_ = self.gds_validate_string(value_, node, 'FamilyHistory')
            self.FamilyHistory = value_
            self.FamilyHistory_nsprefix_ = child_.prefix


# end class FamilyInfo


class SetElementSetType(GeneratedsSuper):
    """The attribute set groups an attribute and citations for that
    attribute. We allow citations for each attribute."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, derived_by=None, id=None, ncbi_id=None, id_status=None, uid=None, ElementValueType=None,
                 ElementValue=None, XRef=None, Citation=None, Comment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.derived_by = _cast(None, derived_by)
        self.derived_by_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.ElementValueType = ElementValueType
        self.ElementValueType_nsprefix_ = None
        self.ElementValue = ElementValue
        self.ElementValue_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SetElementSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SetElementSetType.subclass:
            return SetElementSetType.subclass(*args_, **kwargs_)
        else:
            return SetElementSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ElementValueType(self):
        return self.ElementValueType

    def set_ElementValueType(self, ElementValueType):
        self.ElementValueType = ElementValueType

    def get_ElementValue(self):
        return self.ElementValue

    def set_ElementValue(self, ElementValue):
        self.ElementValue = ElementValue

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def add_Comment(self, value):
        self.Comment.append(value)

    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)

    def replace_Comment_at(self, index, value):
        self.Comment[index] = value

    def get_derived_by(self):
        return self.derived_by

    def set_derived_by(self, derived_by):
        self.derived_by = derived_by

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.ElementValueType is not None or
                self.ElementValue is not None or
                self.XRef or
                self.Citation or
                self.Comment
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SetElementSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SetElementSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SetElementSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SetElementSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SetElementSetType'):
        if self.derived_by is not None and 'derived_by' not in already_processed:
            already_processed.add('derived_by')
            outfile.write(' derived_by=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.derived_by), input_name='derived_by')),))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SetElementSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ElementValueType is not None:
            namespaceprefix_ = self.ElementValueType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ElementValueType_nsprefix_) else ''
            self.ElementValueType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ElementValueType',
                                         pretty_print=pretty_print)
        if self.ElementValue is not None:
            namespaceprefix_ = self.ElementValue_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ElementValue_nsprefix_) else ''
            self.ElementValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ElementValue',
                                     pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for Comment_ in self.Comment:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            Comment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                            pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('derived_by', node)
        if value is not None and 'derived_by' not in already_processed:
            already_processed.add('derived_by')
            self.derived_by = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ElementValueType':
            obj_ = ElementValueTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ElementValueType = obj_
            obj_.original_tagname_ = 'ElementValueType'
        elif nodeName_ == 'ElementValue':
            obj_ = ElementValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ElementValue = obj_
            obj_.original_tagname_ = 'ElementValue'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'


# end class SetElementSetType


class AttributeDecimalType(GeneratedsSuper):
    """The attribute is a general element to represent a defined set of data
    qualified by an enumerated set of types. For each decimal attribute
    element, the
    value will be a decimal and is optional. Source shall be used to store
    identifiers
    for supplied data from source other than the submitter (e.g.
    SequenceOntology). This
    is a generic version for decimal attributes and should be used with
    extension when
    it is used to specify Type and its enumerations. The integerValue attribute
    type is
    retained as an option because the generic structure of this element
    could support a decimal value being submitted with some qualifying
    integer value as well."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, integerValue=None, dateValue=None, source=None, Status='current', id=None, ncbi_id=None,
                 id_status=None, uid=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.integerValue = _cast(int, integerValue)
        self.integerValue_nsprefix_ = None
        if isinstance(dateValue, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateValue, '%Y-%m-%d').date()
        else:
            initvalue_ = dateValue
        self.dateValue = initvalue_
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.Status = _cast(None, Status)
        self.Status_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeDecimalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeDecimalType.subclass:
            return AttributeDecimalType.subclass(*args_, **kwargs_)
        else:
            return AttributeDecimalType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_integerValue(self):
        return self.integerValue

    def set_integerValue(self, integerValue):
        self.integerValue = integerValue

    def get_dateValue(self):
        return self.dateValue

    def set_dateValue(self, dateValue):
        self.dateValue = dateValue

    def get_source(self):
        return self.source

    def set_source(self, source):
        self.source = source

    def get_Status(self):
        return self.Status

    def set_Status(self, Status):
        self.Status = Status

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeStatus(self, value):
        # Validate type typeStatus, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['current', 'completed and retired', 'delete', 'in development', 'reclassified', 'reject',
                            'secondary', 'suppressed', 'under review']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeStatus' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeDecimalType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AttributeDecimalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AttributeDecimalType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AttributeDecimalType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AttributeDecimalType'):
        if self.integerValue is not None and 'integerValue' not in already_processed:
            already_processed.add('integerValue')
            outfile.write(' integerValue="%s"' % self.gds_format_integer(self.integerValue, input_name='integerValue'))
        if self.dateValue is not None and 'dateValue' not in already_processed:
            already_processed.add('dateValue')
            outfile.write(' dateValue="%s"' % self.gds_format_date(self.dateValue, input_name='dateValue'))
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')),))
        if self.Status != "current" and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')),))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeDecimalType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('integerValue', node)
        if value is not None and 'integerValue' not in already_processed:
            already_processed.add('integerValue')
            self.integerValue = self.gds_parse_integer(value, node, 'integerValue')
        value = find_attr_value_('dateValue', node)
        if value is not None and 'dateValue' not in already_processed:
            already_processed.add('dateValue')
            try:
                self.dateValue = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (dateValue): %s' % exp)
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
            self.validate_typeStatus(self.Status)  # validate type typeStatus
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class AttributeDecimalType


class MethodType(GeneratedsSuper):
    """Details of a method used to generate variant calls or predict/report
    functional consequence. The name of the platform should represent a
    sequencer or an
    array, e.g. sequencing or array , e.g. capillary, 454, Helicos, Solexa,
    SOLiD. This
    structure should also be used if the method is 'Curation'."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, id=None, ncbi_id=None, id_status=None, uid=None, NamePlatform=None, TypePlatform=None,
                 Purpose=None, ResultType=None, MinReported=None, MaxReported=None, ReferenceStandard=None,
                 Citation=None, XRef=None, Description=None, Software=None, SourceType=None, MethodType_member=None,
                 MethodAttribute=None, ObsMethodAttribute=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.NamePlatform = NamePlatform
        self.NamePlatform_nsprefix_ = None
        self.TypePlatform = TypePlatform
        self.TypePlatform_nsprefix_ = None
        self.Purpose = Purpose
        self.Purpose_nsprefix_ = None
        self.ResultType = ResultType
        self.validate_ResultTypeType(self.ResultType)
        self.ResultType_nsprefix_ = None
        self.MinReported = MinReported
        self.MinReported_nsprefix_ = None
        self.MaxReported = MaxReported
        self.MaxReported_nsprefix_ = None
        self.ReferenceStandard = ReferenceStandard
        self.ReferenceStandard_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        self.Description = Description
        self.Description_nsprefix_ = None
        if Software is None:
            self.Software = []
        else:
            self.Software = Software
        self.Software_nsprefix_ = None
        self.SourceType = SourceType
        self.validate_SourceTypeType(self.SourceType)
        self.SourceType_nsprefix_ = None
        self.MethodType = MethodType_member
        self.MethodType_nsprefix_ = None
        if MethodAttribute is None:
            self.MethodAttribute = []
        else:
            self.MethodAttribute = MethodAttribute
        self.MethodAttribute_nsprefix_ = None
        if ObsMethodAttribute is None:
            self.ObsMethodAttribute = []
        else:
            self.ObsMethodAttribute = ObsMethodAttribute
        self.ObsMethodAttribute_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MethodType.subclass:
            return MethodType.subclass(*args_, **kwargs_)
        else:
            return MethodType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_NamePlatform(self):
        return self.NamePlatform

    def set_NamePlatform(self, NamePlatform):
        self.NamePlatform = NamePlatform

    def get_TypePlatform(self):
        return self.TypePlatform

    def set_TypePlatform(self, TypePlatform):
        self.TypePlatform = TypePlatform

    def get_Purpose(self):
        return self.Purpose

    def set_Purpose(self, Purpose):
        self.Purpose = Purpose

    def get_ResultType(self):
        return self.ResultType

    def set_ResultType(self, ResultType):
        self.ResultType = ResultType

    def get_MinReported(self):
        return self.MinReported

    def set_MinReported(self, MinReported):
        self.MinReported = MinReported

    def get_MaxReported(self):
        return self.MaxReported

    def set_MaxReported(self, MaxReported):
        self.MaxReported = MaxReported

    def get_ReferenceStandard(self):
        return self.ReferenceStandard

    def set_ReferenceStandard(self, ReferenceStandard):
        self.ReferenceStandard = ReferenceStandard

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Description(self):
        return self.Description

    def set_Description(self, Description):
        self.Description = Description

    def get_Software(self):
        return self.Software

    def set_Software(self, Software):
        self.Software = Software

    def add_Software(self, value):
        self.Software.append(value)

    def insert_Software_at(self, index, value):
        self.Software.insert(index, value)

    def replace_Software_at(self, index, value):
        self.Software[index] = value

    def get_SourceType(self):
        return self.SourceType

    def set_SourceType(self, SourceType):
        self.SourceType = SourceType

    def get_MethodType(self):
        return self.MethodType

    def set_MethodType(self, MethodType):
        self.MethodType = MethodType

    def get_MethodAttribute(self):
        return self.MethodAttribute

    def set_MethodAttribute(self, MethodAttribute):
        self.MethodAttribute = MethodAttribute

    def add_MethodAttribute(self, value):
        self.MethodAttribute.append(value)

    def insert_MethodAttribute_at(self, index, value):
        self.MethodAttribute.insert(index, value)

    def replace_MethodAttribute_at(self, index, value):
        self.MethodAttribute[index] = value

    def get_ObsMethodAttribute(self):
        return self.ObsMethodAttribute

    def set_ObsMethodAttribute(self, ObsMethodAttribute):
        self.ObsMethodAttribute = ObsMethodAttribute

    def add_ObsMethodAttribute(self, value):
        self.ObsMethodAttribute.append(value)

    def insert_ObsMethodAttribute_at(self, index, value):
        self.ObsMethodAttribute.insert(index, value)

    def replace_ObsMethodAttribute_at(self, index, value):
        self.ObsMethodAttribute[index] = value

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_ResultTypeType(self, value):
        result = True
        # Validate type ResultTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['number of occurrences', 'p value', 'odds ratio', 'variant call']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ResultTypeType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def validate_SourceTypeType(self, value):
        result = True
        # Validate type SourceTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['submitter-generated', 'data mining', 'data review']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SourceTypeType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.NamePlatform is not None or
                self.TypePlatform is not None or
                self.Purpose is not None or
                self.ResultType is not None or
                self.MinReported is not None or
                self.MaxReported is not None or
                self.ReferenceStandard is not None or
                self.Citation or
                self.XRef or
                self.Description is not None or
                self.Software or
                self.SourceType is not None or
                self.MethodType is not None or
                self.MethodAttribute or
                self.ObsMethodAttribute
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MethodType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MethodType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MethodType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MethodType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NamePlatform is not None:
            namespaceprefix_ = self.NamePlatform_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.NamePlatform_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNamePlatform>%s</%sNamePlatform>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.NamePlatform), input_name='NamePlatform')), namespaceprefix_,
                                                                     eol_))
        if self.TypePlatform is not None:
            namespaceprefix_ = self.TypePlatform_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TypePlatform_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTypePlatform>%s</%sTypePlatform>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.TypePlatform), input_name='TypePlatform')), namespaceprefix_,
                                                                     eol_))
        if self.Purpose is not None:
            namespaceprefix_ = self.Purpose_nsprefix_ + ':' if (UseCapturedNS_ and self.Purpose_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPurpose>%s</%sPurpose>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Purpose), input_name='Purpose')),
            namespaceprefix_, eol_))
        if self.ResultType is not None:
            namespaceprefix_ = self.ResultType_nsprefix_ + ':' if (UseCapturedNS_ and self.ResultType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResultType>%s</%sResultType>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.ResultType), input_name='ResultType')), namespaceprefix_, eol_))
        if self.MinReported is not None:
            namespaceprefix_ = self.MinReported_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MinReported_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMinReported>%s</%sMinReported>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.MinReported), input_name='MinReported')), namespaceprefix_, eol_))
        if self.MaxReported is not None:
            namespaceprefix_ = self.MaxReported_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MaxReported_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxReported>%s</%sMaxReported>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.MaxReported), input_name='MaxReported')), namespaceprefix_, eol_))
        if self.ReferenceStandard is not None:
            namespaceprefix_ = self.ReferenceStandard_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ReferenceStandard_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReferenceStandard>%s</%sReferenceStandard>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.ReferenceStandard), input_name='ReferenceStandard')),
                                                                               namespaceprefix_, eol_))
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        if self.Description is not None:
            namespaceprefix_ = self.Description_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.Description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.Description), input_name='Description')), namespaceprefix_, eol_))
        for Software_ in self.Software:
            namespaceprefix_ = self.Software_nsprefix_ + ':' if (UseCapturedNS_ and self.Software_nsprefix_) else ''
            Software_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Software',
                             pretty_print=pretty_print)
        if self.SourceType is not None:
            namespaceprefix_ = self.SourceType_nsprefix_ + ':' if (UseCapturedNS_ and self.SourceType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourceType>%s</%sSourceType>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.SourceType), input_name='SourceType')), namespaceprefix_, eol_))
        if self.MethodType is not None:
            namespaceprefix_ = self.MethodType_nsprefix_ + ':' if (UseCapturedNS_ and self.MethodType_nsprefix_) else ''
            self.MethodType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MethodType',
                                   pretty_print=pretty_print)
        for MethodAttribute_ in self.MethodAttribute:
            namespaceprefix_ = self.MethodAttribute_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MethodAttribute_nsprefix_) else ''
            MethodAttribute_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MethodAttribute',
                                    pretty_print=pretty_print)
        for ObsMethodAttribute_ in self.ObsMethodAttribute:
            namespaceprefix_ = self.ObsMethodAttribute_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ObsMethodAttribute_nsprefix_) else ''
            ObsMethodAttribute_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ObsMethodAttribute',
                                       pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NamePlatform':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NamePlatform')
            value_ = self.gds_validate_string(value_, node, 'NamePlatform')
            self.NamePlatform = value_
            self.NamePlatform_nsprefix_ = child_.prefix
        elif nodeName_ == 'TypePlatform':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TypePlatform')
            value_ = self.gds_validate_string(value_, node, 'TypePlatform')
            self.TypePlatform = value_
            self.TypePlatform_nsprefix_ = child_.prefix
        elif nodeName_ == 'Purpose':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Purpose')
            value_ = self.gds_validate_string(value_, node, 'Purpose')
            self.Purpose = value_
            self.Purpose_nsprefix_ = child_.prefix
        elif nodeName_ == 'ResultType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ResultType')
            value_ = self.gds_validate_string(value_, node, 'ResultType')
            self.ResultType = value_
            self.ResultType_nsprefix_ = child_.prefix
            # validate type ResultTypeType
            self.validate_ResultTypeType(self.ResultType)
        elif nodeName_ == 'MinReported':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MinReported')
            value_ = self.gds_validate_string(value_, node, 'MinReported')
            self.MinReported = value_
            self.MinReported_nsprefix_ = child_.prefix
        elif nodeName_ == 'MaxReported':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MaxReported')
            value_ = self.gds_validate_string(value_, node, 'MaxReported')
            self.MaxReported = value_
            self.MaxReported_nsprefix_ = child_.prefix
        elif nodeName_ == 'ReferenceStandard':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ReferenceStandard')
            value_ = self.gds_validate_string(value_, node, 'ReferenceStandard')
            self.ReferenceStandard = value_
            self.ReferenceStandard_nsprefix_ = child_.prefix
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Description')
            value_ = self.gds_validate_string(value_, node, 'Description')
            self.Description = value_
            self.Description_nsprefix_ = child_.prefix
        elif nodeName_ == 'Software':
            obj_ = SoftwareSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Software.append(obj_)
            obj_.original_tagname_ = 'Software'
        elif nodeName_ == 'SourceType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SourceType')
            value_ = self.gds_validate_string(value_, node, 'SourceType')
            self.SourceType = value_
            self.SourceType_nsprefix_ = child_.prefix
            # validate type SourceTypeType
            self.validate_SourceTypeType(self.SourceType)
        elif nodeName_ == 'MethodType':
            obj_ = MethodTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MethodType = obj_
            obj_.original_tagname_ = 'MethodType'
        elif nodeName_ == 'MethodAttribute':
            obj_ = MethodAttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MethodAttribute.append(obj_)
            obj_.original_tagname_ = 'MethodAttribute'
        elif nodeName_ == 'ObsMethodAttribute':
            obj_ = ObsMethodAttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ObsMethodAttribute.append(obj_)
            obj_.original_tagname_ = 'ObsMethodAttribute'


# end class MethodType


class MethodAttributeTypeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MethodAttributeTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MethodAttributeTypeType.subclass:
            return MethodAttributeTypeType.subclass(*args_, **kwargs_)
        else:
            return MethodAttributeTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MethodAttributeTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MethodAttributeTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MethodAttributeTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MethodAttributeTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MethodAttributeTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MethodAttributeTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class MethodAttributeTypeType


class MethodAttributeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, AttributeType=None, Attribute=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.AttributeType = AttributeType
        self.AttributeType_nsprefix_ = None
        self.Attribute = Attribute
        self.Attribute_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MethodAttributeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MethodAttributeType.subclass:
            return MethodAttributeType.subclass(*args_, **kwargs_)
        else:
            return MethodAttributeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AttributeType(self):
        return self.AttributeType

    def set_AttributeType(self, AttributeType):
        self.AttributeType = AttributeType

    def get_Attribute(self):
        return self.Attribute

    def set_Attribute(self, Attribute):
        self.Attribute = Attribute

    def hasContent_(self):
        if (
                self.AttributeType is not None or
                self.Attribute is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MethodAttributeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MethodAttributeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MethodAttributeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MethodAttributeType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MethodAttributeType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MethodAttributeType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AttributeType is not None:
            namespaceprefix_ = self.AttributeType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AttributeType_nsprefix_) else ''
            self.AttributeType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AttributeType',
                                      pretty_print=pretty_print)
        if self.Attribute is not None:
            namespaceprefix_ = self.Attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.Attribute_nsprefix_) else ''
            self.Attribute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Attribute',
                                  pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AttributeType':
            obj_ = AttributeTypeType2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AttributeType = obj_
            obj_.original_tagname_ = 'AttributeType'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'


# end class MethodAttributeType


class ObsMethodAttributeTypeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObsMethodAttributeTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObsMethodAttributeTypeType.subclass:
            return ObsMethodAttributeTypeType.subclass(*args_, **kwargs_)
        else:
            return ObsMethodAttributeTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObsMethodAttributeTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObsMethodAttributeTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObsMethodAttributeTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObsMethodAttributeTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ObsMethodAttributeTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObsMethodAttributeTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ObsMethodAttributeTypeType


class ObsMethodAttributeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, AttributeType=None, Attribute=None, Comment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.AttributeType = AttributeType
        self.AttributeType_nsprefix_ = None
        self.Attribute = Attribute
        self.Attribute_nsprefix_ = None
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObsMethodAttributeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObsMethodAttributeType.subclass:
            return ObsMethodAttributeType.subclass(*args_, **kwargs_)
        else:
            return ObsMethodAttributeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AttributeType(self):
        return self.AttributeType

    def set_AttributeType(self, AttributeType):
        self.AttributeType = AttributeType

    def get_Attribute(self):
        return self.Attribute

    def set_Attribute(self, Attribute):
        self.Attribute = Attribute

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def add_Comment(self, value):
        self.Comment.append(value)

    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)

    def replace_Comment_at(self, index, value):
        self.Comment[index] = value

    def hasContent_(self):
        if (
                self.AttributeType is not None or
                self.Attribute is not None or
                self.Comment
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObsMethodAttributeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObsMethodAttributeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObsMethodAttributeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObsMethodAttributeType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ObsMethodAttributeType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObsMethodAttributeType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AttributeType is not None:
            namespaceprefix_ = self.AttributeType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AttributeType_nsprefix_) else ''
            self.AttributeType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AttributeType',
                                      pretty_print=pretty_print)
        if self.Attribute is not None:
            namespaceprefix_ = self.Attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.Attribute_nsprefix_) else ''
            self.Attribute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Attribute',
                                  pretty_print=pretty_print)
        for Comment_ in self.Comment:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            Comment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                            pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AttributeType':
            obj_ = AttributeTypeType3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AttributeType = obj_
            obj_.original_tagname_ = 'AttributeType'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'


# end class ObsMethodAttributeType


class ObservedDataType(GeneratedsSuper):
    """This is an AttributeSet, there will be 1 attribute supported by
    optional citations, xrefs and comment. There must be at least one
    ObservedData Set, but can be any number. For each ObservedData set
    the Attribute will be either decimal or string depending on type.
    The value will be stored here, but decimals will be entered to the database
    as a
    string."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, id=None, ncbi_id=None, id_status=None, uid=None, ObsAttributeType=None, ObsDecAttributeType=None,
                 Attribute=None, Zygosity=None, XRef=None, Citation=None, Comment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.ObsAttributeType = ObsAttributeType
        self.ObsAttributeType_nsprefix_ = None
        self.ObsDecAttributeType = ObsDecAttributeType
        self.ObsDecAttributeType_nsprefix_ = None
        self.Attribute = Attribute
        self.Attribute_nsprefix_ = None
        self.Zygosity = Zygosity
        self.validate_ZygosityType(self.Zygosity)
        self.Zygosity_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObservedDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObservedDataType.subclass:
            return ObservedDataType.subclass(*args_, **kwargs_)
        else:
            return ObservedDataType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ObsAttributeType(self):
        return self.ObsAttributeType

    def set_ObsAttributeType(self, ObsAttributeType):
        self.ObsAttributeType = ObsAttributeType

    def get_ObsDecAttributeType(self):
        return self.ObsDecAttributeType

    def set_ObsDecAttributeType(self, ObsDecAttributeType):
        self.ObsDecAttributeType = ObsDecAttributeType

    def get_Attribute(self):
        return self.Attribute

    def set_Attribute(self, Attribute):
        self.Attribute = Attribute

    def get_Zygosity(self):
        return self.Zygosity

    def set_Zygosity(self, Zygosity):
        self.Zygosity = Zygosity

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def add_Comment(self, value):
        self.Comment.append(value)

    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)

    def replace_Comment_at(self, index, value):
        self.Comment[index] = value

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_ZygosityType(self, value):
        result = True
        # Validate type ZygosityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['Homozygote', 'Single heterozygote', 'Compound heterozygote', 'Hemizygote', 'not provided']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ZygosityType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.ObsAttributeType is not None or
                self.ObsDecAttributeType is not None or
                self.Attribute is not None or
                self.Zygosity is not None or
                self.XRef or
                self.Citation or
                self.Comment
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObservedDataType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObservedDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObservedDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObservedDataType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ObservedDataType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObservedDataType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ObsAttributeType is not None:
            namespaceprefix_ = self.ObsAttributeType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ObsAttributeType_nsprefix_) else ''
            self.ObsAttributeType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ObsAttributeType',
                                         pretty_print=pretty_print)
        if self.ObsDecAttributeType is not None:
            namespaceprefix_ = self.ObsDecAttributeType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ObsDecAttributeType_nsprefix_) else ''
            self.ObsDecAttributeType.export(outfile, level, namespaceprefix_, namespacedef_='',
                                            name_='ObsDecAttributeType', pretty_print=pretty_print)
        if self.Attribute is not None:
            namespaceprefix_ = self.Attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.Attribute_nsprefix_) else ''
            self.Attribute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Attribute',
                                  pretty_print=pretty_print)
        if self.Zygosity is not None:
            namespaceprefix_ = self.Zygosity_nsprefix_ + ':' if (UseCapturedNS_ and self.Zygosity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZygosity>%s</%sZygosity>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Zygosity), input_name='Zygosity')),
            namespaceprefix_, eol_))
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for Comment_ in self.Comment:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            Comment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                            pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ObsAttributeType':
            obj_ = ObsAttributeTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ObsAttributeType = obj_
            obj_.original_tagname_ = 'ObsAttributeType'
        elif nodeName_ == 'ObsDecAttributeType':
            obj_ = ObsDecAttributeTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ObsDecAttributeType = obj_
            obj_.original_tagname_ = 'ObsDecAttributeType'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Zygosity':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Zygosity')
            value_ = self.gds_validate_string(value_, node, 'Zygosity')
            self.Zygosity = value_
            self.Zygosity_nsprefix_ = child_.prefix
            # validate type ZygosityType
            self.validate_ZygosityType(self.Zygosity)
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'


# end class ObservedDataType


class ObservationSet(GeneratedsSuper):
    """Documents in what populations or samples an allele or genotype has
    been observed relative to the described trait. Summary observations can be
    registered per submitted assertion, grouped by common citation, study type,
    origin,
    ethnicity, tissue, cell line, and species data. Not all options are valid
    per study
    type, but these will not be validated in the xsd."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Status='current', pubStat='3', Aggregate=None, id=None, ncbi_id=None, id_status=None, uid=None,
                 Sample=None, Method=None, ObservedData=None, Severity=None, Co_occurrenceSet=None, TraitSet=None,
                 XRef=None, Citation=None, Comment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Status = _cast(None, Status)
        self.Status_nsprefix_ = None
        self.pubStat = _cast(None, pubStat)
        self.pubStat_nsprefix_ = None
        self.Aggregate = _cast(bool, Aggregate)
        self.Aggregate_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.Sample = Sample
        self.Sample_nsprefix_ = None
        if Method is None:
            self.Method = []
        else:
            self.Method = Method
        self.Method_nsprefix_ = None
        if ObservedData is None:
            self.ObservedData = []
        else:
            self.ObservedData = ObservedData
        self.ObservedData_nsprefix_ = None
        self.Severity = Severity
        self.validate_SeverityType(self.Severity)
        self.Severity_nsprefix_ = None
        if Co_occurrenceSet is None:
            self.Co_occurrenceSet = []
        else:
            self.Co_occurrenceSet = Co_occurrenceSet
        self.Co_occurrenceSet_nsprefix_ = None
        self.TraitSet = TraitSet
        self.TraitSet_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObservationSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObservationSet.subclass:
            return ObservationSet.subclass(*args_, **kwargs_)
        else:
            return ObservationSet(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Sample(self):
        return self.Sample

    def set_Sample(self, Sample):
        self.Sample = Sample

    def get_Method(self):
        return self.Method

    def set_Method(self, Method):
        self.Method = Method

    def add_Method(self, value):
        self.Method.append(value)

    def insert_Method_at(self, index, value):
        self.Method.insert(index, value)

    def replace_Method_at(self, index, value):
        self.Method[index] = value

    def get_ObservedData(self):
        return self.ObservedData

    def set_ObservedData(self, ObservedData):
        self.ObservedData = ObservedData

    def add_ObservedData(self, value):
        self.ObservedData.append(value)

    def insert_ObservedData_at(self, index, value):
        self.ObservedData.insert(index, value)

    def replace_ObservedData_at(self, index, value):
        self.ObservedData[index] = value

    def get_Severity(self):
        return self.Severity

    def set_Severity(self, Severity):
        self.Severity = Severity

    def get_Co_occurrenceSet(self):
        return self.Co_occurrenceSet

    def set_Co_occurrenceSet(self, Co_occurrenceSet):
        self.Co_occurrenceSet = Co_occurrenceSet

    def add_Co_occurrenceSet(self, value):
        self.Co_occurrenceSet.append(value)

    def insert_Co_occurrenceSet_at(self, index, value):
        self.Co_occurrenceSet.insert(index, value)

    def replace_Co_occurrenceSet_at(self, index, value):
        self.Co_occurrenceSet[index] = value

    def get_TraitSet(self):
        return self.TraitSet

    def set_TraitSet(self, TraitSet):
        self.TraitSet = TraitSet

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def add_Comment(self, value):
        self.Comment.append(value)

    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)

    def replace_Comment_at(self, index, value):
        self.Comment[index] = value

    def get_Status(self):
        return self.Status

    def set_Status(self, Status):
        self.Status = Status

    def get_pubStat(self):
        return self.pubStat

    def set_pubStat(self, pubStat):
        self.pubStat = pubStat

    def get_Aggregate(self):
        return self.Aggregate

    def set_Aggregate(self, Aggregate):
        self.Aggregate = Aggregate

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_SeverityType(self, value):
        result = True
        # Validate type SeverityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['mild', 'moderate', 'severe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SeverityType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def validate_typeStatus(self, value):
        # Validate type typeStatus, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['current', 'completed and retired', 'delete', 'in development', 'reclassified', 'reject',
                            'secondary', 'suppressed', 'under review']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeStatus' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.Sample is not None or
                self.Method or
                self.ObservedData or
                self.Severity is not None or
                self.Co_occurrenceSet or
                self.TraitSet is not None or
                self.XRef or
                self.Citation or
                self.Comment
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObservationSet', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObservationSet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObservationSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObservationSet',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ObservationSet'):
        if self.Status != "current" and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')),))
        if self.pubStat != "3" and 'pubStat' not in already_processed:
            already_processed.add('pubStat')
            outfile.write(' pubStat=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.pubStat), input_name='pubStat')),))
        if self.Aggregate is not None and 'Aggregate' not in already_processed:
            already_processed.add('Aggregate')
            outfile.write(' Aggregate="%s"' % self.gds_format_boolean(self.Aggregate, input_name='Aggregate'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObservationSet',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Sample is not None:
            namespaceprefix_ = self.Sample_nsprefix_ + ':' if (UseCapturedNS_ and self.Sample_nsprefix_) else ''
            self.Sample.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Sample',
                               pretty_print=pretty_print)
        for Method_ in self.Method:
            namespaceprefix_ = self.Method_nsprefix_ + ':' if (UseCapturedNS_ and self.Method_nsprefix_) else ''
            Method_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Method',
                           pretty_print=pretty_print)
        for ObservedData_ in self.ObservedData:
            namespaceprefix_ = self.ObservedData_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ObservedData_nsprefix_) else ''
            ObservedData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ObservedData',
                                 pretty_print=pretty_print)
        if self.Severity is not None:
            namespaceprefix_ = self.Severity_nsprefix_ + ':' if (UseCapturedNS_ and self.Severity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSeverity>%s</%sSeverity>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Severity), input_name='Severity')),
            namespaceprefix_, eol_))
        for Co_occurrenceSet_ in self.Co_occurrenceSet:
            namespaceprefix_ = self.Co_occurrenceSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.Co_occurrenceSet_nsprefix_) else ''
            Co_occurrenceSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Co-occurrenceSet',
                                     pretty_print=pretty_print)
        if self.TraitSet is not None:
            namespaceprefix_ = self.TraitSet_nsprefix_ + ':' if (UseCapturedNS_ and self.TraitSet_nsprefix_) else ''
            self.TraitSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TraitSet',
                                 pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for Comment_ in self.Comment:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            Comment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                            pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
            self.validate_typeStatus(self.Status)  # validate type typeStatus
        value = find_attr_value_('pubStat', node)
        if value is not None and 'pubStat' not in already_processed:
            already_processed.add('pubStat')
            self.pubStat = value
        value = find_attr_value_('Aggregate', node)
        if value is not None and 'Aggregate' not in already_processed:
            already_processed.add('Aggregate')
            if value in ('true', '1'):
                self.Aggregate = True
            elif value in ('false', '0'):
                self.Aggregate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Sample':
            obj_ = SampleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Sample = obj_
            obj_.original_tagname_ = 'Sample'
        elif nodeName_ == 'Method':
            obj_ = MethodType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Method.append(obj_)
            obj_.original_tagname_ = 'Method'
        elif nodeName_ == 'ObservedData':
            obj_ = ObservedDataType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ObservedData.append(obj_)
            obj_.original_tagname_ = 'ObservedData'
        elif nodeName_ == 'Severity':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Severity')
            value_ = self.gds_validate_string(value_, node, 'Severity')
            self.Severity = value_
            self.Severity_nsprefix_ = child_.prefix
            # validate type SeverityType
            self.validate_SeverityType(self.Severity)
        elif nodeName_ == 'Co-occurrenceSet':
            obj_ = Co_occurrenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Co_occurrenceSet.append(obj_)
            obj_.original_tagname_ = 'Co-occurrenceSet'
        elif nodeName_ == 'TraitSet':
            obj_ = TraitSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TraitSet = obj_
            obj_.original_tagname_ = 'TraitSet'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'


# end class ObservationSet


class SubmissionType(GeneratedsSuper):
    """Each ClinVar submission is a single asserted relationship. There must
    be at least 1 in a set, but there may be many."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, id=None, ncbi_id=None, id_status=None, uid=None, RecordStatus=None, ReleaseStatus='public',
                 ClinvarSubmissionID=None, ClinvarSubmissionAcc=None, ReplacesAccession=None, MeasureTrait=None,
                 MeasureSet=None, GenotypeSet=None, TraitSet=None, XRef=None, Citation=None, Comment=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.RecordStatus = RecordStatus
        self.validate_RecordStatusType(self.RecordStatus)
        self.RecordStatus_nsprefix_ = None
        self.ReleaseStatus = ReleaseStatus
        self.validate_ReleaseStatusType(self.ReleaseStatus)
        self.ReleaseStatus_nsprefix_ = None
        self.ClinvarSubmissionID = ClinvarSubmissionID
        self.ClinvarSubmissionID_nsprefix_ = None
        self.ClinvarSubmissionAcc = ClinvarSubmissionAcc
        self.ClinvarSubmissionAcc_nsprefix_ = None
        if ReplacesAccession is None:
            self.ReplacesAccession = []
        else:
            self.ReplacesAccession = ReplacesAccession
        self.ReplacesAccession_nsprefix_ = None
        self.MeasureTrait = MeasureTrait
        self.MeasureTrait_nsprefix_ = None
        self.MeasureSet = MeasureSet
        self.MeasureSet_nsprefix_ = None
        self.GenotypeSet = GenotypeSet
        self.GenotypeSet_nsprefix_ = None
        self.TraitSet = TraitSet
        self.TraitSet_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubmissionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubmissionType.subclass:
            return SubmissionType.subclass(*args_, **kwargs_)
        else:
            return SubmissionType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_RecordStatus(self):
        return self.RecordStatus

    def set_RecordStatus(self, RecordStatus):
        self.RecordStatus = RecordStatus

    def get_ReleaseStatus(self):
        return self.ReleaseStatus

    def set_ReleaseStatus(self, ReleaseStatus):
        self.ReleaseStatus = ReleaseStatus

    def get_ClinvarSubmissionID(self):
        return self.ClinvarSubmissionID

    def set_ClinvarSubmissionID(self, ClinvarSubmissionID):
        self.ClinvarSubmissionID = ClinvarSubmissionID

    def get_ClinvarSubmissionAcc(self):
        return self.ClinvarSubmissionAcc

    def set_ClinvarSubmissionAcc(self, ClinvarSubmissionAcc):
        self.ClinvarSubmissionAcc = ClinvarSubmissionAcc

    def get_ReplacesAccession(self):
        return self.ReplacesAccession

    def set_ReplacesAccession(self, ReplacesAccession):
        self.ReplacesAccession = ReplacesAccession

    def add_ReplacesAccession(self, value):
        self.ReplacesAccession.append(value)

    def insert_ReplacesAccession_at(self, index, value):
        self.ReplacesAccession.insert(index, value)

    def replace_ReplacesAccession_at(self, index, value):
        self.ReplacesAccession[index] = value

    def get_MeasureTrait(self):
        return self.MeasureTrait

    def set_MeasureTrait(self, MeasureTrait):
        self.MeasureTrait = MeasureTrait

    def get_MeasureSet(self):
        return self.MeasureSet

    def set_MeasureSet(self, MeasureSet):
        self.MeasureSet = MeasureSet

    def get_GenotypeSet(self):
        return self.GenotypeSet

    def set_GenotypeSet(self, GenotypeSet):
        self.GenotypeSet = GenotypeSet

    def get_TraitSet(self):
        return self.TraitSet

    def set_TraitSet(self, TraitSet):
        self.TraitSet = TraitSet

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def add_Comment(self, value):
        self.Comment.append(value)

    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)

    def replace_Comment_at(self, index, value):
        self.Comment[index] = value

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_RecordStatusType(self, value):
        result = True
        # Validate type RecordStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel', 'update', 'delete']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RecordStatusType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def validate_ReleaseStatusType(self, value):
        result = True
        # Validate type ReleaseStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['public', 'hold until published']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ReleaseStatusType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.RecordStatus is not None or
                self.ReleaseStatus != "public" or
                self.ClinvarSubmissionID is not None or
                self.ClinvarSubmissionAcc is not None or
                self.ReplacesAccession or
                self.MeasureTrait is not None or
                self.MeasureSet is not None or
                self.GenotypeSet is not None or
                self.TraitSet is not None or
                self.XRef or
                self.Citation or
                self.Comment
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubmissionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubmissionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubmissionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SubmissionType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SubmissionType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubmissionType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RecordStatus is not None:
            namespaceprefix_ = self.RecordStatus_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.RecordStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRecordStatus>%s</%sRecordStatus>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.RecordStatus), input_name='RecordStatus')), namespaceprefix_,
                                                                     eol_))
        if self.ReleaseStatus != "public":
            namespaceprefix_ = self.ReleaseStatus_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ReleaseStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReleaseStatus>%s</%sReleaseStatus>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.ReleaseStatus), input_name='ReleaseStatus')), namespaceprefix_,
                                                                       eol_))
        if self.ClinvarSubmissionID is not None:
            namespaceprefix_ = self.ClinvarSubmissionID_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ClinvarSubmissionID_nsprefix_) else ''
            self.ClinvarSubmissionID.export(outfile, level, namespaceprefix_, namespacedef_='',
                                            name_='ClinvarSubmissionID', pretty_print=pretty_print)
        if self.ClinvarSubmissionAcc is not None:
            namespaceprefix_ = self.ClinvarSubmissionAcc_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ClinvarSubmissionAcc_nsprefix_) else ''
            self.ClinvarSubmissionAcc.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='ClinvarSubmissionAcc', pretty_print=pretty_print)
        for ReplacesAccession_ in self.ReplacesAccession:
            namespaceprefix_ = self.ReplacesAccession_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ReplacesAccession_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReplacesAccession>%s</%sReplacesAccession>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(ReplacesAccession_), input_name='ReplacesAccession')),
                                                                               namespaceprefix_, eol_))
        if self.MeasureTrait is not None:
            namespaceprefix_ = self.MeasureTrait_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MeasureTrait_nsprefix_) else ''
            self.MeasureTrait.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MeasureTrait',
                                     pretty_print=pretty_print)
        if self.MeasureSet is not None:
            namespaceprefix_ = self.MeasureSet_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasureSet_nsprefix_) else ''
            self.MeasureSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MeasureSet',
                                   pretty_print=pretty_print)
        if self.GenotypeSet is not None:
            namespaceprefix_ = self.GenotypeSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.GenotypeSet_nsprefix_) else ''
            self.GenotypeSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GenotypeSet',
                                    pretty_print=pretty_print)
        if self.TraitSet is not None:
            namespaceprefix_ = self.TraitSet_nsprefix_ + ':' if (UseCapturedNS_ and self.TraitSet_nsprefix_) else ''
            self.TraitSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TraitSet',
                                 pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for Comment_ in self.Comment:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            Comment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                            pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RecordStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RecordStatus')
            value_ = self.gds_validate_string(value_, node, 'RecordStatus')
            self.RecordStatus = value_
            self.RecordStatus_nsprefix_ = child_.prefix
            # validate type RecordStatusType
            self.validate_RecordStatusType(self.RecordStatus)
        elif nodeName_ == 'ReleaseStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ReleaseStatus')
            value_ = self.gds_validate_string(value_, node, 'ReleaseStatus')
            self.ReleaseStatus = value_
            self.ReleaseStatus_nsprefix_ = child_.prefix
            # validate type ReleaseStatusType
            self.validate_ReleaseStatusType(self.ReleaseStatus)
        elif nodeName_ == 'ClinvarSubmissionID':
            obj_ = ClinvarSubmissionIDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClinvarSubmissionID = obj_
            obj_.original_tagname_ = 'ClinvarSubmissionID'
        elif nodeName_ == 'ClinvarSubmissionAcc':
            obj_ = ClinvarSubmissionAccType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClinvarSubmissionAcc = obj_
            obj_.original_tagname_ = 'ClinvarSubmissionAcc'
        elif nodeName_ == 'ReplacesAccession':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ReplacesAccession')
            value_ = self.gds_validate_string(value_, node, 'ReplacesAccession')
            self.ReplacesAccession.append(value_)
            self.ReplacesAccession_nsprefix_ = child_.prefix
        elif nodeName_ == 'MeasureTrait':
            obj_ = MeasureTraitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasureTrait = obj_
            obj_.original_tagname_ = 'MeasureTrait'
        elif nodeName_ == 'MeasureSet':
            obj_ = MeasureSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasureSet = obj_
            obj_.original_tagname_ = 'MeasureSet'
        elif nodeName_ == 'GenotypeSet':
            obj_ = GenotypeSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GenotypeSet = obj_
            obj_.original_tagname_ = 'GenotypeSet'
        elif nodeName_ == 'TraitSet':
            obj_ = TraitSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TraitSet = obj_
            obj_.original_tagname_ = 'TraitSet'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'


# end class SubmissionType


class ClinVarDeletionType(GeneratedsSuper):
    """Structure to report the organization and person requesting that one or
    more accessions they submitted be deleted. The accessions must be
    listed, and either the reason for each accession being deleted, or a
    general reason
    to be applied to all that are listed. Because the data about the
    submission must already be in the database, the source of the request can
    be simple
    and processed only by OrgID and PersonID"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ReasonForDeleting=None, AccessionSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ReasonForDeleting = ReasonForDeleting
        self.ReasonForDeleting_nsprefix_ = None
        if AccessionSet is None:
            self.AccessionSet = []
        else:
            self.AccessionSet = AccessionSet
        self.AccessionSet_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClinVarDeletionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClinVarDeletionType.subclass:
            return ClinVarDeletionType.subclass(*args_, **kwargs_)
        else:
            return ClinVarDeletionType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ReasonForDeleting(self):
        return self.ReasonForDeleting

    def set_ReasonForDeleting(self, ReasonForDeleting):
        self.ReasonForDeleting = ReasonForDeleting

    def get_AccessionSet(self):
        return self.AccessionSet

    def set_AccessionSet(self, AccessionSet):
        self.AccessionSet = AccessionSet

    def add_AccessionSet(self, value):
        self.AccessionSet.append(value)

    def insert_AccessionSet_at(self, index, value):
        self.AccessionSet.insert(index, value)

    def replace_AccessionSet_at(self, index, value):
        self.AccessionSet[index] = value

    def hasContent_(self):
        if (
                self.ReasonForDeleting is not None or
                self.AccessionSet
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ClinVarDeletionType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClinVarDeletionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClinVarDeletionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClinVarDeletionType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ClinVarDeletionType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ClinVarDeletionType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReasonForDeleting is not None:
            namespaceprefix_ = self.ReasonForDeleting_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ReasonForDeleting_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReasonForDeleting>%s</%sReasonForDeleting>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.ReasonForDeleting), input_name='ReasonForDeleting')),
                                                                               namespaceprefix_, eol_))
        for AccessionSet_ in self.AccessionSet:
            namespaceprefix_ = self.AccessionSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AccessionSet_nsprefix_) else ''
            AccessionSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AccessionSet',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ReasonForDeleting':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ReasonForDeleting')
            value_ = self.gds_validate_string(value_, node, 'ReasonForDeleting')
            self.ReasonForDeleting = value_
            self.ReasonForDeleting_nsprefix_ = child_.prefix
        elif nodeName_ == 'AccessionSet':
            obj_ = typeAccessionSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AccessionSet.append(obj_)
            obj_.original_tagname_ = 'AccessionSet'


# end class ClinVarDeletionType


class typeAccessionSet(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Accession=None, ReasonForDeleting=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Accession = Accession
        self.Accession_nsprefix_ = None
        self.ReasonForDeleting = ReasonForDeleting
        self.ReasonForDeleting_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeAccessionSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeAccessionSet.subclass:
            return typeAccessionSet.subclass(*args_, **kwargs_)
        else:
            return typeAccessionSet(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Accession(self):
        return self.Accession

    def set_Accession(self, Accession):
        self.Accession = Accession

    def get_ReasonForDeleting(self):
        return self.ReasonForDeleting

    def set_ReasonForDeleting(self, ReasonForDeleting):
        self.ReasonForDeleting = ReasonForDeleting

    def hasContent_(self):
        if (
                self.Accession is not None or
                self.ReasonForDeleting is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='typeAccessionSet',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeAccessionSet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='typeAccessionSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='typeAccessionSet',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='typeAccessionSet'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='typeAccessionSet',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Accession is not None:
            namespaceprefix_ = self.Accession_nsprefix_ + ':' if (UseCapturedNS_ and self.Accession_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccession>%s</%sAccession>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.Accession), input_name='Accession')), namespaceprefix_, eol_))
        if self.ReasonForDeleting is not None:
            namespaceprefix_ = self.ReasonForDeleting_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ReasonForDeleting_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReasonForDeleting>%s</%sReasonForDeleting>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.ReasonForDeleting), input_name='ReasonForDeleting')),
                                                                               namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Accession':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Accession')
            value_ = self.gds_validate_string(value_, node, 'Accession')
            self.Accession = value_
            self.Accession_nsprefix_ = child_.prefix
        elif nodeName_ == 'ReasonForDeleting':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ReasonForDeleting')
            value_ = self.gds_validate_string(value_, node, 'ReasonForDeleting')
            self.ReasonForDeleting = value_
            self.ReasonForDeleting_nsprefix_ = child_.prefix


# end class typeAccessionSet


class MeasureTraitType(GeneratedsSuper):
    """MeasureTrait type is the assertion relationship stored in the
    clinvar.measure_target table. This represents a single asserted
    relationship which
    will be assigned an accession of the type SCV, RCV or NCV."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, id=None, ncbi_id=None, id_status=None, uid=None, Assertion=None, ClinicalSignificance=None,
                 PathogenicityProperty=None, CustomAssertionScore=None, ExternalID=None, AttributeSet=None,
                 Severity=None, ObservedIn=None, XRef=None, Citation=None, Comment=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.Assertion = Assertion
        self.Assertion_nsprefix_ = None
        self.ClinicalSignificance = ClinicalSignificance
        self.ClinicalSignificance_nsprefix_ = None
        if PathogenicityProperty is None:
            self.PathogenicityProperty = []
        else:
            self.PathogenicityProperty = PathogenicityProperty
        self.PathogenicityProperty_nsprefix_ = None
        if CustomAssertionScore is None:
            self.CustomAssertionScore = []
        else:
            self.CustomAssertionScore = CustomAssertionScore
        self.CustomAssertionScore_nsprefix_ = None
        self.ExternalID = ExternalID
        self.ExternalID_nsprefix_ = None
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        self.AttributeSet_nsprefix_ = None
        self.Severity = Severity
        self.validate_SeverityType(self.Severity)
        self.Severity_nsprefix_ = None
        if ObservedIn is None:
            self.ObservedIn = []
        else:
            self.ObservedIn = ObservedIn
        self.ObservedIn_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureTraitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureTraitType.subclass:
            return MeasureTraitType.subclass(*args_, **kwargs_)
        else:
            return MeasureTraitType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Assertion(self):
        return self.Assertion

    def set_Assertion(self, Assertion):
        self.Assertion = Assertion

    def get_ClinicalSignificance(self):
        return self.ClinicalSignificance

    def set_ClinicalSignificance(self, ClinicalSignificance):
        self.ClinicalSignificance = ClinicalSignificance

    def get_PathogenicityProperty(self):
        return self.PathogenicityProperty

    def set_PathogenicityProperty(self, PathogenicityProperty):
        self.PathogenicityProperty = PathogenicityProperty

    def add_PathogenicityProperty(self, value):
        self.PathogenicityProperty.append(value)

    def insert_PathogenicityProperty_at(self, index, value):
        self.PathogenicityProperty.insert(index, value)

    def replace_PathogenicityProperty_at(self, index, value):
        self.PathogenicityProperty[index] = value

    def get_CustomAssertionScore(self):
        return self.CustomAssertionScore

    def set_CustomAssertionScore(self, CustomAssertionScore):
        self.CustomAssertionScore = CustomAssertionScore

    def add_CustomAssertionScore(self, value):
        self.CustomAssertionScore.append(value)

    def insert_CustomAssertionScore_at(self, index, value):
        self.CustomAssertionScore.insert(index, value)

    def replace_CustomAssertionScore_at(self, index, value):
        self.CustomAssertionScore[index] = value

    def get_ExternalID(self):
        return self.ExternalID

    def set_ExternalID(self, ExternalID):
        self.ExternalID = ExternalID

    def get_AttributeSet(self):
        return self.AttributeSet

    def set_AttributeSet(self, AttributeSet):
        self.AttributeSet = AttributeSet

    def add_AttributeSet(self, value):
        self.AttributeSet.append(value)

    def insert_AttributeSet_at(self, index, value):
        self.AttributeSet.insert(index, value)

    def replace_AttributeSet_at(self, index, value):
        self.AttributeSet[index] = value

    def get_Severity(self):
        return self.Severity

    def set_Severity(self, Severity):
        self.Severity = Severity

    def get_ObservedIn(self):
        return self.ObservedIn

    def set_ObservedIn(self, ObservedIn):
        self.ObservedIn = ObservedIn

    def add_ObservedIn(self, value):
        self.ObservedIn.append(value)

    def insert_ObservedIn_at(self, index, value):
        self.ObservedIn.insert(index, value)

    def replace_ObservedIn_at(self, index, value):
        self.ObservedIn[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def add_Comment(self, value):
        self.Comment.append(value)

    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)

    def replace_Comment_at(self, index, value):
        self.Comment[index] = value

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_PathogenicityPropertyType(self, value):
        result = True
        # Validate type PathogenicityPropertyType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['this variant, in a female, is causative', 'this variant, in a male, is causative',
                            'this variant is causative', 'this variant, when inherited from the father, is causative',
                            'this variant, when inherited from the mother, is causative']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on PathogenicityPropertyType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def validate_SeverityType(self, value):
        result = True
        # Validate type SeverityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['mild', 'moderate', 'severe']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SeverityType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.Assertion is not None or
                self.ClinicalSignificance is not None or
                self.PathogenicityProperty or
                self.CustomAssertionScore or
                self.ExternalID is not None or
                self.AttributeSet or
                self.Severity is not None or
                self.ObservedIn or
                self.XRef or
                self.Citation or
                self.Comment
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureTraitType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasureTraitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeasureTraitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeasureTraitType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MeasureTraitType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureTraitType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Assertion is not None:
            namespaceprefix_ = self.Assertion_nsprefix_ + ':' if (UseCapturedNS_ and self.Assertion_nsprefix_) else ''
            self.Assertion.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Assertion',
                                  pretty_print=pretty_print)
        if self.ClinicalSignificance is not None:
            namespaceprefix_ = self.ClinicalSignificance_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ClinicalSignificance_nsprefix_) else ''
            self.ClinicalSignificance.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='ClinicalSignificance', pretty_print=pretty_print)
        for PathogenicityProperty_ in self.PathogenicityProperty:
            namespaceprefix_ = self.PathogenicityProperty_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.PathogenicityProperty_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPathogenicityProperty>%s</%sPathogenicityProperty>%s' % (namespaceprefix_,
                                                                                       self.gds_encode(
                                                                                           self.gds_format_string(
                                                                                               quote_xml(
                                                                                                   PathogenicityProperty_),
                                                                                               input_name='PathogenicityProperty')),
                                                                                       namespaceprefix_, eol_))
        for CustomAssertionScore_ in self.CustomAssertionScore:
            namespaceprefix_ = self.CustomAssertionScore_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CustomAssertionScore_nsprefix_) else ''
            CustomAssertionScore_.export(outfile, level, namespaceprefix_, namespacedef_='',
                                         name_='CustomAssertionScore', pretty_print=pretty_print)
        if self.ExternalID is not None:
            namespaceprefix_ = self.ExternalID_nsprefix_ + ':' if (UseCapturedNS_ and self.ExternalID_nsprefix_) else ''
            self.ExternalID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ExternalID',
                                   pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            namespaceprefix_ = self.AttributeSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AttributeSet_nsprefix_) else ''
            AttributeSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AttributeSet',
                                 pretty_print=pretty_print)
        if self.Severity is not None:
            namespaceprefix_ = self.Severity_nsprefix_ + ':' if (UseCapturedNS_ and self.Severity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSeverity>%s</%sSeverity>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Severity), input_name='Severity')),
            namespaceprefix_, eol_))
        for ObservedIn_ in self.ObservedIn:
            namespaceprefix_ = self.ObservedIn_nsprefix_ + ':' if (UseCapturedNS_ and self.ObservedIn_nsprefix_) else ''
            ObservedIn_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ObservedIn',
                               pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for Comment_ in self.Comment:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            Comment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                            pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Assertion':
            obj_ = AssertionType4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Assertion = obj_
            obj_.original_tagname_ = 'Assertion'
        elif nodeName_ == 'ClinicalSignificance':
            obj_ = ClinicalSignificanceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClinicalSignificance = obj_
            obj_.original_tagname_ = 'ClinicalSignificance'
        elif nodeName_ == 'PathogenicityProperty':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PathogenicityProperty')
            value_ = self.gds_validate_string(value_, node, 'PathogenicityProperty')
            self.PathogenicityProperty.append(value_)
            self.PathogenicityProperty_nsprefix_ = child_.prefix
            # validate type PathogenicityPropertyType
            self.validate_PathogenicityPropertyType(self.PathogenicityProperty[-1])
        elif nodeName_ == 'CustomAssertionScore':
            obj_ = CustomAssertionScoreType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CustomAssertionScore.append(obj_)
            obj_.original_tagname_ = 'CustomAssertionScore'
        elif nodeName_ == 'ExternalID':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ExternalID = obj_
            obj_.original_tagname_ = 'ExternalID'
        elif nodeName_ == 'AttributeSet':
            obj_ = AttributeSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'Severity':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Severity')
            value_ = self.gds_validate_string(value_, node, 'Severity')
            self.Severity = value_
            self.Severity_nsprefix_ = child_.prefix
            # validate type SeverityType
            self.validate_SeverityType(self.Severity)
        elif nodeName_ == 'ObservedIn':
            obj_ = ObservationSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ObservedIn.append(obj_)
            obj_.original_tagname_ = 'ObservedIn'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'


# end class MeasureTraitType


class MeasureSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, NumberOfChromosomes=None, id=None, ncbi_id=None, id_status=None, uid=None,
                 MeasureSetType_member=None, Measure=None, Name=None, Symbol=None, AttributeSet=None, Citation=None,
                 XRef=None, Comment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NumberOfChromosomes = _cast(int, NumberOfChromosomes)
        self.NumberOfChromosomes_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.MeasureSetType = MeasureSetType_member
        self.MeasureSetType_nsprefix_ = None
        if Measure is None:
            self.Measure = []
        else:
            self.Measure = Measure
        self.Measure_nsprefix_ = None
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        self.Name_nsprefix_ = None
        if Symbol is None:
            self.Symbol = []
        else:
            self.Symbol = Symbol
        self.Symbol_nsprefix_ = None
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        self.AttributeSet_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureSetType.subclass:
            return MeasureSetType.subclass(*args_, **kwargs_)
        else:
            return MeasureSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MeasureSetType(self):
        return self.MeasureSetType

    def set_MeasureSetType(self, MeasureSetType):
        self.MeasureSetType = MeasureSetType

    def get_Measure(self):
        return self.Measure

    def set_Measure(self, Measure):
        self.Measure = Measure

    def add_Measure(self, value):
        self.Measure.append(value)

    def insert_Measure_at(self, index, value):
        self.Measure.insert(index, value)

    def replace_Measure_at(self, index, value):
        self.Measure[index] = value

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def add_Name(self, value):
        self.Name.append(value)

    def insert_Name_at(self, index, value):
        self.Name.insert(index, value)

    def replace_Name_at(self, index, value):
        self.Name[index] = value

    def get_Symbol(self):
        return self.Symbol

    def set_Symbol(self, Symbol):
        self.Symbol = Symbol

    def add_Symbol(self, value):
        self.Symbol.append(value)

    def insert_Symbol_at(self, index, value):
        self.Symbol.insert(index, value)

    def replace_Symbol_at(self, index, value):
        self.Symbol[index] = value

    def get_AttributeSet(self):
        return self.AttributeSet

    def set_AttributeSet(self, AttributeSet):
        self.AttributeSet = AttributeSet

    def add_AttributeSet(self, value):
        self.AttributeSet.append(value)

    def insert_AttributeSet_at(self, index, value):
        self.AttributeSet.insert(index, value)

    def replace_AttributeSet_at(self, index, value):
        self.AttributeSet[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def get_NumberOfChromosomes(self):
        return self.NumberOfChromosomes

    def set_NumberOfChromosomes(self, NumberOfChromosomes):
        self.NumberOfChromosomes = NumberOfChromosomes

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.MeasureSetType is not None or
                self.Measure or
                self.Name or
                self.Symbol or
                self.AttributeSet or
                self.Citation or
                self.XRef or
                self.Comment is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasureSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeasureSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeasureSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MeasureSetType'):
        if self.NumberOfChromosomes is not None and 'NumberOfChromosomes' not in already_processed:
            already_processed.add('NumberOfChromosomes')
            outfile.write(' NumberOfChromosomes="%s"' % self.gds_format_integer(self.NumberOfChromosomes,
                                                                                input_name='NumberOfChromosomes'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeasureSetType is not None:
            namespaceprefix_ = self.MeasureSetType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MeasureSetType_nsprefix_) else ''
            self.MeasureSetType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MeasureSetType',
                                       pretty_print=pretty_print)
        for Measure_ in self.Measure:
            namespaceprefix_ = self.Measure_nsprefix_ + ':' if (UseCapturedNS_ and self.Measure_nsprefix_) else ''
            Measure_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Measure',
                            pretty_print=pretty_print)
        for Name_ in self.Name:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            Name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        for Symbol_ in self.Symbol:
            namespaceprefix_ = self.Symbol_nsprefix_ + ':' if (UseCapturedNS_ and self.Symbol_nsprefix_) else ''
            Symbol_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Symbol',
                           pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            namespaceprefix_ = self.AttributeSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AttributeSet_nsprefix_) else ''
            AttributeSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AttributeSet',
                                 pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        if self.Comment is not None:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            self.Comment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NumberOfChromosomes', node)
        if value is not None and 'NumberOfChromosomes' not in already_processed:
            already_processed.add('NumberOfChromosomes')
            self.NumberOfChromosomes = self.gds_parse_integer(value, node, 'NumberOfChromosomes')
            if self.NumberOfChromosomes <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MeasureSetType':
            obj_ = MeasureSetTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasureSetType = obj_
            obj_.original_tagname_ = 'MeasureSetType'
        elif nodeName_ == 'Measure':
            obj_ = MeasureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Measure.append(obj_)
            obj_.original_tagname_ = 'Measure'
        elif nodeName_ == 'Name':
            obj_ = SetElementSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Symbol':
            obj_ = SetElementSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Symbol.append(obj_)
            obj_.original_tagname_ = 'Symbol'
        elif nodeName_ == 'AttributeSet':
            obj_ = MeasureSetAttributeSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'


# end class MeasureSetType


class MeasureSetAttributeSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, MeasureSetAttributeType=None, Attribute=None, Citation=None, XRef=None, Comment=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MeasureSetAttributeType = MeasureSetAttributeType
        self.MeasureSetAttributeType_nsprefix_ = None
        self.Attribute = Attribute
        self.Attribute_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureSetAttributeSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureSetAttributeSetType.subclass:
            return MeasureSetAttributeSetType.subclass(*args_, **kwargs_)
        else:
            return MeasureSetAttributeSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MeasureSetAttributeType(self):
        return self.MeasureSetAttributeType

    def set_MeasureSetAttributeType(self, MeasureSetAttributeType):
        self.MeasureSetAttributeType = MeasureSetAttributeType

    def get_Attribute(self):
        return self.Attribute

    def set_Attribute(self, Attribute):
        self.Attribute = Attribute

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def hasContent_(self):
        if (
                self.MeasureSetAttributeType is not None or
                self.Attribute is not None or
                self.Citation or
                self.XRef or
                self.Comment is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureSetAttributeSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasureSetAttributeSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeasureSetAttributeSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeasureSetAttributeSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='MeasureSetAttributeSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureSetAttributeSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeasureSetAttributeType is not None:
            namespaceprefix_ = self.MeasureSetAttributeType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MeasureSetAttributeType_nsprefix_) else ''
            self.MeasureSetAttributeType.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                name_='MeasureSetAttributeType', pretty_print=pretty_print)
        if self.Attribute is not None:
            namespaceprefix_ = self.Attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.Attribute_nsprefix_) else ''
            self.Attribute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Attribute',
                                  pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        if self.Comment is not None:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            self.Comment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MeasureSetAttributeType':
            obj_ = MeasureSetAttributeTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasureSetAttributeType = obj_
            obj_.original_tagname_ = 'MeasureSetAttributeType'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'


# end class MeasureSetAttributeSetType


class TraitSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, DateLastEvaluated=None, id=None, ncbi_id=None, id_status=None, uid=None,
                 TraitSetType_member=None, Trait=None, Name=None, Symbol=None, AttributeSet=None, Citation=None,
                 XRef=None, Comment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if isinstance(DateLastEvaluated, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DateLastEvaluated, '%Y-%m-%d').date()
        else:
            initvalue_ = DateLastEvaluated
        self.DateLastEvaluated = initvalue_
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.TraitSetType = TraitSetType_member
        self.TraitSetType_nsprefix_ = None
        if Trait is None:
            self.Trait = []
        else:
            self.Trait = Trait
        self.Trait_nsprefix_ = None
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        self.Name_nsprefix_ = None
        if Symbol is None:
            self.Symbol = []
        else:
            self.Symbol = Symbol
        self.Symbol_nsprefix_ = None
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        self.AttributeSet_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TraitSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TraitSetType.subclass:
            return TraitSetType.subclass(*args_, **kwargs_)
        else:
            return TraitSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_TraitSetType(self):
        return self.TraitSetType

    def set_TraitSetType(self, TraitSetType):
        self.TraitSetType = TraitSetType

    def get_Trait(self):
        return self.Trait

    def set_Trait(self, Trait):
        self.Trait = Trait

    def add_Trait(self, value):
        self.Trait.append(value)

    def insert_Trait_at(self, index, value):
        self.Trait.insert(index, value)

    def replace_Trait_at(self, index, value):
        self.Trait[index] = value

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def add_Name(self, value):
        self.Name.append(value)

    def insert_Name_at(self, index, value):
        self.Name.insert(index, value)

    def replace_Name_at(self, index, value):
        self.Name[index] = value

    def get_Symbol(self):
        return self.Symbol

    def set_Symbol(self, Symbol):
        self.Symbol = Symbol

    def add_Symbol(self, value):
        self.Symbol.append(value)

    def insert_Symbol_at(self, index, value):
        self.Symbol.insert(index, value)

    def replace_Symbol_at(self, index, value):
        self.Symbol[index] = value

    def get_AttributeSet(self):
        return self.AttributeSet

    def set_AttributeSet(self, AttributeSet):
        self.AttributeSet = AttributeSet

    def add_AttributeSet(self, value):
        self.AttributeSet.append(value)

    def insert_AttributeSet_at(self, index, value):
        self.AttributeSet.insert(index, value)

    def replace_AttributeSet_at(self, index, value):
        self.AttributeSet[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def get_DateLastEvaluated(self):
        return self.DateLastEvaluated

    def set_DateLastEvaluated(self, DateLastEvaluated):
        self.DateLastEvaluated = DateLastEvaluated

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.TraitSetType is not None or
                self.Trait or
                self.Name or
                self.Symbol or
                self.AttributeSet or
                self.Citation or
                self.XRef or
                self.Comment is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TraitSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TraitSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TraitSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TraitSetType'):
        if self.DateLastEvaluated is not None and 'DateLastEvaluated' not in already_processed:
            already_processed.add('DateLastEvaluated')
            outfile.write(' DateLastEvaluated="%s"' % self.gds_format_date(self.DateLastEvaluated,
                                                                           input_name='DateLastEvaluated'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TraitSetType is not None:
            namespaceprefix_ = self.TraitSetType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TraitSetType_nsprefix_) else ''
            self.TraitSetType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TraitSetType',
                                     pretty_print=pretty_print)
        for Trait_ in self.Trait:
            namespaceprefix_ = self.Trait_nsprefix_ + ':' if (UseCapturedNS_ and self.Trait_nsprefix_) else ''
            Trait_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Trait', pretty_print=pretty_print)
        for Name_ in self.Name:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            Name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        for Symbol_ in self.Symbol:
            namespaceprefix_ = self.Symbol_nsprefix_ + ':' if (UseCapturedNS_ and self.Symbol_nsprefix_) else ''
            Symbol_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Symbol',
                           pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            namespaceprefix_ = self.AttributeSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AttributeSet_nsprefix_) else ''
            AttributeSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AttributeSet',
                                 pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        if self.Comment is not None:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            self.Comment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DateLastEvaluated', node)
        if value is not None and 'DateLastEvaluated' not in already_processed:
            already_processed.add('DateLastEvaluated')
            try:
                self.DateLastEvaluated = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (DateLastEvaluated): %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TraitSetType':
            obj_ = TraitSetTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TraitSetType = obj_
            obj_.original_tagname_ = 'TraitSetType'
        elif nodeName_ == 'Trait':
            obj_ = TraitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Trait.append(obj_)
            obj_.original_tagname_ = 'Trait'
        elif nodeName_ == 'Name':
            obj_ = SetElementSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Symbol':
            obj_ = SetElementSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Symbol.append(obj_)
            obj_.original_tagname_ = 'Symbol'
        elif nodeName_ == 'AttributeSet':
            obj_ = TraitSetAttributeSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'


# end class TraitSetType


class IndicationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, id=None, ncbi_id=None, id_status=None, uid=None, TraitSetType=None, Trait=None, Name=None,
                 Symbol=None, AttributeSet=None, Citation=None, XRef=None, Comment=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.TraitSetType = TraitSetType
        self.TraitSetType_nsprefix_ = None
        if Trait is None:
            self.Trait = []
        else:
            self.Trait = Trait
        self.Trait_nsprefix_ = None
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        self.Name_nsprefix_ = None
        if Symbol is None:
            self.Symbol = []
        else:
            self.Symbol = Symbol
        self.Symbol_nsprefix_ = None
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        self.AttributeSet_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IndicationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IndicationType.subclass:
            return IndicationType.subclass(*args_, **kwargs_)
        else:
            return IndicationType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_TraitSetType(self):
        return self.TraitSetType

    def set_TraitSetType(self, TraitSetType):
        self.TraitSetType = TraitSetType

    def get_Trait(self):
        return self.Trait

    def set_Trait(self, Trait):
        self.Trait = Trait

    def add_Trait(self, value):
        self.Trait.append(value)

    def insert_Trait_at(self, index, value):
        self.Trait.insert(index, value)

    def replace_Trait_at(self, index, value):
        self.Trait[index] = value

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def add_Name(self, value):
        self.Name.append(value)

    def insert_Name_at(self, index, value):
        self.Name.insert(index, value)

    def replace_Name_at(self, index, value):
        self.Name[index] = value

    def get_Symbol(self):
        return self.Symbol

    def set_Symbol(self, Symbol):
        self.Symbol = Symbol

    def add_Symbol(self, value):
        self.Symbol.append(value)

    def insert_Symbol_at(self, index, value):
        self.Symbol.insert(index, value)

    def replace_Symbol_at(self, index, value):
        self.Symbol[index] = value

    def get_AttributeSet(self):
        return self.AttributeSet

    def set_AttributeSet(self, AttributeSet):
        self.AttributeSet = AttributeSet

    def add_AttributeSet(self, value):
        self.AttributeSet.append(value)

    def insert_AttributeSet_at(self, index, value):
        self.AttributeSet.insert(index, value)

    def replace_AttributeSet_at(self, index, value):
        self.AttributeSet[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.TraitSetType is not None or
                self.Trait or
                self.Name or
                self.Symbol or
                self.AttributeSet or
                self.Citation or
                self.XRef or
                self.Comment is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IndicationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IndicationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IndicationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IndicationType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IndicationType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IndicationType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TraitSetType is not None:
            namespaceprefix_ = self.TraitSetType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TraitSetType_nsprefix_) else ''
            self.TraitSetType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TraitSetType',
                                     pretty_print=pretty_print)
        for Trait_ in self.Trait:
            namespaceprefix_ = self.Trait_nsprefix_ + ':' if (UseCapturedNS_ and self.Trait_nsprefix_) else ''
            Trait_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Trait', pretty_print=pretty_print)
        for Name_ in self.Name:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            Name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        for Symbol_ in self.Symbol:
            namespaceprefix_ = self.Symbol_nsprefix_ + ':' if (UseCapturedNS_ and self.Symbol_nsprefix_) else ''
            Symbol_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Symbol',
                           pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            namespaceprefix_ = self.AttributeSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AttributeSet_nsprefix_) else ''
            AttributeSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AttributeSet',
                                 pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        if self.Comment is not None:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            self.Comment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TraitSetType':
            obj_ = TraitSetTypeType7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TraitSetType = obj_
            obj_.original_tagname_ = 'TraitSetType'
        elif nodeName_ == 'Trait':
            obj_ = TraitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Trait.append(obj_)
            obj_.original_tagname_ = 'Trait'
        elif nodeName_ == 'Name':
            obj_ = SetElementSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Symbol':
            obj_ = SetElementSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Symbol.append(obj_)
            obj_.original_tagname_ = 'Symbol'
        elif nodeName_ == 'AttributeSet':
            obj_ = TraitSetAttributeSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'


# end class IndicationType


class TraitSetAttributeSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, TraitSetAttributeType=None, Attribute=None, Citation=None, XRef=None, Comment=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TraitSetAttributeType = TraitSetAttributeType
        self.TraitSetAttributeType_nsprefix_ = None
        self.Attribute = Attribute
        self.Attribute_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TraitSetAttributeSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TraitSetAttributeSetType.subclass:
            return TraitSetAttributeSetType.subclass(*args_, **kwargs_)
        else:
            return TraitSetAttributeSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_TraitSetAttributeType(self):
        return self.TraitSetAttributeType

    def set_TraitSetAttributeType(self, TraitSetAttributeType):
        self.TraitSetAttributeType = TraitSetAttributeType

    def get_Attribute(self):
        return self.Attribute

    def set_Attribute(self, Attribute):
        self.Attribute = Attribute

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def hasContent_(self):
        if (
                self.TraitSetAttributeType is not None or
                self.Attribute is not None or
                self.Citation or
                self.XRef or
                self.Comment is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitSetAttributeSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TraitSetAttributeSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TraitSetAttributeSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TraitSetAttributeSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='TraitSetAttributeSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitSetAttributeSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TraitSetAttributeType is not None:
            namespaceprefix_ = self.TraitSetAttributeType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TraitSetAttributeType_nsprefix_) else ''
            self.TraitSetAttributeType.export(outfile, level, namespaceprefix_, namespacedef_='',
                                              name_='TraitSetAttributeType', pretty_print=pretty_print)
        if self.Attribute is not None:
            namespaceprefix_ = self.Attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.Attribute_nsprefix_) else ''
            self.Attribute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Attribute',
                                  pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        if self.Comment is not None:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            self.Comment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TraitSetAttributeType':
            obj_ = TraitSetAttributeTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TraitSetAttributeType = obj_
            obj_.original_tagname_ = 'TraitSetAttributeType'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'


# end class TraitSetAttributeSetType


class TraitType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, id=None, ncbi_id=None, id_status=None, uid=None, TraitType_member=None, Name=None, Symbol=None,
                 AttributeSet=None, TraitRelationship=None, Citation=None, XRef=None, Comment=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.TraitType = TraitType_member
        self.TraitType_nsprefix_ = None
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        self.Name_nsprefix_ = None
        if Symbol is None:
            self.Symbol = []
        else:
            self.Symbol = Symbol
        self.Symbol_nsprefix_ = None
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        self.AttributeSet_nsprefix_ = None
        if TraitRelationship is None:
            self.TraitRelationship = []
        else:
            self.TraitRelationship = TraitRelationship
        self.TraitRelationship_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TraitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TraitType.subclass:
            return TraitType.subclass(*args_, **kwargs_)
        else:
            return TraitType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_TraitType(self):
        return self.TraitType

    def set_TraitType(self, TraitType):
        self.TraitType = TraitType

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def add_Name(self, value):
        self.Name.append(value)

    def insert_Name_at(self, index, value):
        self.Name.insert(index, value)

    def replace_Name_at(self, index, value):
        self.Name[index] = value

    def get_Symbol(self):
        return self.Symbol

    def set_Symbol(self, Symbol):
        self.Symbol = Symbol

    def add_Symbol(self, value):
        self.Symbol.append(value)

    def insert_Symbol_at(self, index, value):
        self.Symbol.insert(index, value)

    def replace_Symbol_at(self, index, value):
        self.Symbol[index] = value

    def get_AttributeSet(self):
        return self.AttributeSet

    def set_AttributeSet(self, AttributeSet):
        self.AttributeSet = AttributeSet

    def add_AttributeSet(self, value):
        self.AttributeSet.append(value)

    def insert_AttributeSet_at(self, index, value):
        self.AttributeSet.insert(index, value)

    def replace_AttributeSet_at(self, index, value):
        self.AttributeSet[index] = value

    def get_TraitRelationship(self):
        return self.TraitRelationship

    def set_TraitRelationship(self, TraitRelationship):
        self.TraitRelationship = TraitRelationship

    def add_TraitRelationship(self, value):
        self.TraitRelationship.append(value)

    def insert_TraitRelationship_at(self, index, value):
        self.TraitRelationship.insert(index, value)

    def replace_TraitRelationship_at(self, index, value):
        self.TraitRelationship[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.TraitType is not None or
                self.Name or
                self.Symbol or
                self.AttributeSet or
                self.TraitRelationship or
                self.Citation or
                self.XRef or
                self.Comment is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TraitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TraitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TraitType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TraitType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TraitType is not None:
            namespaceprefix_ = self.TraitType_nsprefix_ + ':' if (UseCapturedNS_ and self.TraitType_nsprefix_) else ''
            self.TraitType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TraitType',
                                  pretty_print=pretty_print)
        for Name_ in self.Name:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            Name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        for Symbol_ in self.Symbol:
            namespaceprefix_ = self.Symbol_nsprefix_ + ':' if (UseCapturedNS_ and self.Symbol_nsprefix_) else ''
            Symbol_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Symbol',
                           pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            namespaceprefix_ = self.AttributeSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AttributeSet_nsprefix_) else ''
            AttributeSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AttributeSet',
                                 pretty_print=pretty_print)
        for TraitRelationship_ in self.TraitRelationship:
            namespaceprefix_ = self.TraitRelationship_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TraitRelationship_nsprefix_) else ''
            TraitRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TraitRelationship',
                                      pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        if self.Comment is not None:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            self.Comment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TraitType':
            obj_ = TraitTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TraitType = obj_
            obj_.original_tagname_ = 'TraitType'
        elif nodeName_ == 'Name':
            obj_ = SetElementSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Symbol':
            obj_ = SetElementSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Symbol.append(obj_)
            obj_.original_tagname_ = 'Symbol'
        elif nodeName_ == 'AttributeSet':
            obj_ = AttributeSetType8.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'TraitRelationship':
            obj_ = TraitRelationshipType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TraitRelationship.append(obj_)
            obj_.original_tagname_ = 'TraitRelationship'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'


# end class TraitType


class AlleleDescType(GeneratedsSuper):
    """This is to be used within co-occurrence set"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, cv_id=0, Name=None, RelativeOrientation=None, Zygosity=None, ClinicalSignificance=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.cv_id = _cast(int, cv_id)
        self.cv_id_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.RelativeOrientation = RelativeOrientation
        self.validate_OrientationType(self.RelativeOrientation)
        self.RelativeOrientation_nsprefix_ = None
        self.Zygosity = Zygosity
        self.validate_ZygosityType(self.Zygosity)
        self.Zygosity_nsprefix_ = None
        self.ClinicalSignificance = ClinicalSignificance
        self.ClinicalSignificance_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlleleDescType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlleleDescType.subclass:
            return AlleleDescType.subclass(*args_, **kwargs_)
        else:
            return AlleleDescType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_RelativeOrientation(self):
        return self.RelativeOrientation

    def set_RelativeOrientation(self, RelativeOrientation):
        self.RelativeOrientation = RelativeOrientation

    def get_Zygosity(self):
        return self.Zygosity

    def set_Zygosity(self, Zygosity):
        self.Zygosity = Zygosity

    def get_ClinicalSignificance(self):
        return self.ClinicalSignificance

    def set_ClinicalSignificance(self, ClinicalSignificance):
        self.ClinicalSignificance = ClinicalSignificance

    def get_cv_id(self):
        return self.cv_id

    def set_cv_id(self, cv_id):
        self.cv_id = cv_id

    def validate_OrientationType(self, value):
        result = True
        # Validate type OrientationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['cis', 'trans', 'unknown']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OrientationType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def validate_ZygosityType(self, value):
        result = True
        # Validate type ZygosityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['Homozygote', 'Single heterozygote', 'Compound heterozygote', 'Hemizygote', 'not provided']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ZygosityType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def hasContent_(self):
        if (
                self.Name is not None or
                self.RelativeOrientation is not None or
                self.Zygosity is not None or
                self.ClinicalSignificance is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlleleDescType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlleleDescType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AlleleDescType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AlleleDescType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AlleleDescType'):
        if self.cv_id != 0 and 'cv_id' not in already_processed:
            already_processed.add('cv_id')
            outfile.write(' cv_id="%s"' % self.gds_format_integer(self.cv_id, input_name='cv_id'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AlleleDescType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')),
            namespaceprefix_, eol_))
        if self.RelativeOrientation is not None:
            namespaceprefix_ = self.RelativeOrientation_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.RelativeOrientation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRelativeOrientation>%s</%sRelativeOrientation>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.RelativeOrientation), input_name='RelativeOrientation')),
                                                                                   namespaceprefix_, eol_))
        if self.Zygosity is not None:
            namespaceprefix_ = self.Zygosity_nsprefix_ + ':' if (UseCapturedNS_ and self.Zygosity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZygosity>%s</%sZygosity>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Zygosity), input_name='Zygosity')),
            namespaceprefix_, eol_))
        if self.ClinicalSignificance is not None:
            namespaceprefix_ = self.ClinicalSignificance_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ClinicalSignificance_nsprefix_) else ''
            self.ClinicalSignificance.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='ClinicalSignificance', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cv_id', node)
        if value is not None and 'cv_id' not in already_processed:
            already_processed.add('cv_id')
            self.cv_id = self.gds_parse_integer(value, node, 'cv_id')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
        elif nodeName_ == 'RelativeOrientation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'RelativeOrientation')
            value_ = self.gds_validate_string(value_, node, 'RelativeOrientation')
            self.RelativeOrientation = value_
            self.RelativeOrientation_nsprefix_ = child_.prefix
            # validate type OrientationType
            self.validate_OrientationType(self.RelativeOrientation)
        elif nodeName_ == 'Zygosity':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Zygosity')
            value_ = self.gds_validate_string(value_, node, 'Zygosity')
            self.Zygosity = value_
            self.Zygosity_nsprefix_ = child_.prefix
            # validate type ZygosityType
            self.validate_ZygosityType(self.Zygosity)
        elif nodeName_ == 'ClinicalSignificance':
            obj_ = ClinicalSignificanceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClinicalSignificance = obj_
            obj_.original_tagname_ = 'ClinicalSignificance'


# end class AlleleDescType


class SampleType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, id=None, ncbi_id=None, id_status=None, uid=None, SampleDescription=None, Origin=None,
                 Ethnicity=None, GeographicOrigin=None, Tissue=None, FractionTumor=None, CellLine=None, Species=None,
                 Age=None, Strain=None, AffectedStatus=None, NumberTested=None, NumberMales=None, NumberFemales=None,
                 NumberChrTested=None, Gender=None, FamilyData=None, Proband=None, Indication=None, XRef=None,
                 Citation=None, Comment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.SampleDescription = SampleDescription
        self.SampleDescription_nsprefix_ = None
        self.Origin = Origin
        self.validate_OriginType(self.Origin)
        self.Origin_nsprefix_ = None
        self.Ethnicity = Ethnicity
        self.Ethnicity_nsprefix_ = None
        self.GeographicOrigin = GeographicOrigin
        self.GeographicOrigin_nsprefix_ = None
        self.Tissue = Tissue
        self.Tissue_nsprefix_ = None
        self.FractionTumor = FractionTumor
        self.FractionTumor_nsprefix_ = None
        self.CellLine = CellLine
        self.CellLine_nsprefix_ = None
        self.Species = Species
        self.Species_nsprefix_ = None
        if Age is None:
            self.Age = []
        else:
            self.Age = Age
        self.Age_nsprefix_ = None
        self.Strain = Strain
        self.Strain_nsprefix_ = None
        self.AffectedStatus = AffectedStatus
        self.validate_AffectedStatusType(self.AffectedStatus)
        self.AffectedStatus_nsprefix_ = None
        self.NumberTested = NumberTested
        self.NumberTested_nsprefix_ = None
        self.NumberMales = NumberMales
        self.NumberMales_nsprefix_ = None
        self.NumberFemales = NumberFemales
        self.NumberFemales_nsprefix_ = None
        self.NumberChrTested = NumberChrTested
        self.NumberChrTested_nsprefix_ = None
        self.Gender = Gender
        self.validate_GenderType(self.Gender)
        self.Gender_nsprefix_ = None
        self.FamilyData = FamilyData
        self.FamilyData_nsprefix_ = None
        self.Proband = Proband
        self.Proband_nsprefix_ = None
        self.Indication = Indication
        self.Indication_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SampleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SampleType.subclass:
            return SampleType.subclass(*args_, **kwargs_)
        else:
            return SampleType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SampleDescription(self):
        return self.SampleDescription

    def set_SampleDescription(self, SampleDescription):
        self.SampleDescription = SampleDescription

    def get_Origin(self):
        return self.Origin

    def set_Origin(self, Origin):
        self.Origin = Origin

    def get_Ethnicity(self):
        return self.Ethnicity

    def set_Ethnicity(self, Ethnicity):
        self.Ethnicity = Ethnicity

    def get_GeographicOrigin(self):
        return self.GeographicOrigin

    def set_GeographicOrigin(self, GeographicOrigin):
        self.GeographicOrigin = GeographicOrigin

    def get_Tissue(self):
        return self.Tissue

    def set_Tissue(self, Tissue):
        self.Tissue = Tissue

    def get_FractionTumor(self):
        return self.FractionTumor

    def set_FractionTumor(self, FractionTumor):
        self.FractionTumor = FractionTumor

    def get_CellLine(self):
        return self.CellLine

    def set_CellLine(self, CellLine):
        self.CellLine = CellLine

    def get_Species(self):
        return self.Species

    def set_Species(self, Species):
        self.Species = Species

    def get_Age(self):
        return self.Age

    def set_Age(self, Age):
        self.Age = Age

    def add_Age(self, value):
        self.Age.append(value)

    def insert_Age_at(self, index, value):
        self.Age.insert(index, value)

    def replace_Age_at(self, index, value):
        self.Age[index] = value

    def get_Strain(self):
        return self.Strain

    def set_Strain(self, Strain):
        self.Strain = Strain

    def get_AffectedStatus(self):
        return self.AffectedStatus

    def set_AffectedStatus(self, AffectedStatus):
        self.AffectedStatus = AffectedStatus

    def get_NumberTested(self):
        return self.NumberTested

    def set_NumberTested(self, NumberTested):
        self.NumberTested = NumberTested

    def get_NumberMales(self):
        return self.NumberMales

    def set_NumberMales(self, NumberMales):
        self.NumberMales = NumberMales

    def get_NumberFemales(self):
        return self.NumberFemales

    def set_NumberFemales(self, NumberFemales):
        self.NumberFemales = NumberFemales

    def get_NumberChrTested(self):
        return self.NumberChrTested

    def set_NumberChrTested(self, NumberChrTested):
        self.NumberChrTested = NumberChrTested

    def get_Gender(self):
        return self.Gender

    def set_Gender(self, Gender):
        self.Gender = Gender

    def get_FamilyData(self):
        return self.FamilyData

    def set_FamilyData(self, FamilyData):
        self.FamilyData = FamilyData

    def get_Proband(self):
        return self.Proband

    def set_Proband(self, Proband):
        self.Proband = Proband

    def get_Indication(self):
        return self.Indication

    def set_Indication(self, Indication):
        self.Indication = Indication

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def add_Comment(self, value):
        self.Comment.append(value)

    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)

    def replace_Comment_at(self, index, value):
        self.Comment[index] = value

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_OriginType(self, value):
        result = True
        # Validate type OriginType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['germline', 'somatic', 'de novo', 'unknown', 'not provided', 'inherited', 'maternal',
                            'paternal', 'uniparental', 'biparental', 'not-reported', 'tested-inconclusive',
                            'not applicable', 'experimentally generated']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OriginType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def validate_AffectedStatusType(self, value):
        result = True
        # Validate type AffectedStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no', 'unknown', 'not provided', 'not applicable']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on AffectedStatusType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def validate_GenderType(self, value):
        result = True
        # Validate type GenderType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['male', 'female', 'mixed']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on GenderType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.SampleDescription is not None or
                self.Origin is not None or
                self.Ethnicity is not None or
                self.GeographicOrigin is not None or
                self.Tissue is not None or
                self.FractionTumor is not None or
                self.CellLine is not None or
                self.Species is not None or
                self.Age or
                self.Strain is not None or
                self.AffectedStatus is not None or
                self.NumberTested is not None or
                self.NumberMales is not None or
                self.NumberFemales is not None or
                self.NumberChrTested is not None or
                self.Gender is not None or
                self.FamilyData is not None or
                self.Proband is not None or
                self.Indication is not None or
                self.XRef or
                self.Citation or
                self.Comment
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SampleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SampleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SampleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SampleType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SampleType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SampleType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SampleDescription is not None:
            namespaceprefix_ = self.SampleDescription_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SampleDescription_nsprefix_) else ''
            self.SampleDescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SampleDescription',
                                          pretty_print=pretty_print)
        if self.Origin is not None:
            namespaceprefix_ = self.Origin_nsprefix_ + ':' if (UseCapturedNS_ and self.Origin_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrigin>%s</%sOrigin>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Origin), input_name='Origin')),
            namespaceprefix_, eol_))
        if self.Ethnicity is not None:
            namespaceprefix_ = self.Ethnicity_nsprefix_ + ':' if (UseCapturedNS_ and self.Ethnicity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEthnicity>%s</%sEthnicity>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.Ethnicity), input_name='Ethnicity')), namespaceprefix_, eol_))
        if self.GeographicOrigin is not None:
            namespaceprefix_ = self.GeographicOrigin_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.GeographicOrigin_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGeographicOrigin>%s</%sGeographicOrigin>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.GeographicOrigin), input_name='GeographicOrigin')),
                                                                             namespaceprefix_, eol_))
        if self.Tissue is not None:
            namespaceprefix_ = self.Tissue_nsprefix_ + ':' if (UseCapturedNS_ and self.Tissue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTissue>%s</%sTissue>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Tissue), input_name='Tissue')),
            namespaceprefix_, eol_))
        if self.FractionTumor is not None:
            namespaceprefix_ = self.FractionTumor_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.FractionTumor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFractionTumor>%s</%sFractionTumor>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.FractionTumor), input_name='FractionTumor')), namespaceprefix_,
                                                                       eol_))
        if self.CellLine is not None:
            namespaceprefix_ = self.CellLine_nsprefix_ + ':' if (UseCapturedNS_ and self.CellLine_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCellLine>%s</%sCellLine>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.CellLine), input_name='CellLine')),
            namespaceprefix_, eol_))
        if self.Species is not None:
            namespaceprefix_ = self.Species_nsprefix_ + ':' if (UseCapturedNS_ and self.Species_nsprefix_) else ''
            self.Species.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Species',
                                pretty_print=pretty_print)
        for Age_ in self.Age:
            namespaceprefix_ = self.Age_nsprefix_ + ':' if (UseCapturedNS_ and self.Age_nsprefix_) else ''
            Age_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Age', pretty_print=pretty_print)
        if self.Strain is not None:
            namespaceprefix_ = self.Strain_nsprefix_ + ':' if (UseCapturedNS_ and self.Strain_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStrain>%s</%sStrain>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Strain), input_name='Strain')),
            namespaceprefix_, eol_))
        if self.AffectedStatus is not None:
            namespaceprefix_ = self.AffectedStatus_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AffectedStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAffectedStatus>%s</%sAffectedStatus>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.AffectedStatus), input_name='AffectedStatus')), namespaceprefix_,
                                                                         eol_))
        if self.NumberTested is not None:
            namespaceprefix_ = self.NumberTested_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.NumberTested_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberTested>%s</%sNumberTested>%s' % (
            namespaceprefix_, self.gds_format_integer(self.NumberTested, input_name='NumberTested'), namespaceprefix_,
            eol_))
        if self.NumberMales is not None:
            namespaceprefix_ = self.NumberMales_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.NumberMales_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberMales>%s</%sNumberMales>%s' % (
            namespaceprefix_, self.gds_format_integer(self.NumberMales, input_name='NumberMales'), namespaceprefix_,
            eol_))
        if self.NumberFemales is not None:
            namespaceprefix_ = self.NumberFemales_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.NumberFemales_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberFemales>%s</%sNumberFemales>%s' % (
            namespaceprefix_, self.gds_format_integer(self.NumberFemales, input_name='NumberFemales'), namespaceprefix_,
            eol_))
        if self.NumberChrTested is not None:
            namespaceprefix_ = self.NumberChrTested_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.NumberChrTested_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberChrTested>%s</%sNumberChrTested>%s' % (
            namespaceprefix_, self.gds_format_integer(self.NumberChrTested, input_name='NumberChrTested'),
            namespaceprefix_, eol_))
        if self.Gender is not None:
            namespaceprefix_ = self.Gender_nsprefix_ + ':' if (UseCapturedNS_ and self.Gender_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGender>%s</%sGender>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Gender), input_name='Gender')),
            namespaceprefix_, eol_))
        if self.FamilyData is not None:
            namespaceprefix_ = self.FamilyData_nsprefix_ + ':' if (UseCapturedNS_ and self.FamilyData_nsprefix_) else ''
            self.FamilyData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FamilyData',
                                   pretty_print=pretty_print)
        if self.Proband is not None:
            namespaceprefix_ = self.Proband_nsprefix_ + ':' if (UseCapturedNS_ and self.Proband_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProband>%s</%sProband>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Proband), input_name='Proband')),
            namespaceprefix_, eol_))
        if self.Indication is not None:
            namespaceprefix_ = self.Indication_nsprefix_ + ':' if (UseCapturedNS_ and self.Indication_nsprefix_) else ''
            self.Indication.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Indication',
                                   pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for Comment_ in self.Comment:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            Comment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                            pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SampleDescription':
            obj_ = SampleDescriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SampleDescription = obj_
            obj_.original_tagname_ = 'SampleDescription'
        elif nodeName_ == 'Origin':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Origin')
            value_ = self.gds_validate_string(value_, node, 'Origin')
            self.Origin = value_
            self.Origin_nsprefix_ = child_.prefix
            # validate type OriginType
            self.validate_OriginType(self.Origin)
        elif nodeName_ == 'Ethnicity':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Ethnicity')
            value_ = self.gds_validate_string(value_, node, 'Ethnicity')
            self.Ethnicity = value_
            self.Ethnicity_nsprefix_ = child_.prefix
        elif nodeName_ == 'GeographicOrigin':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GeographicOrigin')
            value_ = self.gds_validate_string(value_, node, 'GeographicOrigin')
            self.GeographicOrigin = value_
            self.GeographicOrigin_nsprefix_ = child_.prefix
        elif nodeName_ == 'Tissue':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Tissue')
            value_ = self.gds_validate_string(value_, node, 'Tissue')
            self.Tissue = value_
            self.Tissue_nsprefix_ = child_.prefix
        elif nodeName_ == 'FractionTumor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'FractionTumor')
            value_ = self.gds_validate_string(value_, node, 'FractionTumor')
            self.FractionTumor = value_
            self.FractionTumor_nsprefix_ = child_.prefix
        elif nodeName_ == 'CellLine':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CellLine')
            value_ = self.gds_validate_string(value_, node, 'CellLine')
            self.CellLine = value_
            self.CellLine_nsprefix_ = child_.prefix
        elif nodeName_ == 'Species':
            obj_ = SpeciesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Species = obj_
            obj_.original_tagname_ = 'Species'
        elif nodeName_ == 'Age':
            obj_ = AgeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Age.append(obj_)
            obj_.original_tagname_ = 'Age'
        elif nodeName_ == 'Strain':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Strain')
            value_ = self.gds_validate_string(value_, node, 'Strain')
            self.Strain = value_
            self.Strain_nsprefix_ = child_.prefix
        elif nodeName_ == 'AffectedStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AffectedStatus')
            value_ = self.gds_validate_string(value_, node, 'AffectedStatus')
            self.AffectedStatus = value_
            self.AffectedStatus_nsprefix_ = child_.prefix
            # validate type AffectedStatusType
            self.validate_AffectedStatusType(self.AffectedStatus)
        elif nodeName_ == 'NumberTested' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'NumberTested')
            ival_ = self.gds_validate_integer(ival_, node, 'NumberTested')
            self.NumberTested = ival_
            self.NumberTested_nsprefix_ = child_.prefix
        elif nodeName_ == 'NumberMales' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'NumberMales')
            ival_ = self.gds_validate_integer(ival_, node, 'NumberMales')
            self.NumberMales = ival_
            self.NumberMales_nsprefix_ = child_.prefix
        elif nodeName_ == 'NumberFemales' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'NumberFemales')
            ival_ = self.gds_validate_integer(ival_, node, 'NumberFemales')
            self.NumberFemales = ival_
            self.NumberFemales_nsprefix_ = child_.prefix
        elif nodeName_ == 'NumberChrTested' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'NumberChrTested')
            ival_ = self.gds_validate_integer(ival_, node, 'NumberChrTested')
            self.NumberChrTested = ival_
            self.NumberChrTested_nsprefix_ = child_.prefix
        elif nodeName_ == 'Gender':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Gender')
            value_ = self.gds_validate_string(value_, node, 'Gender')
            self.Gender = value_
            self.Gender_nsprefix_ = child_.prefix
            # validate type GenderType
            self.validate_GenderType(self.Gender)
        elif nodeName_ == 'FamilyData':
            obj_ = FamilyInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FamilyData = obj_
            obj_.original_tagname_ = 'FamilyData'
        elif nodeName_ == 'Proband':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Proband')
            value_ = self.gds_validate_string(value_, node, 'Proband')
            self.Proband = value_
            self.Proband_nsprefix_ = child_.prefix
        elif nodeName_ == 'Indication':
            obj_ = IndicationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Indication = obj_
            obj_.original_tagname_ = 'Indication'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'


# end class SampleType


class Co_occurrenceType(GeneratedsSuper):
    """this refers to the variant being asserted's
    zygosity"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, cv_id=0, Zygosity=None, AlleleDescSet=None, Count=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.cv_id = _cast(int, cv_id)
        self.cv_id_nsprefix_ = None
        self.Zygosity = Zygosity
        self.validate_ZygosityType(self.Zygosity)
        self.Zygosity_nsprefix_ = None
        if AlleleDescSet is None:
            self.AlleleDescSet = []
        else:
            self.AlleleDescSet = AlleleDescSet
        self.AlleleDescSet_nsprefix_ = None
        self.Count = Count
        self.Count_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Co_occurrenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Co_occurrenceType.subclass:
            return Co_occurrenceType.subclass(*args_, **kwargs_)
        else:
            return Co_occurrenceType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Zygosity(self):
        return self.Zygosity

    def set_Zygosity(self, Zygosity):
        self.Zygosity = Zygosity

    def get_AlleleDescSet(self):
        return self.AlleleDescSet

    def set_AlleleDescSet(self, AlleleDescSet):
        self.AlleleDescSet = AlleleDescSet

    def add_AlleleDescSet(self, value):
        self.AlleleDescSet.append(value)

    def insert_AlleleDescSet_at(self, index, value):
        self.AlleleDescSet.insert(index, value)

    def replace_AlleleDescSet_at(self, index, value):
        self.AlleleDescSet[index] = value

    def get_Count(self):
        return self.Count

    def set_Count(self, Count):
        self.Count = Count

    def get_cv_id(self):
        return self.cv_id

    def set_cv_id(self, cv_id):
        self.cv_id = cv_id

    def validate_ZygosityType(self, value):
        result = True
        # Validate type ZygosityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['Homozygote', 'Single heterozygote', 'Compound heterozygote', 'Hemizygote', 'not provided']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ZygosityType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def hasContent_(self):
        if (
                self.Zygosity is not None or
                self.AlleleDescSet or
                self.Count is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Co-occurrenceType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Co-occurrenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Co-occurrenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Co-occurrenceType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Co-occurrenceType'):
        if self.cv_id != 0 and 'cv_id' not in already_processed:
            already_processed.add('cv_id')
            outfile.write(' cv_id="%s"' % self.gds_format_integer(self.cv_id, input_name='cv_id'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Co-occurrenceType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Zygosity is not None:
            namespaceprefix_ = self.Zygosity_nsprefix_ + ':' if (UseCapturedNS_ and self.Zygosity_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZygosity>%s</%sZygosity>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Zygosity), input_name='Zygosity')),
            namespaceprefix_, eol_))
        for AlleleDescSet_ in self.AlleleDescSet:
            namespaceprefix_ = self.AlleleDescSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AlleleDescSet_nsprefix_) else ''
            AlleleDescSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AlleleDescSet',
                                  pretty_print=pretty_print)
        if self.Count is not None:
            namespaceprefix_ = self.Count_nsprefix_ + ':' if (UseCapturedNS_ and self.Count_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCount>%s</%sCount>%s' % (
            namespaceprefix_, self.gds_format_integer(self.Count, input_name='Count'), namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cv_id', node)
        if value is not None and 'cv_id' not in already_processed:
            already_processed.add('cv_id')
            self.cv_id = self.gds_parse_integer(value, node, 'cv_id')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Zygosity':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Zygosity')
            value_ = self.gds_validate_string(value_, node, 'Zygosity')
            self.Zygosity = value_
            self.Zygosity_nsprefix_ = child_.prefix
            # validate type ZygosityType
            self.validate_ZygosityType(self.Zygosity)
        elif nodeName_ == 'AlleleDescSet':
            obj_ = AlleleDescType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AlleleDescSet.append(obj_)
            obj_.original_tagname_ = 'AlleleDescSet'
        elif nodeName_ == 'Count' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'Count')
            ival_ = self.gds_validate_integer(ival_, node, 'Count')
            self.Count = ival_
            self.Count_nsprefix_ = child_.prefix


# end class Co_occurrenceType


class ClinicalSignificanceType(GeneratedsSuper):
    """Review status is used to summarize the level of support for
    the interpretation of clinical significance based on submissions to
    ClinVar.
    'reviewed by professional society' includes practice guidelines.
    'DateLastEvaluated' is the date the significance was last evaluated; it may
    differ from the submission date."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ReviewStatus=None, Description=None, DateLastEvaluated=None, XRef=None, Citation=None,
                 Comment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ReviewStatus = ReviewStatus
        self.validate_ReviewStatusType(self.ReviewStatus)
        self.ReviewStatus_nsprefix_ = None
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.Description_nsprefix_ = None
        if isinstance(DateLastEvaluated, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DateLastEvaluated, '%Y-%m-%d').date()
        else:
            initvalue_ = DateLastEvaluated
        self.DateLastEvaluated = initvalue_
        self.DateLastEvaluated_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClinicalSignificanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClinicalSignificanceType.subclass:
            return ClinicalSignificanceType.subclass(*args_, **kwargs_)
        else:
            return ClinicalSignificanceType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ReviewStatus(self):
        return self.ReviewStatus

    def set_ReviewStatus(self, ReviewStatus):
        self.ReviewStatus = ReviewStatus

    def get_Description(self):
        return self.Description

    def set_Description(self, Description):
        self.Description = Description

    def add_Description(self, value):
        self.Description.append(value)

    def insert_Description_at(self, index, value):
        self.Description.insert(index, value)

    def replace_Description_at(self, index, value):
        self.Description[index] = value

    def get_DateLastEvaluated(self):
        return self.DateLastEvaluated

    def set_DateLastEvaluated(self, DateLastEvaluated):
        self.DateLastEvaluated = DateLastEvaluated

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def add_Comment(self, value):
        self.Comment.append(value)

    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)

    def replace_Comment_at(self, index, value):
        self.Comment[index] = value

    def validate_ReviewStatusType(self, value):
        result = True
        # Validate type ReviewStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['no assertion provided', 'no assertion criteria provided',
                            'criteria provided, single submitter',
                            'criteria provided, multiple submitters, no conflicts',
                            'criteria provided, conflicting interpretations', 'reviewed by expert panel',
                            'practice guideline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ReviewStatusType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def hasContent_(self):
        if (
                self.ReviewStatus is not None or
                self.Description or
                self.DateLastEvaluated is not None or
                self.XRef or
                self.Citation or
                self.Comment
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ClinicalSignificanceType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClinicalSignificanceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClinicalSignificanceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClinicalSignificanceType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ClinicalSignificanceType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ClinicalSignificanceType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReviewStatus is not None:
            namespaceprefix_ = self.ReviewStatus_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ReviewStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReviewStatus>%s</%sReviewStatus>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.ReviewStatus), input_name='ReviewStatus')), namespaceprefix_,
                                                                     eol_))
        for Description_ in self.Description:
            namespaceprefix_ = self.Description_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.Description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(Description_), input_name='Description')), namespaceprefix_, eol_))
        if self.DateLastEvaluated is not None:
            namespaceprefix_ = self.DateLastEvaluated_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.DateLastEvaluated_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateLastEvaluated>%s</%sDateLastEvaluated>%s' % (
            namespaceprefix_, self.gds_format_date(self.DateLastEvaluated, input_name='DateLastEvaluated'),
            namespaceprefix_, eol_))
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for Comment_ in self.Comment:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            Comment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                            pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ReviewStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ReviewStatus')
            value_ = self.gds_validate_string(value_, node, 'ReviewStatus')
            self.ReviewStatus = value_
            self.ReviewStatus_nsprefix_ = child_.prefix
            # validate type ReviewStatusType
            self.validate_ReviewStatusType(self.ReviewStatus)
        elif nodeName_ == 'Description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Description')
            value_ = self.gds_validate_string(value_, node, 'Description')
            self.Description.append(value_)
            self.Description_nsprefix_ = child_.prefix
        elif nodeName_ == 'DateLastEvaluated':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DateLastEvaluated = dval_
            self.DateLastEvaluated_nsprefix_ = child_.prefix
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'


# end class ClinicalSignificanceType


class SequenceLocationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Assembly=None, Chr=None, Accession=None, outerStart=None, innerStart=None, start=None, stop=None,
                 innerStop=None, outerStop=None, Strand=None, variantLength=None, referenceAllele=None,
                 alternateAllele=None, id=None, ncbi_id=None, id_status=None, uid=None, valueOf_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Assembly = _cast(None, Assembly)
        self.Assembly_nsprefix_ = None
        self.Chr = _cast(None, Chr)
        self.Chr_nsprefix_ = None
        self.Accession = _cast(None, Accession)
        self.Accession_nsprefix_ = None
        self.outerStart = _cast(int, outerStart)
        self.outerStart_nsprefix_ = None
        self.innerStart = _cast(int, innerStart)
        self.innerStart_nsprefix_ = None
        self.start = _cast(int, start)
        self.start_nsprefix_ = None
        self.stop = _cast(int, stop)
        self.stop_nsprefix_ = None
        self.innerStop = _cast(int, innerStop)
        self.innerStop_nsprefix_ = None
        self.outerStop = _cast(int, outerStop)
        self.outerStop_nsprefix_ = None
        self.Strand = _cast(None, Strand)
        self.Strand_nsprefix_ = None
        self.variantLength = _cast(int, variantLength)
        self.variantLength_nsprefix_ = None
        self.referenceAllele = _cast(None, referenceAllele)
        self.referenceAllele_nsprefix_ = None
        self.alternateAllele = _cast(None, alternateAllele)
        self.alternateAllele_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SequenceLocationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SequenceLocationType.subclass:
            return SequenceLocationType.subclass(*args_, **kwargs_)
        else:
            return SequenceLocationType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Assembly(self):
        return self.Assembly

    def set_Assembly(self, Assembly):
        self.Assembly = Assembly

    def get_Chr(self):
        return self.Chr

    def set_Chr(self, Chr):
        self.Chr = Chr

    def get_Accession(self):
        return self.Accession

    def set_Accession(self, Accession):
        self.Accession = Accession

    def get_outerStart(self):
        return self.outerStart

    def set_outerStart(self, outerStart):
        self.outerStart = outerStart

    def get_innerStart(self):
        return self.innerStart

    def set_innerStart(self, innerStart):
        self.innerStart = innerStart

    def get_start(self):
        return self.start

    def set_start(self, start):
        self.start = start

    def get_stop(self):
        return self.stop

    def set_stop(self, stop):
        self.stop = stop

    def get_innerStop(self):
        return self.innerStop

    def set_innerStop(self, innerStop):
        self.innerStop = innerStop

    def get_outerStop(self):
        return self.outerStop

    def set_outerStop(self, outerStop):
        self.outerStop = outerStop

    def get_Strand(self):
        return self.Strand

    def set_Strand(self, Strand):
        self.Strand = Strand

    def get_variantLength(self):
        return self.variantLength

    def set_variantLength(self, variantLength):
        self.variantLength = variantLength

    def get_referenceAllele(self):
        return self.referenceAllele

    def set_referenceAllele(self, referenceAllele):
        self.referenceAllele = referenceAllele

    def get_alternateAllele(self):
        return self.alternateAllele

    def set_alternateAllele(self, alternateAllele):
        self.alternateAllele = alternateAllele

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_Strandtype(self, value):
        # Validate type Strandtype, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['+', '-']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on Strandtype' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SequenceLocationType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SequenceLocationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SequenceLocationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SequenceLocationType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SequenceLocationType'):
        if self.Assembly is not None and 'Assembly' not in already_processed:
            already_processed.add('Assembly')
            outfile.write(' Assembly=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.Assembly), input_name='Assembly')),))
        if self.Chr is not None and 'Chr' not in already_processed:
            already_processed.add('Chr')
            outfile.write(
                ' Chr=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Chr), input_name='Chr')),))
        if self.Accession is not None and 'Accession' not in already_processed:
            already_processed.add('Accession')
            outfile.write(' Accession=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.Accession), input_name='Accession')),))
        if self.outerStart is not None and 'outerStart' not in already_processed:
            already_processed.add('outerStart')
            outfile.write(' outerStart="%s"' % self.gds_format_integer(self.outerStart, input_name='outerStart'))
        if self.innerStart is not None and 'innerStart' not in already_processed:
            already_processed.add('innerStart')
            outfile.write(' innerStart="%s"' % self.gds_format_integer(self.innerStart, input_name='innerStart'))
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            outfile.write(' start="%s"' % self.gds_format_integer(self.start, input_name='start'))
        if self.stop is not None and 'stop' not in already_processed:
            already_processed.add('stop')
            outfile.write(' stop="%s"' % self.gds_format_integer(self.stop, input_name='stop'))
        if self.innerStop is not None and 'innerStop' not in already_processed:
            already_processed.add('innerStop')
            outfile.write(' innerStop="%s"' % self.gds_format_integer(self.innerStop, input_name='innerStop'))
        if self.outerStop is not None and 'outerStop' not in already_processed:
            already_processed.add('outerStop')
            outfile.write(' outerStop="%s"' % self.gds_format_integer(self.outerStop, input_name='outerStop'))
        if self.Strand is not None and 'Strand' not in already_processed:
            already_processed.add('Strand')
            outfile.write(' Strand=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.Strand), input_name='Strand')),))
        if self.variantLength is not None and 'variantLength' not in already_processed:
            already_processed.add('variantLength')
            outfile.write(
                ' variantLength="%s"' % self.gds_format_integer(self.variantLength, input_name='variantLength'))
        if self.referenceAllele is not None and 'referenceAllele' not in already_processed:
            already_processed.add('referenceAllele')
            outfile.write(' referenceAllele=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.referenceAllele), input_name='referenceAllele')),))
        if self.alternateAllele is not None and 'alternateAllele' not in already_processed:
            already_processed.add('alternateAllele')
            outfile.write(' alternateAllele=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.alternateAllele), input_name='alternateAllele')),))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SequenceLocationType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Assembly', node)
        if value is not None and 'Assembly' not in already_processed:
            already_processed.add('Assembly')
            self.Assembly = value
        value = find_attr_value_('Chr', node)
        if value is not None and 'Chr' not in already_processed:
            already_processed.add('Chr')
            self.Chr = value
        value = find_attr_value_('Accession', node)
        if value is not None and 'Accession' not in already_processed:
            already_processed.add('Accession')
            self.Accession = value
        value = find_attr_value_('outerStart', node)
        if value is not None and 'outerStart' not in already_processed:
            already_processed.add('outerStart')
            self.outerStart = self.gds_parse_integer(value, node, 'outerStart')
            if self.outerStart < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('innerStart', node)
        if value is not None and 'innerStart' not in already_processed:
            already_processed.add('innerStart')
            self.innerStart = self.gds_parse_integer(value, node, 'innerStart')
            if self.innerStart < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('start', node)
        if value is not None and 'start' not in already_processed:
            already_processed.add('start')
            self.start = self.gds_parse_integer(value, node, 'start')
            if self.start < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('stop', node)
        if value is not None and 'stop' not in already_processed:
            already_processed.add('stop')
            self.stop = self.gds_parse_integer(value, node, 'stop')
            if self.stop <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('innerStop', node)
        if value is not None and 'innerStop' not in already_processed:
            already_processed.add('innerStop')
            self.innerStop = self.gds_parse_integer(value, node, 'innerStop')
            if self.innerStop <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('outerStop', node)
        if value is not None and 'outerStop' not in already_processed:
            already_processed.add('outerStop')
            self.outerStop = self.gds_parse_integer(value, node, 'outerStop')
            if self.outerStop <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('Strand', node)
        if value is not None and 'Strand' not in already_processed:
            already_processed.add('Strand')
            self.Strand = value
            self.validate_Strandtype(self.Strand)  # validate type Strandtype
        value = find_attr_value_('variantLength', node)
        if value is not None and 'variantLength' not in already_processed:
            already_processed.add('variantLength')
            self.variantLength = self.gds_parse_integer(value, node, 'variantLength')
            if self.variantLength <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('referenceAllele', node)
        if value is not None and 'referenceAllele' not in already_processed:
            already_processed.add('referenceAllele')
            self.referenceAllele = value
        value = find_attr_value_('alternateAllele', node)
        if value is not None and 'alternateAllele' not in already_processed:
            already_processed.add('alternateAllele')
            self.alternateAllele = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class SequenceLocationType


class GenotypeSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, num_chr=None, id=None, ncbi_id=None, id_status=None, uid=None, GenotypeSetType_member=None,
                 MeasureSet=None, Name=None, Symbol=None, AttributeSet=None, Citation=None, XRef=None, Comment=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.num_chr = _cast(int, num_chr)
        self.num_chr_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.GenotypeSetType = GenotypeSetType_member
        self.GenotypeSetType_nsprefix_ = None
        if MeasureSet is None:
            self.MeasureSet = []
        else:
            self.MeasureSet = MeasureSet
        self.MeasureSet_nsprefix_ = None
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        self.Name_nsprefix_ = None
        if Symbol is None:
            self.Symbol = []
        else:
            self.Symbol = Symbol
        self.Symbol_nsprefix_ = None
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        self.AttributeSet_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenotypeSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenotypeSetType.subclass:
            return GenotypeSetType.subclass(*args_, **kwargs_)
        else:
            return GenotypeSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_GenotypeSetType(self):
        return self.GenotypeSetType

    def set_GenotypeSetType(self, GenotypeSetType):
        self.GenotypeSetType = GenotypeSetType

    def get_MeasureSet(self):
        return self.MeasureSet

    def set_MeasureSet(self, MeasureSet):
        self.MeasureSet = MeasureSet

    def add_MeasureSet(self, value):
        self.MeasureSet.append(value)

    def insert_MeasureSet_at(self, index, value):
        self.MeasureSet.insert(index, value)

    def replace_MeasureSet_at(self, index, value):
        self.MeasureSet[index] = value

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def add_Name(self, value):
        self.Name.append(value)

    def insert_Name_at(self, index, value):
        self.Name.insert(index, value)

    def replace_Name_at(self, index, value):
        self.Name[index] = value

    def get_Symbol(self):
        return self.Symbol

    def set_Symbol(self, Symbol):
        self.Symbol = Symbol

    def add_Symbol(self, value):
        self.Symbol.append(value)

    def insert_Symbol_at(self, index, value):
        self.Symbol.insert(index, value)

    def replace_Symbol_at(self, index, value):
        self.Symbol[index] = value

    def get_AttributeSet(self):
        return self.AttributeSet

    def set_AttributeSet(self, AttributeSet):
        self.AttributeSet = AttributeSet

    def add_AttributeSet(self, value):
        self.AttributeSet.append(value)

    def insert_AttributeSet_at(self, index, value):
        self.AttributeSet.insert(index, value)

    def replace_AttributeSet_at(self, index, value):
        self.AttributeSet[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def get_num_chr(self):
        return self.num_chr

    def set_num_chr(self, num_chr):
        self.num_chr = num_chr

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.GenotypeSetType is not None or
                self.MeasureSet or
                self.Name or
                self.Symbol or
                self.AttributeSet or
                self.Citation or
                self.XRef or
                self.Comment is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GenotypeSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenotypeSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenotypeSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GenotypeSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GenotypeSetType'):
        if self.num_chr is not None and 'num_chr' not in already_processed:
            already_processed.add('num_chr')
            outfile.write(' num_chr="%s"' % self.gds_format_integer(self.num_chr, input_name='num_chr'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GenotypeSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GenotypeSetType is not None:
            namespaceprefix_ = self.GenotypeSetType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.GenotypeSetType_nsprefix_) else ''
            self.GenotypeSetType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GenotypeSetType',
                                        pretty_print=pretty_print)
        for MeasureSet_ in self.MeasureSet:
            namespaceprefix_ = self.MeasureSet_nsprefix_ + ':' if (UseCapturedNS_ and self.MeasureSet_nsprefix_) else ''
            MeasureSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MeasureSet',
                               pretty_print=pretty_print)
        for Name_ in self.Name:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            Name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        for Symbol_ in self.Symbol:
            namespaceprefix_ = self.Symbol_nsprefix_ + ':' if (UseCapturedNS_ and self.Symbol_nsprefix_) else ''
            Symbol_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Symbol',
                           pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            namespaceprefix_ = self.AttributeSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AttributeSet_nsprefix_) else ''
            AttributeSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AttributeSet',
                                 pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        if self.Comment is not None:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            self.Comment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('num_chr', node)
        if value is not None and 'num_chr' not in already_processed:
            already_processed.add('num_chr')
            self.num_chr = self.gds_parse_integer(value, node, 'num_chr')
            if self.num_chr <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GenotypeSetType':
            obj_ = GenotypeSetTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GenotypeSetType = obj_
            obj_.original_tagname_ = 'GenotypeSetType'
        elif nodeName_ == 'MeasureSet':
            obj_ = MeasureSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasureSet.append(obj_)
            obj_.original_tagname_ = 'MeasureSet'
        elif nodeName_ == 'Name':
            obj_ = SetElementSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Symbol':
            obj_ = SetElementSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Symbol.append(obj_)
            obj_.original_tagname_ = 'Symbol'
        elif nodeName_ == 'AttributeSet':
            obj_ = MeasureSetAttributeSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'


# end class GenotypeSetType


class SubmitterType(GeneratedsSuper):
    """This is used to identify the one individual or process that is the
    submitter of record, in contrast to the many who contributed to the
    submission. The latter are reported under submitter."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Person=None, Organization=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Person = Person
        self.Person_nsprefix_ = None
        self.Organization = Organization
        self.Organization_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubmitterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubmitterType.subclass:
            return SubmitterType.subclass(*args_, **kwargs_)
        else:
            return SubmitterType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Person(self):
        return self.Person

    def set_Person(self, Person):
        self.Person = Person

    def get_Organization(self):
        return self.Organization

    def set_Organization(self, Organization):
        self.Organization = Organization

    def hasContent_(self):
        if (
                self.Person is not None or
                self.Organization is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubmitterType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubmitterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubmitterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SubmitterType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SubmitterType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubmitterType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Person is not None:
            namespaceprefix_ = self.Person_nsprefix_ + ':' if (UseCapturedNS_ and self.Person_nsprefix_) else ''
            self.Person.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Person',
                               pretty_print=pretty_print)
        if self.Organization is not None:
            namespaceprefix_ = self.Organization_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.Organization_nsprefix_) else ''
            self.Organization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organization',
                                     pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Person':
            obj_ = PersonType10.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Person = obj_
            obj_.original_tagname_ = 'Person'
        elif nodeName_ == 'Organization':
            obj_ = OrganizationType11.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organization = obj_
            obj_.original_tagname_ = 'Organization'


# end class SubmitterType


class OrgType(GeneratedsSuper):
    """For Type use 'primary' if this is the primary organization that
    should get attribution for the submission; use 'secondary' if this is an
    additional organization that should get attribution; use 'behalf' if this
    is
    an organization that is submitting on behalf of another and should not get
    attribution for the submission"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Type=None, id=None, ncbi_id=None, id_status=None, uid=None, Organization=None, Personnel=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Type = _cast(None, Type)
        self.Type_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.Organization = Organization
        self.Organization_nsprefix_ = None
        if Personnel is None:
            self.Personnel = []
        else:
            self.Personnel = Personnel
        self.Personnel_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrgType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrgType.subclass:
            return OrgType.subclass(*args_, **kwargs_)
        else:
            return OrgType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Organization(self):
        return self.Organization

    def set_Organization(self, Organization):
        self.Organization = Organization

    def get_Personnel(self):
        return self.Personnel

    def set_Personnel(self, Personnel):
        self.Personnel = Personnel

    def add_Personnel(self, value):
        self.Personnel.append(value)

    def insert_Personnel_at(self, index, value):
        self.Personnel.insert(index, value)

    def replace_Personnel_at(self, index, value):
        self.Personnel[index] = value

    def get_Type(self):
        return self.Type

    def set_Type(self, Type):
        self.Type = Type

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.Organization is not None or
                self.Personnel
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OrgType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrgType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrgType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OrgType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OrgType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(
                ' Type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Type), input_name='Type')),))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OrgType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Organization is not None:
            namespaceprefix_ = self.Organization_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.Organization_nsprefix_) else ''
            self.Organization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Organization',
                                     pretty_print=pretty_print)
        for Personnel_ in self.Personnel:
            namespaceprefix_ = self.Personnel_nsprefix_ + ':' if (UseCapturedNS_ and self.Personnel_nsprefix_) else ''
            Personnel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Personnel',
                              pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Organization':
            obj_ = OrganizationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Organization = obj_
            obj_.original_tagname_ = 'Organization'
        elif nodeName_ == 'Personnel':
            obj_ = PersonnelType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Personnel.append(obj_)
            obj_.original_tagname_ = 'Personnel'


# end class OrgType


class OrganizationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Name=None, NameAcronym=None, Institution=None, InstitutionAcronym=None,
                 OrganizationCategory='lab', Department=None, MailingAddress=None, StreetAddress=None, LabContact=None,
                 URL=None, OrgAttribute=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        if NameAcronym is None:
            self.NameAcronym = []
        else:
            self.NameAcronym = NameAcronym
        self.NameAcronym_nsprefix_ = None
        self.Institution = Institution
        self.Institution_nsprefix_ = None
        if InstitutionAcronym is None:
            self.InstitutionAcronym = []
        else:
            self.InstitutionAcronym = InstitutionAcronym
        self.InstitutionAcronym_nsprefix_ = None
        self.OrganizationCategory = OrganizationCategory
        self.validate_OrganizationCategoryList(self.OrganizationCategory)
        self.OrganizationCategory_nsprefix_ = None
        self.Department = Department
        self.Department_nsprefix_ = None
        self.MailingAddress = MailingAddress
        self.MailingAddress_nsprefix_ = None
        self.StreetAddress = StreetAddress
        self.StreetAddress_nsprefix_ = None
        if LabContact is None:
            self.LabContact = []
        else:
            self.LabContact = LabContact
        self.LabContact_nsprefix_ = None
        self.URL = URL
        self.URL_nsprefix_ = None
        if OrgAttribute is None:
            self.OrgAttribute = []
        else:
            self.OrgAttribute = OrgAttribute
        self.OrgAttribute_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganizationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganizationType.subclass:
            return OrganizationType.subclass(*args_, **kwargs_)
        else:
            return OrganizationType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_NameAcronym(self):
        return self.NameAcronym

    def set_NameAcronym(self, NameAcronym):
        self.NameAcronym = NameAcronym

    def add_NameAcronym(self, value):
        self.NameAcronym.append(value)

    def insert_NameAcronym_at(self, index, value):
        self.NameAcronym.insert(index, value)

    def replace_NameAcronym_at(self, index, value):
        self.NameAcronym[index] = value

    def get_Institution(self):
        return self.Institution

    def set_Institution(self, Institution):
        self.Institution = Institution

    def get_InstitutionAcronym(self):
        return self.InstitutionAcronym

    def set_InstitutionAcronym(self, InstitutionAcronym):
        self.InstitutionAcronym = InstitutionAcronym

    def add_InstitutionAcronym(self, value):
        self.InstitutionAcronym.append(value)

    def insert_InstitutionAcronym_at(self, index, value):
        self.InstitutionAcronym.insert(index, value)

    def replace_InstitutionAcronym_at(self, index, value):
        self.InstitutionAcronym[index] = value

    def get_OrganizationCategory(self):
        return self.OrganizationCategory

    def set_OrganizationCategory(self, OrganizationCategory):
        self.OrganizationCategory = OrganizationCategory

    def get_Department(self):
        return self.Department

    def set_Department(self, Department):
        self.Department = Department

    def get_MailingAddress(self):
        return self.MailingAddress

    def set_MailingAddress(self, MailingAddress):
        self.MailingAddress = MailingAddress

    def get_StreetAddress(self):
        return self.StreetAddress

    def set_StreetAddress(self, StreetAddress):
        self.StreetAddress = StreetAddress

    def get_LabContact(self):
        return self.LabContact

    def set_LabContact(self, LabContact):
        self.LabContact = LabContact

    def add_LabContact(self, value):
        self.LabContact.append(value)

    def insert_LabContact_at(self, index, value):
        self.LabContact.insert(index, value)

    def replace_LabContact_at(self, index, value):
        self.LabContact[index] = value

    def get_URL(self):
        return self.URL

    def set_URL(self, URL):
        self.URL = URL

    def get_OrgAttribute(self):
        return self.OrgAttribute

    def set_OrgAttribute(self, OrgAttribute):
        self.OrgAttribute = OrgAttribute

    def add_OrgAttribute(self, value):
        self.OrgAttribute.append(value)

    def insert_OrgAttribute_at(self, index, value):
        self.OrgAttribute.insert(index, value)

    def replace_OrgAttribute_at(self, index, value):
        self.OrgAttribute[index] = value

    def validate_OrganizationCategoryList(self, value):
        result = True
        # Validate type OrganizationCategoryList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['lab', 'LSDB', 'clinic', 'resource', 'consortium', 'patient registry', 'other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OrganizationCategoryList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def hasContent_(self):
        if (
                self.Name is not None or
                self.NameAcronym or
                self.Institution is not None or
                self.InstitutionAcronym or
                self.OrganizationCategory != "lab" or
                self.Department is not None or
                self.MailingAddress is not None or
                self.StreetAddress is not None or
                self.LabContact or
                self.URL is not None or
                self.OrgAttribute
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OrganizationType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrganizationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrganizationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OrganizationType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OrganizationType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OrganizationType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')),
            namespaceprefix_, eol_))
        for NameAcronym_ in self.NameAcronym:
            namespaceprefix_ = self.NameAcronym_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.NameAcronym_nsprefix_) else ''
            NameAcronym_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NameAcronym',
                                pretty_print=pretty_print)
        if self.Institution is not None:
            namespaceprefix_ = self.Institution_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.Institution_nsprefix_) else ''
            self.Institution.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Institution',
                                    pretty_print=pretty_print)
        for InstitutionAcronym_ in self.InstitutionAcronym:
            namespaceprefix_ = self.InstitutionAcronym_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.InstitutionAcronym_nsprefix_) else ''
            InstitutionAcronym_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InstitutionAcronym',
                                       pretty_print=pretty_print)
        if self.OrganizationCategory is not None:
            namespaceprefix_ = self.OrganizationCategory_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.OrganizationCategory_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganizationCategory>%s</%sOrganizationCategory>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.OrganizationCategory), input_name='OrganizationCategory')),
                                                                                     namespaceprefix_, eol_))
        if self.Department is not None:
            namespaceprefix_ = self.Department_nsprefix_ + ':' if (UseCapturedNS_ and self.Department_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDepartment>%s</%sDepartment>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.Department), input_name='Department')), namespaceprefix_, eol_))
        if self.MailingAddress is not None:
            namespaceprefix_ = self.MailingAddress_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MailingAddress_nsprefix_) else ''
            self.MailingAddress.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MailingAddress',
                                       pretty_print=pretty_print)
        if self.StreetAddress is not None:
            namespaceprefix_ = self.StreetAddress_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.StreetAddress_nsprefix_) else ''
            self.StreetAddress.export(outfile, level, namespaceprefix_, namespacedef_='', name_='StreetAddress',
                                      pretty_print=pretty_print)
        for LabContact_ in self.LabContact:
            namespaceprefix_ = self.LabContact_nsprefix_ + ':' if (UseCapturedNS_ and self.LabContact_nsprefix_) else ''
            LabContact_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LabContact',
                               pretty_print=pretty_print)
        if self.URL is not None:
            namespaceprefix_ = self.URL_nsprefix_ + ':' if (UseCapturedNS_ and self.URL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.URL), input_name='URL')),
            namespaceprefix_, eol_))
        for OrgAttribute_ in self.OrgAttribute:
            namespaceprefix_ = self.OrgAttribute_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.OrgAttribute_nsprefix_) else ''
            OrgAttribute_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OrgAttribute',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
        elif nodeName_ == 'NameAcronym':
            obj_ = AcronymType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NameAcronym.append(obj_)
            obj_.original_tagname_ = 'NameAcronym'
        elif nodeName_ == 'Institution':
            obj_ = InstitutionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Institution = obj_
            obj_.original_tagname_ = 'Institution'
        elif nodeName_ == 'InstitutionAcronym':
            obj_ = AcronymType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InstitutionAcronym.append(obj_)
            obj_.original_tagname_ = 'InstitutionAcronym'
        elif nodeName_ == 'OrganizationCategory':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OrganizationCategory')
            value_ = self.gds_validate_string(value_, node, 'OrganizationCategory')
            self.OrganizationCategory = value_
            self.OrganizationCategory_nsprefix_ = child_.prefix
            # validate type OrganizationCategoryList
            self.validate_OrganizationCategoryList(self.OrganizationCategory)
        elif nodeName_ == 'Department':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Department')
            value_ = self.gds_validate_string(value_, node, 'Department')
            self.Department = value_
            self.Department_nsprefix_ = child_.prefix
        elif nodeName_ == 'MailingAddress':
            obj_ = AddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MailingAddress = obj_
            obj_.original_tagname_ = 'MailingAddress'
        elif nodeName_ == 'StreetAddress':
            obj_ = AddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.StreetAddress = obj_
            obj_.original_tagname_ = 'StreetAddress'
        elif nodeName_ == 'LabContact':
            obj_ = ContactType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LabContact.append(obj_)
            obj_.original_tagname_ = 'LabContact'
        elif nodeName_ == 'URL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'URL')
            value_ = self.gds_validate_string(value_, node, 'URL')
            self.URL = value_
            self.URL_nsprefix_ = child_.prefix
        elif nodeName_ == 'OrgAttribute':
            obj_ = AttributeBundleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OrgAttribute.append(obj_)
            obj_.original_tagname_ = 'OrgAttribute'


# end class OrganizationType


class AddressType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Public=None, id=None, ncbi_id=None, id_status=None, uid=None, Line1=None, Line2=None, Line3=None,
                 City=None, State=None, PostCode=None, Country=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Public = _cast(bool, Public)
        self.Public_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.Line1 = Line1
        self.Line1_nsprefix_ = None
        self.Line2 = Line2
        self.Line2_nsprefix_ = None
        self.Line3 = Line3
        self.Line3_nsprefix_ = None
        self.City = City
        self.City_nsprefix_ = None
        self.State = State
        self.State_nsprefix_ = None
        self.PostCode = PostCode
        self.PostCode_nsprefix_ = None
        self.Country = Country
        self.Country_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressType.subclass:
            return AddressType.subclass(*args_, **kwargs_)
        else:
            return AddressType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Line1(self):
        return self.Line1

    def set_Line1(self, Line1):
        self.Line1 = Line1

    def get_Line2(self):
        return self.Line2

    def set_Line2(self, Line2):
        self.Line2 = Line2

    def get_Line3(self):
        return self.Line3

    def set_Line3(self, Line3):
        self.Line3 = Line3

    def get_City(self):
        return self.City

    def set_City(self, City):
        self.City = City

    def get_State(self):
        return self.State

    def set_State(self, State):
        self.State = State

    def get_PostCode(self):
        return self.PostCode

    def set_PostCode(self, PostCode):
        self.PostCode = PostCode

    def get_Country(self):
        return self.Country

    def set_Country(self, Country):
        self.Country = Country

    def get_Public(self):
        return self.Public

    def set_Public(self, Public):
        self.Public = Public

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.Line1 is not None or
                self.Line2 is not None or
                self.Line3 is not None or
                self.City is not None or
                self.State is not None or
                self.PostCode is not None or
                self.Country is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AddressType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AddressType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AddressType'):
        if self.Public is not None and 'Public' not in already_processed:
            already_processed.add('Public')
            outfile.write(' Public="%s"' % self.gds_format_boolean(self.Public, input_name='Public'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AddressType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Line1 is not None:
            namespaceprefix_ = self.Line1_nsprefix_ + ':' if (UseCapturedNS_ and self.Line1_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLine1>%s</%sLine1>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Line1), input_name='Line1')),
            namespaceprefix_, eol_))
        if self.Line2 is not None:
            namespaceprefix_ = self.Line2_nsprefix_ + ':' if (UseCapturedNS_ and self.Line2_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLine2>%s</%sLine2>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Line2), input_name='Line2')),
            namespaceprefix_, eol_))
        if self.Line3 is not None:
            namespaceprefix_ = self.Line3_nsprefix_ + ':' if (UseCapturedNS_ and self.Line3_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLine3>%s</%sLine3>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Line3), input_name='Line3')),
            namespaceprefix_, eol_))
        if self.City is not None:
            namespaceprefix_ = self.City_nsprefix_ + ':' if (UseCapturedNS_ and self.City_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCity>%s</%sCity>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')),
            namespaceprefix_, eol_))
        if self.State is not None:
            namespaceprefix_ = self.State_nsprefix_ + ':' if (UseCapturedNS_ and self.State_nsprefix_) else ''
            self.State.export(outfile, level, namespaceprefix_, namespacedef_='', name_='State',
                              pretty_print=pretty_print)
        if self.PostCode is not None:
            namespaceprefix_ = self.PostCode_nsprefix_ + ':' if (UseCapturedNS_ and self.PostCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPostCode>%s</%sPostCode>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.PostCode), input_name='PostCode')),
            namespaceprefix_, eol_))
        if self.Country is not None:
            namespaceprefix_ = self.Country_nsprefix_ + ':' if (UseCapturedNS_ and self.Country_nsprefix_) else ''
            self.Country.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Country',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Public', node)
        if value is not None and 'Public' not in already_processed:
            already_processed.add('Public')
            if value in ('true', '1'):
                self.Public = True
            elif value in ('false', '0'):
                self.Public = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Line1':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Line1')
            value_ = self.gds_validate_string(value_, node, 'Line1')
            self.Line1 = value_
            self.Line1_nsprefix_ = child_.prefix
        elif nodeName_ == 'Line2':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Line2')
            value_ = self.gds_validate_string(value_, node, 'Line2')
            self.Line2 = value_
            self.Line2_nsprefix_ = child_.prefix
        elif nodeName_ == 'Line3':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Line3')
            value_ = self.gds_validate_string(value_, node, 'Line3')
            self.Line3 = value_
            self.Line3_nsprefix_ = child_.prefix
        elif nodeName_ == 'City':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'City')
            value_ = self.gds_validate_string(value_, node, 'City')
            self.City = value_
            self.City_nsprefix_ = child_.prefix
        elif nodeName_ == 'State':
            obj_ = StateType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.State = obj_
            obj_.original_tagname_ = 'State'
        elif nodeName_ == 'PostCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PostCode')
            value_ = self.gds_validate_string(value_, node, 'PostCode')
            self.PostCode = value_
            self.PostCode_nsprefix_ = child_.prefix
        elif nodeName_ == 'Country':
            obj_ = CountryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Country = obj_
            obj_.original_tagname_ = 'Country'


# end class AddressType


class PersonnelType(GeneratedsSuper):
    """You have to provide between one and two contacts per
    Personnel. If you provide two, one has to be
    PublicContact and the other PrivateContact. Both may
    contain the same contact information (i.e., email, phone, etc.), however.
    In that case, the PublicContact will have precedence"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, PrimaryContact=None, IsDirector=None, DisplayWeb=None, Status='current', pubStat='3',
                 cv_org_id=0, id=None, ncbi_id=None, id_status=None, uid=None, Person=None, PrivateContact=None,
                 PublicContact=None, Title=None, PersonRef=None, PersonPermissions=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.PrimaryContact = _cast(bool, PrimaryContact)
        self.PrimaryContact_nsprefix_ = None
        self.IsDirector = _cast(bool, IsDirector)
        self.IsDirector_nsprefix_ = None
        self.DisplayWeb = _cast(bool, DisplayWeb)
        self.DisplayWeb_nsprefix_ = None
        self.Status = _cast(None, Status)
        self.Status_nsprefix_ = None
        self.pubStat = _cast(None, pubStat)
        self.pubStat_nsprefix_ = None
        self.cv_org_id = _cast(int, cv_org_id)
        self.cv_org_id_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.Person = Person
        self.Person_nsprefix_ = None
        self.PrivateContact = PrivateContact
        self.PrivateContact_nsprefix_ = None
        self.PublicContact = PublicContact
        self.PublicContact_nsprefix_ = None
        self.Title = Title
        self.validate_TitleList(self.Title)
        self.Title_nsprefix_ = None
        self.PersonRef = PersonRef
        self.PersonRef_nsprefix_ = None
        if PersonPermissions is None:
            self.PersonPermissions = []
        else:
            self.PersonPermissions = PersonPermissions
        self.PersonPermissions_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonnelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonnelType.subclass:
            return PersonnelType.subclass(*args_, **kwargs_)
        else:
            return PersonnelType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Person(self):
        return self.Person

    def set_Person(self, Person):
        self.Person = Person

    def get_PrivateContact(self):
        return self.PrivateContact

    def set_PrivateContact(self, PrivateContact):
        self.PrivateContact = PrivateContact

    def get_PublicContact(self):
        return self.PublicContact

    def set_PublicContact(self, PublicContact):
        self.PublicContact = PublicContact

    def get_Title(self):
        return self.Title

    def set_Title(self, Title):
        self.Title = Title

    def get_PersonRef(self):
        return self.PersonRef

    def set_PersonRef(self, PersonRef):
        self.PersonRef = PersonRef

    def get_PersonPermissions(self):
        return self.PersonPermissions

    def set_PersonPermissions(self, PersonPermissions):
        self.PersonPermissions = PersonPermissions

    def add_PersonPermissions(self, value):
        self.PersonPermissions.append(value)

    def insert_PersonPermissions_at(self, index, value):
        self.PersonPermissions.insert(index, value)

    def replace_PersonPermissions_at(self, index, value):
        self.PersonPermissions[index] = value

    def get_PrimaryContact(self):
        return self.PrimaryContact

    def set_PrimaryContact(self, PrimaryContact):
        self.PrimaryContact = PrimaryContact

    def get_IsDirector(self):
        return self.IsDirector

    def set_IsDirector(self, IsDirector):
        self.IsDirector = IsDirector

    def get_DisplayWeb(self):
        return self.DisplayWeb

    def set_DisplayWeb(self, DisplayWeb):
        self.DisplayWeb = DisplayWeb

    def get_Status(self):
        return self.Status

    def set_Status(self, Status):
        self.Status = Status

    def get_pubStat(self):
        return self.pubStat

    def set_pubStat(self, pubStat):
        self.pubStat = pubStat

    def get_cv_org_id(self):
        return self.cv_org_id

    def set_cv_org_id(self, cv_org_id):
        self.cv_org_id = cv_org_id

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_TitleList(self, value):
        result = True
        # Validate type TitleList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['Lab Director', 'Lab Associate Director', 'Medical Director', 'Genetic Counselor', 'Nurse',
                            'Research Nurse', 'Administrator', 'Staff', 'Principal Investigator', 'Contact',
                            'Informatics staff', 'CEO', 'Coordinator']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TitleList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def validate_typeStatus(self, value):
        # Validate type typeStatus, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['current', 'completed and retired', 'delete', 'in development', 'reclassified', 'reject',
                            'secondary', 'suppressed', 'under review']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeStatus' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.Person is not None or
                self.PrivateContact is not None or
                self.PublicContact is not None or
                self.Title is not None or
                self.PersonRef is not None or
                self.PersonPermissions
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PersonnelType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonnelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonnelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonnelType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PersonnelType'):
        if self.PrimaryContact is not None and 'PrimaryContact' not in already_processed:
            already_processed.add('PrimaryContact')
            outfile.write(
                ' PrimaryContact="%s"' % self.gds_format_boolean(self.PrimaryContact, input_name='PrimaryContact'))
        if self.IsDirector is not None and 'IsDirector' not in already_processed:
            already_processed.add('IsDirector')
            outfile.write(' IsDirector="%s"' % self.gds_format_boolean(self.IsDirector, input_name='IsDirector'))
        if self.DisplayWeb is not None and 'DisplayWeb' not in already_processed:
            already_processed.add('DisplayWeb')
            outfile.write(' DisplayWeb="%s"' % self.gds_format_boolean(self.DisplayWeb, input_name='DisplayWeb'))
        if self.Status != "current" and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')),))
        if self.pubStat != "3" and 'pubStat' not in already_processed:
            already_processed.add('pubStat')
            outfile.write(' pubStat=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.pubStat), input_name='pubStat')),))
        if self.cv_org_id != 0 and 'cv_org_id' not in already_processed:
            already_processed.add('cv_org_id')
            outfile.write(' cv_org_id="%s"' % self.gds_format_integer(self.cv_org_id, input_name='cv_org_id'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PersonnelType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Person is not None:
            namespaceprefix_ = self.Person_nsprefix_ + ':' if (UseCapturedNS_ and self.Person_nsprefix_) else ''
            self.Person.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Person',
                               pretty_print=pretty_print)
        if self.PrivateContact is not None:
            namespaceprefix_ = self.PrivateContact_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.PrivateContact_nsprefix_) else ''
            self.PrivateContact.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PrivateContact',
                                       pretty_print=pretty_print)
        if self.PublicContact is not None:
            namespaceprefix_ = self.PublicContact_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.PublicContact_nsprefix_) else ''
            self.PublicContact.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PublicContact',
                                      pretty_print=pretty_print)
        if self.Title is not None:
            namespaceprefix_ = self.Title_nsprefix_ + ':' if (UseCapturedNS_ and self.Title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitle>%s</%sTitle>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Title), input_name='Title')),
            namespaceprefix_, eol_))
        if self.PersonRef is not None:
            namespaceprefix_ = self.PersonRef_nsprefix_ + ':' if (UseCapturedNS_ and self.PersonRef_nsprefix_) else ''
            self.PersonRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PersonRef',
                                  pretty_print=pretty_print)
        for PersonPermissions_ in self.PersonPermissions:
            namespaceprefix_ = self.PersonPermissions_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.PersonPermissions_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPersonPermissions>%s</%sPersonPermissions>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(PersonPermissions_), input_name='PersonPermissions')),
                                                                               namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('PrimaryContact', node)
        if value is not None and 'PrimaryContact' not in already_processed:
            already_processed.add('PrimaryContact')
            if value in ('true', '1'):
                self.PrimaryContact = True
            elif value in ('false', '0'):
                self.PrimaryContact = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('IsDirector', node)
        if value is not None and 'IsDirector' not in already_processed:
            already_processed.add('IsDirector')
            if value in ('true', '1'):
                self.IsDirector = True
            elif value in ('false', '0'):
                self.IsDirector = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DisplayWeb', node)
        if value is not None and 'DisplayWeb' not in already_processed:
            already_processed.add('DisplayWeb')
            if value in ('true', '1'):
                self.DisplayWeb = True
            elif value in ('false', '0'):
                self.DisplayWeb = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
            self.validate_typeStatus(self.Status)  # validate type typeStatus
        value = find_attr_value_('pubStat', node)
        if value is not None and 'pubStat' not in already_processed:
            already_processed.add('pubStat')
            self.pubStat = value
        value = find_attr_value_('cv_org_id', node)
        if value is not None and 'cv_org_id' not in already_processed:
            already_processed.add('cv_org_id')
            self.cv_org_id = self.gds_parse_integer(value, node, 'cv_org_id')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Person':
            obj_ = PersonType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Person = obj_
            obj_.original_tagname_ = 'Person'
        elif nodeName_ == 'PrivateContact':
            obj_ = ContactType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrivateContact = obj_
            obj_.original_tagname_ = 'PrivateContact'
        elif nodeName_ == 'PublicContact':
            obj_ = ContactType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PublicContact = obj_
            obj_.original_tagname_ = 'PublicContact'
        elif nodeName_ == 'Title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Title')
            value_ = self.gds_validate_string(value_, node, 'Title')
            self.Title = value_
            self.Title_nsprefix_ = child_.prefix
            # validate type TitleList
            self.validate_TitleList(self.Title)
        elif nodeName_ == 'PersonRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PersonRef = obj_
            obj_.original_tagname_ = 'PersonRef'
        elif nodeName_ == 'PersonPermissions':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PersonPermissions')
            value_ = self.gds_validate_string(value_, node, 'PersonPermissions')
            self.PersonPermissions.append(value_)
            self.PersonPermissions_nsprefix_ = child_.prefix


# end class PersonnelType


class PersonType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Status='current', pubStat='3', cv_type=None, id=None, ncbi_id=None, id_status=None, uid=None,
                 Name=None, LabPersonID=None, Degree=None, Certification=None, Credential=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Status = _cast(None, Status)
        self.Status_nsprefix_ = None
        self.pubStat = _cast(None, pubStat)
        self.pubStat_nsprefix_ = None
        self.cv_type = _cast(int, cv_type)
        self.cv_type_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.LabPersonID = LabPersonID
        self.LabPersonID_nsprefix_ = None
        if Degree is None:
            self.Degree = []
        else:
            self.Degree = Degree
        self.Degree_nsprefix_ = None
        if Certification is None:
            self.Certification = []
        else:
            self.Certification = Certification
        self.Certification_nsprefix_ = None
        if Credential is None:
            self.Credential = []
        else:
            self.Credential = Credential
        self.Credential_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonType.subclass:
            return PersonType.subclass(*args_, **kwargs_)
        else:
            return PersonType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_LabPersonID(self):
        return self.LabPersonID

    def set_LabPersonID(self, LabPersonID):
        self.LabPersonID = LabPersonID

    def get_Degree(self):
        return self.Degree

    def set_Degree(self, Degree):
        self.Degree = Degree

    def add_Degree(self, value):
        self.Degree.append(value)

    def insert_Degree_at(self, index, value):
        self.Degree.insert(index, value)

    def replace_Degree_at(self, index, value):
        self.Degree[index] = value

    def get_Certification(self):
        return self.Certification

    def set_Certification(self, Certification):
        self.Certification = Certification

    def add_Certification(self, value):
        self.Certification.append(value)

    def insert_Certification_at(self, index, value):
        self.Certification.insert(index, value)

    def replace_Certification_at(self, index, value):
        self.Certification[index] = value

    def get_Credential(self):
        return self.Credential

    def set_Credential(self, Credential):
        self.Credential = Credential

    def add_Credential(self, value):
        self.Credential.append(value)

    def insert_Credential_at(self, index, value):
        self.Credential.insert(index, value)

    def replace_Credential_at(self, index, value):
        self.Credential[index] = value

    def get_Status(self):
        return self.Status

    def set_Status(self, Status):
        self.Status = Status

    def get_pubStat(self):
        return self.pubStat

    def set_pubStat(self, pubStat):
        self.pubStat = pubStat

    def get_cv_type(self):
        return self.cv_type

    def set_cv_type(self, cv_type):
        self.cv_type = cv_type

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_typeStatus(self, value):
        # Validate type typeStatus, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['current', 'completed and retired', 'delete', 'in development', 'reclassified', 'reject',
                            'secondary', 'suppressed', 'under review']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeStatus' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.Name is not None or
                self.LabPersonID is not None or
                self.Degree or
                self.Certification or
                self.Credential
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PersonType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PersonType'):
        if self.Status != "current" and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.Status), input_name='Status')),))
        if self.pubStat != "3" and 'pubStat' not in already_processed:
            already_processed.add('pubStat')
            outfile.write(' pubStat=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.pubStat), input_name='pubStat')),))
        if self.cv_type is not None and 'cv_type' not in already_processed:
            already_processed.add('cv_type')
            outfile.write(' cv_type="%s"' % self.gds_format_integer(self.cv_type, input_name='cv_type'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PersonType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            self.Name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name',
                             pretty_print=pretty_print)
        if self.LabPersonID is not None:
            namespaceprefix_ = self.LabPersonID_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.LabPersonID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLabPersonID>%s</%sLabPersonID>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.LabPersonID), input_name='LabPersonID')), namespaceprefix_, eol_))
        for Degree_ in self.Degree:
            namespaceprefix_ = self.Degree_nsprefix_ + ':' if (UseCapturedNS_ and self.Degree_nsprefix_) else ''
            Degree_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Degree',
                           pretty_print=pretty_print)
        for Certification_ in self.Certification:
            namespaceprefix_ = self.Certification_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.Certification_nsprefix_) else ''
            Certification_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Certification',
                                  pretty_print=pretty_print)
        for Credential_ in self.Credential:
            namespaceprefix_ = self.Credential_nsprefix_ + ':' if (UseCapturedNS_ and self.Credential_nsprefix_) else ''
            Credential_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Credential',
                               pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
            self.validate_typeStatus(self.Status)  # validate type typeStatus
        value = find_attr_value_('pubStat', node)
        if value is not None and 'pubStat' not in already_processed:
            already_processed.add('pubStat')
            self.pubStat = value
        value = find_attr_value_('cv_type', node)
        if value is not None and 'cv_type' not in already_processed:
            already_processed.add('cv_type')
            self.cv_type = self.gds_parse_integer(value, node, 'cv_type')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Name':
            obj_ = NameType12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'LabPersonID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LabPersonID')
            value_ = self.gds_validate_string(value_, node, 'LabPersonID')
            self.LabPersonID = value_
            self.LabPersonID_nsprefix_ = child_.prefix
        elif nodeName_ == 'Degree':
            obj_ = DegreeType13.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Degree.append(obj_)
            obj_.original_tagname_ = 'Degree'
        elif nodeName_ == 'Certification':
            obj_ = PersonCertificationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Certification.append(obj_)
            obj_.original_tagname_ = 'Certification'
        elif nodeName_ == 'Credential':
            obj_ = CredentialType14.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Credential.append(obj_)
            obj_.original_tagname_ = 'Credential'


# end class PersonType


class PersonCertificationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, SubSpecialty=None, Specialty=None, Board=None, ExpirationDate=None, Number=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.SubSpecialty = SubSpecialty
        self.SubSpecialty_nsprefix_ = None
        self.Specialty = Specialty
        self.Specialty_nsprefix_ = None
        self.Board = Board
        self.Board_nsprefix_ = None
        if isinstance(ExpirationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ExpirationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = ExpirationDate
        self.ExpirationDate = initvalue_
        self.ExpirationDate_nsprefix_ = None
        self.Number = Number
        self.Number_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonCertificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonCertificationType.subclass:
            return PersonCertificationType.subclass(*args_, **kwargs_)
        else:
            return PersonCertificationType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SubSpecialty(self):
        return self.SubSpecialty

    def set_SubSpecialty(self, SubSpecialty):
        self.SubSpecialty = SubSpecialty

    def get_Specialty(self):
        return self.Specialty

    def set_Specialty(self, Specialty):
        self.Specialty = Specialty

    def get_Board(self):
        return self.Board

    def set_Board(self, Board):
        self.Board = Board

    def get_ExpirationDate(self):
        return self.ExpirationDate

    def set_ExpirationDate(self, ExpirationDate):
        self.ExpirationDate = ExpirationDate

    def get_Number(self):
        return self.Number

    def set_Number(self, Number):
        self.Number = Number

    def hasContent_(self):
        if (
                self.SubSpecialty is not None or
                self.Specialty is not None or
                self.Board is not None or
                self.ExpirationDate is not None or
                self.Number is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PersonCertificationType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonCertificationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonCertificationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonCertificationType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PersonCertificationType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PersonCertificationType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SubSpecialty is not None:
            namespaceprefix_ = self.SubSpecialty_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SubSpecialty_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubSpecialty>%s</%sSubSpecialty>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.SubSpecialty), input_name='SubSpecialty')), namespaceprefix_,
                                                                     eol_))
        if self.Specialty is not None:
            namespaceprefix_ = self.Specialty_nsprefix_ + ':' if (UseCapturedNS_ and self.Specialty_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpecialty>%s</%sSpecialty>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.Specialty), input_name='Specialty')), namespaceprefix_, eol_))
        if self.Board is not None:
            namespaceprefix_ = self.Board_nsprefix_ + ':' if (UseCapturedNS_ and self.Board_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBoard>%s</%sBoard>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Board), input_name='Board')),
            namespaceprefix_, eol_))
        if self.ExpirationDate is not None:
            namespaceprefix_ = self.ExpirationDate_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ExpirationDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExpirationDate>%s</%sExpirationDate>%s' % (
            namespaceprefix_, self.gds_format_date(self.ExpirationDate, input_name='ExpirationDate'), namespaceprefix_,
            eol_))
        if self.Number is not None:
            namespaceprefix_ = self.Number_nsprefix_ + ':' if (UseCapturedNS_ and self.Number_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumber>%s</%sNumber>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Number), input_name='Number')),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SubSpecialty':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SubSpecialty')
            value_ = self.gds_validate_string(value_, node, 'SubSpecialty')
            self.SubSpecialty = value_
            self.SubSpecialty_nsprefix_ = child_.prefix
        elif nodeName_ == 'Specialty':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Specialty')
            value_ = self.gds_validate_string(value_, node, 'Specialty')
            self.Specialty = value_
            self.Specialty_nsprefix_ = child_.prefix
        elif nodeName_ == 'Board':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Board')
            value_ = self.gds_validate_string(value_, node, 'Board')
            self.Board = value_
            self.Board_nsprefix_ = child_.prefix
        elif nodeName_ == 'ExpirationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ExpirationDate = dval_
            self.ExpirationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'Number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Number')
            value_ = self.gds_validate_string(value_, node, 'Number')
            self.Number = value_
            self.Number_nsprefix_ = child_.prefix


# end class PersonCertificationType


class CertificationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Qualifier=None, Unit=None, ExpirationDate=None, Number=None, extensiontype_=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Qualifier = Qualifier
        self.Qualifier_nsprefix_ = None
        self.Unit = Unit
        self.Unit_nsprefix_ = None
        if isinstance(ExpirationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ExpirationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = ExpirationDate
        self.ExpirationDate = initvalue_
        self.ExpirationDate_nsprefix_ = None
        self.Number = Number
        self.Number_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CertificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CertificationType.subclass:
            return CertificationType.subclass(*args_, **kwargs_)
        else:
            return CertificationType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Qualifier(self):
        return self.Qualifier

    def set_Qualifier(self, Qualifier):
        self.Qualifier = Qualifier

    def get_Unit(self):
        return self.Unit

    def set_Unit(self, Unit):
        self.Unit = Unit

    def get_ExpirationDate(self):
        return self.ExpirationDate

    def set_ExpirationDate(self, ExpirationDate):
        self.ExpirationDate = ExpirationDate

    def get_Number(self):
        return self.Number

    def set_Number(self, Number):
        self.Number = Number

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.Qualifier is not None or
                self.Unit is not None or
                self.ExpirationDate is not None or
                self.Number is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CertificationType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CertificationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CertificationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CertificationType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CertificationType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CertificationType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Qualifier is not None:
            namespaceprefix_ = self.Qualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.Qualifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQualifier>%s</%sQualifier>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.Qualifier), input_name='Qualifier')), namespaceprefix_, eol_))
        if self.Unit is not None:
            namespaceprefix_ = self.Unit_nsprefix_ + ':' if (UseCapturedNS_ and self.Unit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnit>%s</%sUnit>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Unit), input_name='Unit')),
            namespaceprefix_, eol_))
        if self.ExpirationDate is not None:
            namespaceprefix_ = self.ExpirationDate_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ExpirationDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExpirationDate>%s</%sExpirationDate>%s' % (
            namespaceprefix_, self.gds_format_date(self.ExpirationDate, input_name='ExpirationDate'), namespaceprefix_,
            eol_))
        if self.Number is not None:
            namespaceprefix_ = self.Number_nsprefix_ + ':' if (UseCapturedNS_ and self.Number_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumber>%s</%sNumber>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Number), input_name='Number')),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Qualifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Qualifier')
            value_ = self.gds_validate_string(value_, node, 'Qualifier')
            self.Qualifier = value_
            self.Qualifier_nsprefix_ = child_.prefix
        elif nodeName_ == 'Unit':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Unit')
            value_ = self.gds_validate_string(value_, node, 'Unit')
            self.Unit = value_
            self.Unit_nsprefix_ = child_.prefix
        elif nodeName_ == 'ExpirationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ExpirationDate = dval_
            self.ExpirationDate_nsprefix_ = child_.prefix
        elif nodeName_ == 'Number':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Number')
            value_ = self.gds_validate_string(value_, node, 'Number')
            self.Number = value_
            self.Number_nsprefix_ = child_.prefix


# end class CertificationType


class LabCertificationType(CertificationType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CertificationType

    def __init__(self, Qualifier=None, Unit=None, ExpirationDate=None, Number=None, Type=None, Name=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(LabCertificationType, self).__init__(Qualifier, Unit, ExpirationDate, Number, **kwargs_)
        self.Type = _cast(None, Type)
        self.Type_nsprefix_ = None
        self.Name = Name
        self.validate_NameType15(self.Name)
        self.Name_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LabCertificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LabCertificationType.subclass:
            return LabCertificationType.subclass(*args_, **kwargs_)
        else:
            return LabCertificationType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_Type(self):
        return self.Type

    def set_Type(self, Type):
        self.Type = Type

    def validate_NameType15(self, value):
        result = True
        # Validate type NameType15, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['CLIA', 'CAP', 'NY CLEP', 'AABB', 'EMQN', 'CA State License', 'MD State License',
                            'License for Tennessee', 'License for Florida', 'License for Maryland']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NameType15' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def hasContent_(self):
        if (
                self.Name is not None or
                super(LabCertificationType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LabCertificationType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LabCertificationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LabCertificationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LabCertificationType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LabCertificationType'):
        super(LabCertificationType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                           name_='LabCertificationType')
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(
                ' Type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Type), input_name='Type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LabCertificationType',
                       fromsubclass_=False, pretty_print=True):
        super(LabCertificationType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                         pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        super(LabCertificationType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
            # validate type NameType15
            self.validate_NameType15(self.Name)
        super(LabCertificationType, self).buildChildren(child_, node, nodeName_, True)


# end class LabCertificationType


class DegreeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Name=None, Qualifier=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Name = Name
        self.validate_NameType16(self.Name)
        self.Name_nsprefix_ = None
        self.Qualifier = Qualifier
        self.Qualifier_nsprefix_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DegreeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DegreeType.subclass:
            return DegreeType.subclass(*args_, **kwargs_)
        else:
            return DegreeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_Qualifier(self):
        return self.Qualifier

    def set_Qualifier(self, Qualifier):
        self.Qualifier = Qualifier

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def validate_NameType16(self, value):
        result = True
        # Validate type NameType16, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['PhD', 'MD', 'MS', 'BS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NameType16' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def hasContent_(self):
        if (
                self.Name is not None or
                self.Qualifier is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DegreeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DegreeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DegreeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DegreeType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DegreeType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DegreeType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')),
            namespaceprefix_, eol_))
        if self.Qualifier is not None:
            namespaceprefix_ = self.Qualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.Qualifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQualifier>%s</%sQualifier>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.Qualifier), input_name='Qualifier')), namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
            # validate type NameType16
            self.validate_NameType16(self.Name)
        elif nodeName_ == 'Qualifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Qualifier')
            value_ = self.gds_validate_string(value_, node, 'Qualifier')
            self.Qualifier = value_
            self.Qualifier_nsprefix_ = child_.prefix


# end class DegreeType


class CredentialType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Name=None, Qualifier=None, Unit=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Name = Name
        self.validate_NameType17(self.Name)
        self.Name_nsprefix_ = None
        self.Qualifier = Qualifier
        self.Qualifier_nsprefix_ = None
        self.Unit = Unit
        self.Unit_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CredentialType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CredentialType.subclass:
            return CredentialType.subclass(*args_, **kwargs_)
        else:
            return CredentialType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_Qualifier(self):
        return self.Qualifier

    def set_Qualifier(self, Qualifier):
        self.Qualifier = Qualifier

    def get_Unit(self):
        return self.Unit

    def set_Unit(self, Unit):
        self.Unit = Unit

    def validate_NameType17(self, value):
        result = True
        # Validate type NameType17, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['CGC', 'FACMG', 'MT(ASCP)']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NameType17' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def hasContent_(self):
        if (
                self.Name is not None or
                self.Qualifier is not None or
                self.Unit is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CredentialType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CredentialType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CredentialType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CredentialType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CredentialType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CredentialType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')),
            namespaceprefix_, eol_))
        if self.Qualifier is not None:
            namespaceprefix_ = self.Qualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.Qualifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQualifier>%s</%sQualifier>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.Qualifier), input_name='Qualifier')), namespaceprefix_, eol_))
        if self.Unit is not None:
            namespaceprefix_ = self.Unit_nsprefix_ + ':' if (UseCapturedNS_ and self.Unit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnit>%s</%sUnit>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Unit), input_name='Unit')),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
            # validate type NameType17
            self.validate_NameType17(self.Name)
        elif nodeName_ == 'Qualifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Qualifier')
            value_ = self.gds_validate_string(value_, node, 'Qualifier')
            self.Qualifier = value_
            self.Qualifier_nsprefix_ = child_.prefix
        elif nodeName_ == 'Unit':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Unit')
            value_ = self.gds_validate_string(value_, node, 'Unit')
            self.Unit = value_
            self.Unit_nsprefix_ = child_.prefix


# end class CredentialType


class ContactType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, id=None, ncbi_id=None, id_status=None, uid=None, Email=None, Phone=None, Fax=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.Email = Email
        self.Email_nsprefix_ = None
        self.Phone = Phone
        self.Phone_nsprefix_ = None
        self.Fax = Fax
        self.Fax_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactType.subclass:
            return ContactType.subclass(*args_, **kwargs_)
        else:
            return ContactType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Email(self):
        return self.Email

    def set_Email(self, Email):
        self.Email = Email

    def get_Phone(self):
        return self.Phone

    def set_Phone(self, Phone):
        self.Phone = Phone

    def get_Fax(self):
        return self.Fax

    def set_Fax(self, Fax):
        self.Fax = Fax

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.Email is not None or
                self.Phone is not None or
                self.Fax is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContactType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContactType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContactType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContactType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContactType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ContactType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Email is not None:
            namespaceprefix_ = self.Email_nsprefix_ + ':' if (UseCapturedNS_ and self.Email_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEmail>%s</%sEmail>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Email), input_name='Email')),
            namespaceprefix_, eol_))
        if self.Phone is not None:
            namespaceprefix_ = self.Phone_nsprefix_ + ':' if (UseCapturedNS_ and self.Phone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPhone>%s</%sPhone>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Phone), input_name='Phone')),
            namespaceprefix_, eol_))
        if self.Fax is not None:
            namespaceprefix_ = self.Fax_nsprefix_ + ':' if (UseCapturedNS_ and self.Fax_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFax>%s</%sFax>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Fax), input_name='Fax')),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Email')
            value_ = self.gds_validate_string(value_, node, 'Email')
            self.Email = value_
            self.Email_nsprefix_ = child_.prefix
        elif nodeName_ == 'Phone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Phone')
            value_ = self.gds_validate_string(value_, node, 'Phone')
            self.Phone = value_
            self.Phone_nsprefix_ = child_.prefix
        elif nodeName_ == 'Fax':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Fax')
            value_ = self.gds_validate_string(value_, node, 'Fax')
            self.Fax = value_
            self.Fax_nsprefix_ = child_.prefix


# end class ContactType


class OrgIDType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Type = _cast(None, Type)
        self.Type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrgIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrgIDType.subclass:
            return OrgIDType.subclass(*args_, **kwargs_)
        else:
            return OrgIDType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Type(self):
        return self.Type

    def set_Type(self, Type):
        self.Type = Type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OrgIDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrgIDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrgIDType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OrgIDType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OrgIDType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(
                ' Type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Type), input_name='Type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OrgIDType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class OrgIDType


class AcronymType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, ncbi_id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AcronymType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AcronymType.subclass:
            return AcronymType.subclass(*args_, **kwargs_)
        else:
            return AcronymType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AcronymType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AcronymType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AcronymType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AcronymType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AcronymType'):
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AcronymType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class AcronymType


class SubmissionSetType(GeneratedsSuper):
    """The SubmissionSet is a set of asserted relationships. Within ClinVar
    this may be the set of assertions that constitute the accession (prefix
    RCV)
    assigned to independent assertions (accession prefix SCV). For testing
    laboratories,
    this may be a test panel. If the set represents a reference accession (RCV)
    there
    can be be only 1 for the SubmissionSet. If the Set is a test panel, the Set
    can
    consist of any mixture of RCV and SCV assertions. If an SCV is known to be
    a member
    of an RCV, only the RCV should be included in the submission. The set can
    also be
    used to submit a set of assertions from a source that are not part of a
    single
    accession, but a collection of SCV's from a laboratory. This data structure
    is consistent with the Genetic Testing
    Registry (GTR) and is used to describe the organization
    submitting data. This may be an LSDB, a testing laboratory, etc.
    date of submission This attribute should be used if the the submission set
    has public data associated with the set, such as a citation or an
    accession. The
    set_key facilitates tracking of a batch of records as a unit, and is
    particularly important if a submitter provides multiple submissions sets
    that
    need to be processed as discrete sets."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, sub_id=None, input_spreadsheet=None, Date=None, set_key=None, id=None, ncbi_id=None,
                 id_status=None, uid=None, SubmitterOfRecord=None, SubmitterOfRecordID=None, Submitter=None, OrgID=None,
                 Title=None, RefTrait=None, ClinvarSubmission=None, ClinVarDeletion=None, Comment=None, Citation=None,
                 XRef=None, StudyName=None, ReleaseStatus='public', StudyDescription=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sub_id = _cast(None, sub_id)
        self.sub_id_nsprefix_ = None
        self.input_spreadsheet = _cast(None, input_spreadsheet)
        self.input_spreadsheet_nsprefix_ = None
        if isinstance(Date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%d').date()
        else:
            initvalue_ = Date
        self.Date = initvalue_
        self.set_key = _cast(None, set_key)
        self.set_key_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.SubmitterOfRecord = SubmitterOfRecord
        self.SubmitterOfRecord_nsprefix_ = None
        self.SubmitterOfRecordID = SubmitterOfRecordID
        self.SubmitterOfRecordID_nsprefix_ = None
        if Submitter is None:
            self.Submitter = []
        else:
            self.Submitter = Submitter
        self.Submitter_nsprefix_ = None
        if OrgID is None:
            self.OrgID = []
        else:
            self.OrgID = OrgID
        self.OrgID_nsprefix_ = None
        self.Title = Title
        self.Title_nsprefix_ = None
        self.RefTrait = RefTrait
        self.RefTrait_nsprefix_ = None
        if ClinvarSubmission is None:
            self.ClinvarSubmission = []
        else:
            self.ClinvarSubmission = ClinvarSubmission
        self.ClinvarSubmission_nsprefix_ = None
        self.ClinVarDeletion = ClinVarDeletion
        self.ClinVarDeletion_nsprefix_ = None
        self.Comment = Comment
        self.Comment_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        self.StudyName = StudyName
        self.StudyName_nsprefix_ = None
        self.ReleaseStatus = ReleaseStatus
        self.validate_ReleaseStatusType(self.ReleaseStatus)
        self.ReleaseStatus_nsprefix_ = None
        if StudyDescription is None:
            self.StudyDescription = []
        else:
            self.StudyDescription = StudyDescription
        self.StudyDescription_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubmissionSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubmissionSetType.subclass:
            return SubmissionSetType.subclass(*args_, **kwargs_)
        else:
            return SubmissionSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_SubmitterOfRecord(self):
        return self.SubmitterOfRecord

    def set_SubmitterOfRecord(self, SubmitterOfRecord):
        self.SubmitterOfRecord = SubmitterOfRecord

    def get_SubmitterOfRecordID(self):
        return self.SubmitterOfRecordID

    def set_SubmitterOfRecordID(self, SubmitterOfRecordID):
        self.SubmitterOfRecordID = SubmitterOfRecordID

    def get_Submitter(self):
        return self.Submitter

    def set_Submitter(self, Submitter):
        self.Submitter = Submitter

    def add_Submitter(self, value):
        self.Submitter.append(value)

    def insert_Submitter_at(self, index, value):
        self.Submitter.insert(index, value)

    def replace_Submitter_at(self, index, value):
        self.Submitter[index] = value

    def get_OrgID(self):
        return self.OrgID

    def set_OrgID(self, OrgID):
        self.OrgID = OrgID

    def add_OrgID(self, value):
        self.OrgID.append(value)

    def insert_OrgID_at(self, index, value):
        self.OrgID.insert(index, value)

    def replace_OrgID_at(self, index, value):
        self.OrgID[index] = value

    def get_Title(self):
        return self.Title

    def set_Title(self, Title):
        self.Title = Title

    def get_RefTrait(self):
        return self.RefTrait

    def set_RefTrait(self, RefTrait):
        self.RefTrait = RefTrait

    def get_ClinvarSubmission(self):
        return self.ClinvarSubmission

    def set_ClinvarSubmission(self, ClinvarSubmission):
        self.ClinvarSubmission = ClinvarSubmission

    def add_ClinvarSubmission(self, value):
        self.ClinvarSubmission.append(value)

    def insert_ClinvarSubmission_at(self, index, value):
        self.ClinvarSubmission.insert(index, value)

    def replace_ClinvarSubmission_at(self, index, value):
        self.ClinvarSubmission[index] = value

    def get_ClinVarDeletion(self):
        return self.ClinVarDeletion

    def set_ClinVarDeletion(self, ClinVarDeletion):
        self.ClinVarDeletion = ClinVarDeletion

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_StudyName(self):
        return self.StudyName

    def set_StudyName(self, StudyName):
        self.StudyName = StudyName

    def get_ReleaseStatus(self):
        return self.ReleaseStatus

    def set_ReleaseStatus(self, ReleaseStatus):
        self.ReleaseStatus = ReleaseStatus

    def get_StudyDescription(self):
        return self.StudyDescription

    def set_StudyDescription(self, StudyDescription):
        self.StudyDescription = StudyDescription

    def add_StudyDescription(self, value):
        self.StudyDescription.append(value)

    def insert_StudyDescription_at(self, index, value):
        self.StudyDescription.insert(index, value)

    def replace_StudyDescription_at(self, index, value):
        self.StudyDescription[index] = value

    def get_sub_id(self):
        return self.sub_id

    def set_sub_id(self, sub_id):
        self.sub_id = sub_id

    def get_input_spreadsheet(self):
        return self.input_spreadsheet

    def set_input_spreadsheet(self, input_spreadsheet):
        self.input_spreadsheet = input_spreadsheet

    def get_Date(self):
        return self.Date

    def set_Date(self, Date):
        self.Date = Date

    def get_set_key(self):
        return self.set_key

    def set_set_key(self, set_key):
        self.set_key = set_key

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_ReleaseStatusType(self, value):
        result = True
        # Validate type ReleaseStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['public', 'hold until published']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ReleaseStatusType' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.SubmitterOfRecord is not None or
                self.SubmitterOfRecordID is not None or
                self.Submitter or
                self.OrgID or
                self.Title is not None or
                self.RefTrait is not None or
                self.ClinvarSubmission or
                self.ClinVarDeletion is not None or
                self.Comment is not None or
                self.Citation or
                self.XRef or
                self.StudyName is not None or
                self.ReleaseStatus != "public" or
                self.StudyDescription
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubmissionSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubmissionSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubmissionSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SubmissionSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SubmissionSetType'):
        if self.sub_id is not None and 'sub_id' not in already_processed:
            already_processed.add('sub_id')
            outfile.write(' sub_id=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.sub_id), input_name='sub_id')),))
        if self.input_spreadsheet is not None and 'input_spreadsheet' not in already_processed:
            already_processed.add('input_spreadsheet')
            outfile.write(' input_spreadsheet=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.input_spreadsheet), input_name='input_spreadsheet')),))
        if self.Date is not None and 'Date' not in already_processed:
            already_processed.add('Date')
            outfile.write(' Date="%s"' % self.gds_format_date(self.Date, input_name='Date'))
        if self.set_key is not None and 'set_key' not in already_processed:
            already_processed.add('set_key')
            outfile.write(' set_key=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.set_key), input_name='set_key')),))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubmissionSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SubmitterOfRecord is not None:
            namespaceprefix_ = self.SubmitterOfRecord_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SubmitterOfRecord_nsprefix_) else ''
            self.SubmitterOfRecord.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SubmitterOfRecord',
                                          pretty_print=pretty_print)
        if self.SubmitterOfRecordID is not None:
            namespaceprefix_ = self.SubmitterOfRecordID_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SubmitterOfRecordID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubmitterOfRecordID>%s</%sSubmitterOfRecordID>%s' % (
            namespaceprefix_, self.gds_format_integer(self.SubmitterOfRecordID, input_name='SubmitterOfRecordID'),
            namespaceprefix_, eol_))
        for Submitter_ in self.Submitter:
            namespaceprefix_ = self.Submitter_nsprefix_ + ':' if (UseCapturedNS_ and self.Submitter_nsprefix_) else ''
            Submitter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Submitter',
                              pretty_print=pretty_print)
        for OrgID_ in self.OrgID:
            namespaceprefix_ = self.OrgID_nsprefix_ + ':' if (UseCapturedNS_ and self.OrgID_nsprefix_) else ''
            OrgID_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OrgID', pretty_print=pretty_print)
        if self.Title is not None:
            namespaceprefix_ = self.Title_nsprefix_ + ':' if (UseCapturedNS_ and self.Title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitle>%s</%sTitle>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Title), input_name='Title')),
            namespaceprefix_, eol_))
        if self.RefTrait is not None:
            namespaceprefix_ = self.RefTrait_nsprefix_ + ':' if (UseCapturedNS_ and self.RefTrait_nsprefix_) else ''
            self.RefTrait.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RefTrait',
                                 pretty_print=pretty_print)
        for ClinvarSubmission_ in self.ClinvarSubmission:
            namespaceprefix_ = self.ClinvarSubmission_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ClinvarSubmission_nsprefix_) else ''
            ClinvarSubmission_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ClinvarSubmission',
                                      pretty_print=pretty_print)
        if self.ClinVarDeletion is not None:
            namespaceprefix_ = self.ClinVarDeletion_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ClinVarDeletion_nsprefix_) else ''
            self.ClinVarDeletion.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ClinVarDeletion',
                                        pretty_print=pretty_print)
        if self.Comment is not None:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            self.Comment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                                pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        if self.StudyName is not None:
            namespaceprefix_ = self.StudyName_nsprefix_ + ':' if (UseCapturedNS_ and self.StudyName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStudyName>%s</%sStudyName>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.StudyName), input_name='StudyName')), namespaceprefix_, eol_))
        if self.ReleaseStatus != "public":
            namespaceprefix_ = self.ReleaseStatus_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ReleaseStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReleaseStatus>%s</%sReleaseStatus>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.ReleaseStatus), input_name='ReleaseStatus')), namespaceprefix_,
                                                                       eol_))
        for StudyDescription_ in self.StudyDescription:
            namespaceprefix_ = self.StudyDescription_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.StudyDescription_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStudyDescription>%s</%sStudyDescription>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(StudyDescription_), input_name='StudyDescription')), namespaceprefix_,
                                                                             eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sub_id', node)
        if value is not None and 'sub_id' not in already_processed:
            already_processed.add('sub_id')
            self.sub_id = value
        value = find_attr_value_('input_spreadsheet', node)
        if value is not None and 'input_spreadsheet' not in already_processed:
            already_processed.add('input_spreadsheet')
            self.input_spreadsheet = value
        value = find_attr_value_('Date', node)
        if value is not None and 'Date' not in already_processed:
            already_processed.add('Date')
            try:
                self.Date = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (Date): %s' % exp)
        value = find_attr_value_('set_key', node)
        if value is not None and 'set_key' not in already_processed:
            already_processed.add('set_key')
            self.set_key = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SubmitterOfRecord':
            obj_ = SubmitterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SubmitterOfRecord = obj_
            obj_.original_tagname_ = 'SubmitterOfRecord'
        elif nodeName_ == 'SubmitterOfRecordID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SubmitterOfRecordID')
            ival_ = self.gds_validate_integer(ival_, node, 'SubmitterOfRecordID')
            self.SubmitterOfRecordID = ival_
            self.SubmitterOfRecordID_nsprefix_ = child_.prefix
        elif nodeName_ == 'Submitter':
            obj_ = OrgType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Submitter.append(obj_)
            obj_.original_tagname_ = 'Submitter'
        elif nodeName_ == 'OrgID':
            obj_ = OrgIDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OrgID.append(obj_)
            obj_.original_tagname_ = 'OrgID'
        elif nodeName_ == 'Title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Title')
            value_ = self.gds_validate_string(value_, node, 'Title')
            self.Title = value_
            self.Title_nsprefix_ = child_.prefix
        elif nodeName_ == 'RefTrait':
            obj_ = TraitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RefTrait = obj_
            obj_.original_tagname_ = 'RefTrait'
        elif nodeName_ == 'ClinvarSubmission':
            obj_ = SubmissionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClinvarSubmission.append(obj_)
            obj_.original_tagname_ = 'ClinvarSubmission'
        elif nodeName_ == 'ClinVarDeletion':
            obj_ = ClinVarDeletionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClinVarDeletion = obj_
            obj_.original_tagname_ = 'ClinVarDeletion'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'StudyName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'StudyName')
            value_ = self.gds_validate_string(value_, node, 'StudyName')
            self.StudyName = value_
            self.StudyName_nsprefix_ = child_.prefix
        elif nodeName_ == 'ReleaseStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ReleaseStatus')
            value_ = self.gds_validate_string(value_, node, 'ReleaseStatus')
            self.ReleaseStatus = value_
            self.ReleaseStatus_nsprefix_ = child_.prefix
            # validate type ReleaseStatusType
            self.validate_ReleaseStatusType(self.ReleaseStatus)
        elif nodeName_ == 'StudyDescription':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'StudyDescription')
            value_ = self.gds_validate_string(value_, node, 'StudyDescription')
            self.StudyDescription.append(value_)
            self.StudyDescription_nsprefix_ = child_.prefix


# end class SubmissionSetType


class TypeType(GeneratedsSuper):
    """The name or id of comment_type in clinvar"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TypeType.subclass:
            return TypeType.subclass(*args_, **kwargs_)
        else:
            return TypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TypeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class TypeType


class CitationTypeType(GeneratedsSuper):
    """Will be set to 'general' on submission processing if not
    provided."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CitationTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CitationTypeType.subclass:
            return CitationTypeType.subclass(*args_, **kwargs_)
        else:
            return CitationTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CitationTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CitationTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CitationTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CitationTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CitationTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CitationTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class CitationTypeType


class IDType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Source=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Source = _cast(None, Source)
        self.Source_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IDType.subclass:
            return IDType.subclass(*args_, **kwargs_)
        else:
            return IDType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Source(self):
        return self.Source

    def set_Source(self, Source):
        self.Source = Source

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IDType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IDType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IDType'):
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            outfile.write(' Source=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.Source), input_name='Source')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IDType', fromsubclass_=False,
                       pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.add('Source')
            self.Source = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class IDType


class AttributeTypeType1(AttributeTypeType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AttributeTypeType

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AttributeTypeType1, self).__init__(val_type, valueOf_, **kwargs_)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeTypeType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeTypeType1.subclass:
            return AttributeTypeType1.subclass(*args_, **kwargs_)
        else:
            return AttributeTypeType1(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_) or
                super(AttributeTypeType1, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeTypeType1',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AttributeTypeType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AttributeTypeType1')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AttributeTypeType1',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AttributeTypeType1'):
        super(AttributeTypeType1, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                         name_='AttributeTypeType1')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeTypeType1',
                       fromsubclass_=False, pretty_print=True):
        super(AttributeTypeType1, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                       pretty_print=pretty_print)
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(AttributeTypeType1, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class AttributeTypeType1


class ElementValueTypeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElementValueTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElementValueTypeType.subclass:
            return ElementValueTypeType.subclass(*args_, **kwargs_)
        else:
            return ElementValueTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ElementValueTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElementValueTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElementValueTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ElementValueTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ElementValueTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ElementValueTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ElementValueTypeType


class ElementValueType(GeneratedsSuper):
    """Used generically to define the attributes of sets of data
    (such as sets of conditions or phenotypes, or sets of variations) or their
    relationships (measure-target)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, db=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.db = _cast(None, db)
        self.db_nsprefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElementValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElementValueType.subclass:
            return ElementValueType.subclass(*args_, **kwargs_)
        else:
            return ElementValueType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_db(self):
        return self.db

    def set_db(self, db):
        self.db = db

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ElementValueType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElementValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElementValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ElementValueType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ElementValueType'):
        if self.db is not None and 'db' not in already_processed:
            already_processed.add('db')
            outfile.write(' db=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.db), input_name='db')),))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ElementValueType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('db', node)
        if value is not None and 'db' not in already_processed:
            already_processed.add('db')
            self.db = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ElementValueType


class MethodTypeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MethodTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MethodTypeType.subclass:
            return MethodTypeType.subclass(*args_, **kwargs_)
        else:
            return MethodTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MethodTypeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MethodTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MethodTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MethodTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MethodTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MethodTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class MethodTypeType


class AttributeTypeType2(MethodAttributeTypeType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MethodAttributeTypeType

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AttributeTypeType2, self).__init__(val_type, valueOf_, **kwargs_)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeTypeType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeTypeType2.subclass:
            return AttributeTypeType2.subclass(*args_, **kwargs_)
        else:
            return AttributeTypeType2(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_) or
                super(AttributeTypeType2, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeTypeType2',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AttributeTypeType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AttributeTypeType2')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AttributeTypeType2',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AttributeTypeType2'):
        super(AttributeTypeType2, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                         name_='AttributeTypeType2')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeTypeType2',
                       fromsubclass_=False, pretty_print=True):
        super(AttributeTypeType2, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                       pretty_print=pretty_print)
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(AttributeTypeType2, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class AttributeTypeType2


class AttributeTypeType3(ObsMethodAttributeTypeType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ObsMethodAttributeTypeType

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AttributeTypeType3, self).__init__(val_type, valueOf_, **kwargs_)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeTypeType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeTypeType3.subclass:
            return AttributeTypeType3.subclass(*args_, **kwargs_)
        else:
            return AttributeTypeType3(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_) or
                super(AttributeTypeType3, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeTypeType3',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AttributeTypeType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AttributeTypeType3')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AttributeTypeType3',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AttributeTypeType3'):
        super(AttributeTypeType3, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                         name_='AttributeTypeType3')

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeTypeType3',
                       fromsubclass_=False, pretty_print=True):
        super(AttributeTypeType3, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                       pretty_print=pretty_print)
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(AttributeTypeType3, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class AttributeTypeType3


class ObsAttributeTypeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObsAttributeTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObsAttributeTypeType.subclass:
            return ObsAttributeTypeType.subclass(*args_, **kwargs_)
        else:
            return ObsAttributeTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObsAttributeTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObsAttributeTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObsAttributeTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObsAttributeTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ObsAttributeTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObsAttributeTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ObsAttributeTypeType


class ObsDecAttributeTypeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObsDecAttributeTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObsDecAttributeTypeType.subclass:
            return ObsDecAttributeTypeType.subclass(*args_, **kwargs_)
        else:
            return ObsDecAttributeTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObsDecAttributeTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObsDecAttributeTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObsDecAttributeTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObsDecAttributeTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ObsDecAttributeTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObsDecAttributeTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ObsDecAttributeTypeType


class ClinvarSubmissionIDType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, submitter=None, title=None, localKey=None, submittedAssembly=None, submitterDate=None,
                 submitter_variant_id=None, localKeyIsSubmitted=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.submitter = _cast(None, submitter)
        self.submitter_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.localKey = _cast(None, localKey)
        self.localKey_nsprefix_ = None
        self.submittedAssembly = _cast(None, submittedAssembly)
        self.submittedAssembly_nsprefix_ = None
        if isinstance(submitterDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(submitterDate, '%Y-%m-%d').date()
        else:
            initvalue_ = submitterDate
        self.submitterDate = initvalue_
        self.submitter_variant_id = _cast(None, submitter_variant_id)
        self.submitter_variant_id_nsprefix_ = None
        self.localKeyIsSubmitted = _cast(int, localKeyIsSubmitted)
        self.localKeyIsSubmitted_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClinvarSubmissionIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClinvarSubmissionIDType.subclass:
            return ClinvarSubmissionIDType.subclass(*args_, **kwargs_)
        else:
            return ClinvarSubmissionIDType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_submitter(self):
        return self.submitter

    def set_submitter(self, submitter):
        self.submitter = submitter

    def get_title(self):
        return self.title

    def set_title(self, title):
        self.title = title

    def get_localKey(self):
        return self.localKey

    def set_localKey(self, localKey):
        self.localKey = localKey

    def get_submittedAssembly(self):
        return self.submittedAssembly

    def set_submittedAssembly(self, submittedAssembly):
        self.submittedAssembly = submittedAssembly

    def get_submitterDate(self):
        return self.submitterDate

    def set_submitterDate(self, submitterDate):
        self.submitterDate = submitterDate

    def get_submitter_variant_id(self):
        return self.submitter_variant_id

    def set_submitter_variant_id(self, submitter_variant_id):
        self.submitter_variant_id = submitter_variant_id

    def get_localKeyIsSubmitted(self):
        return self.localKeyIsSubmitted

    def set_localKeyIsSubmitted(self, localKeyIsSubmitted):
        self.localKeyIsSubmitted = localKeyIsSubmitted

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ClinvarSubmissionIDType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClinvarSubmissionIDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClinvarSubmissionIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClinvarSubmissionIDType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ClinvarSubmissionIDType'):
        if self.submitter is not None and 'submitter' not in already_processed:
            already_processed.add('submitter')
            outfile.write(' submitter=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.submitter), input_name='submitter')),))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(
                ' title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')),))
        if self.localKey is not None and 'localKey' not in already_processed:
            already_processed.add('localKey')
            outfile.write(' localKey=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.localKey), input_name='localKey')),))
        if self.submittedAssembly is not None and 'submittedAssembly' not in already_processed:
            already_processed.add('submittedAssembly')
            outfile.write(' submittedAssembly=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.submittedAssembly), input_name='submittedAssembly')),))
        if self.submitterDate is not None and 'submitterDate' not in already_processed:
            already_processed.add('submitterDate')
            outfile.write(' submitterDate="%s"' % self.gds_format_date(self.submitterDate, input_name='submitterDate'))
        if self.submitter_variant_id is not None and 'submitter_variant_id' not in already_processed:
            already_processed.add('submitter_variant_id')
            outfile.write(' submitter_variant_id=%s' % (self.gds_encode(
                self.gds_format_string(quote_attrib(self.submitter_variant_id), input_name='submitter_variant_id')),))
        if self.localKeyIsSubmitted is not None and 'localKeyIsSubmitted' not in already_processed:
            already_processed.add('localKeyIsSubmitted')
            outfile.write(' localKeyIsSubmitted="%s"' % self.gds_format_integer(self.localKeyIsSubmitted,
                                                                                input_name='localKeyIsSubmitted'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ClinvarSubmissionIDType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('submitter', node)
        if value is not None and 'submitter' not in already_processed:
            already_processed.add('submitter')
            self.submitter = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('localKey', node)
        if value is not None and 'localKey' not in already_processed:
            already_processed.add('localKey')
            self.localKey = value
        value = find_attr_value_('submittedAssembly', node)
        if value is not None and 'submittedAssembly' not in already_processed:
            already_processed.add('submittedAssembly')
            self.submittedAssembly = value
        value = find_attr_value_('submitterDate', node)
        if value is not None and 'submitterDate' not in already_processed:
            already_processed.add('submitterDate')
            try:
                self.submitterDate = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (submitterDate): %s' % exp)
        value = find_attr_value_('submitter_variant_id', node)
        if value is not None and 'submitter_variant_id' not in already_processed:
            already_processed.add('submitter_variant_id')
            self.submitter_variant_id = value
        value = find_attr_value_('localKeyIsSubmitted', node)
        if value is not None and 'localKeyIsSubmitted' not in already_processed:
            already_processed.add('localKeyIsSubmitted')
            self.localKeyIsSubmitted = self.gds_parse_integer(value, node, 'localKeyIsSubmitted')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ClinvarSubmissionIDType


class ClinvarSubmissionAccType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Acc=None, ClinvarSubmissionAccType_member=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Acc = _cast(None, Acc)
        self.Acc_nsprefix_ = None
        self.ClinvarSubmissionAccType = ClinvarSubmissionAccType_member
        self.ClinvarSubmissionAccType_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClinvarSubmissionAccType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClinvarSubmissionAccType.subclass:
            return ClinvarSubmissionAccType.subclass(*args_, **kwargs_)
        else:
            return ClinvarSubmissionAccType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ClinvarSubmissionAccType(self):
        return self.ClinvarSubmissionAccType

    def set_ClinvarSubmissionAccType(self, ClinvarSubmissionAccType):
        self.ClinvarSubmissionAccType = ClinvarSubmissionAccType

    def get_Acc(self):
        return self.Acc

    def set_Acc(self, Acc):
        self.Acc = Acc

    def hasContent_(self):
        if (
                self.ClinvarSubmissionAccType is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ClinvarSubmissionAccType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClinvarSubmissionAccType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClinvarSubmissionAccType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClinvarSubmissionAccType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ClinvarSubmissionAccType'):
        if self.Acc is not None and 'Acc' not in already_processed:
            already_processed.add('Acc')
            outfile.write(
                ' Acc=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Acc), input_name='Acc')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ClinvarSubmissionAccType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClinvarSubmissionAccType is not None:
            namespaceprefix_ = self.ClinvarSubmissionAccType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.ClinvarSubmissionAccType_nsprefix_) else ''
            self.ClinvarSubmissionAccType.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                 name_='ClinvarSubmissionAccType', pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Acc', node)
        if value is not None and 'Acc' not in already_processed:
            already_processed.add('Acc')
            self.Acc = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ClinvarSubmissionAccType':
            obj_ = ClinvarSubmissionAccTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClinvarSubmissionAccType = obj_
            obj_.original_tagname_ = 'ClinvarSubmissionAccType'


# end class ClinvarSubmissionAccType


class ClinvarSubmissionAccTypeType(GeneratedsSuper):
    """Each assertion of the relationship between a set
    of variations and a set of
    phenotype measures is assigned an accession
    in ClinVar. The prefix for the an external submitter's accession
    is SCV (submitted ClinVar);
    assertions curated by NCBI staff are
    assigned a private NCV accession (such as gene-disease
    relationship reported in the
    literature. The aggregate of submissions for the
    same assertion is assigned an RCV accession (aka reference
    ClinVar)"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClinvarSubmissionAccTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClinvarSubmissionAccTypeType.subclass:
            return ClinvarSubmissionAccTypeType.subclass(*args_, **kwargs_)
        else:
            return ClinvarSubmissionAccTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ClinvarSubmissionAccTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClinvarSubmissionAccTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClinvarSubmissionAccTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='ClinvarSubmissionAccTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='ClinvarSubmissionAccTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='ClinvarSubmissionAccTypeType', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class ClinvarSubmissionAccTypeType


class AssertionType4(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, AssertionType=None, AssertionCriteriaFile=None, XRef=None, Citation=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.AssertionType = AssertionType
        self.AssertionType_nsprefix_ = None
        self.AssertionCriteriaFile = AssertionCriteriaFile
        self.AssertionCriteriaFile_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssertionType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssertionType4.subclass:
            return AssertionType4.subclass(*args_, **kwargs_)
        else:
            return AssertionType4(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AssertionType(self):
        return self.AssertionType

    def set_AssertionType(self, AssertionType):
        self.AssertionType = AssertionType

    def get_AssertionCriteriaFile(self):
        return self.AssertionCriteriaFile

    def set_AssertionCriteriaFile(self, AssertionCriteriaFile):
        self.AssertionCriteriaFile = AssertionCriteriaFile

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def hasContent_(self):
        if (
                self.AssertionType is not None or
                self.AssertionCriteriaFile is not None or
                self.XRef or
                self.Citation
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AssertionType4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssertionType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssertionType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AssertionType4',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AssertionType4'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AssertionType4',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AssertionType is not None:
            namespaceprefix_ = self.AssertionType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AssertionType_nsprefix_) else ''
            self.AssertionType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssertionType',
                                      pretty_print=pretty_print)
        if self.AssertionCriteriaFile is not None:
            namespaceprefix_ = self.AssertionCriteriaFile_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AssertionCriteriaFile_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAssertionCriteriaFile>%s</%sAssertionCriteriaFile>%s' % (namespaceprefix_,
                                                                                       self.gds_encode(
                                                                                           self.gds_format_string(
                                                                                               quote_xml(
                                                                                                   self.AssertionCriteriaFile),
                                                                                               input_name='AssertionCriteriaFile')),
                                                                                       namespaceprefix_, eol_))
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AssertionType':
            obj_ = AssertionTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssertionType = obj_
            obj_.original_tagname_ = 'AssertionType'
        elif nodeName_ == 'AssertionCriteriaFile':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AssertionCriteriaFile')
            value_ = self.gds_validate_string(value_, node, 'AssertionCriteriaFile')
            self.AssertionCriteriaFile = value_
            self.AssertionCriteriaFile_nsprefix_ = child_.prefix
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'


# end class AssertionType4


class AssertionTypeType(GeneratedsSuper):
    """relat_type in measure_target"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssertionTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssertionTypeType.subclass:
            return AssertionTypeType.subclass(*args_, **kwargs_)
        else:
            return AssertionTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AssertionTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssertionTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssertionTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AssertionTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AssertionTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AssertionTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class AssertionTypeType


class CustomAssertionScoreType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Value=None, CustomAssertionScoreType_member=None, XRef=None, Citation=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Value = _cast(None, Value)
        self.Value_nsprefix_ = None
        self.CustomAssertionScoreType = CustomAssertionScoreType_member
        self.CustomAssertionScoreType_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomAssertionScoreType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomAssertionScoreType.subclass:
            return CustomAssertionScoreType.subclass(*args_, **kwargs_)
        else:
            return CustomAssertionScoreType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_CustomAssertionScoreType(self):
        return self.CustomAssertionScoreType

    def set_CustomAssertionScoreType(self, CustomAssertionScoreType):
        self.CustomAssertionScoreType = CustomAssertionScoreType

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_Value(self):
        return self.Value

    def set_Value(self, Value):
        self.Value = Value

    def hasContent_(self):
        if (
                self.CustomAssertionScoreType is not None or
                self.XRef or
                self.Citation
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CustomAssertionScoreType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomAssertionScoreType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomAssertionScoreType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomAssertionScoreType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='CustomAssertionScoreType'):
        if self.Value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            outfile.write(
                ' Value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Value), input_name='Value')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CustomAssertionScoreType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomAssertionScoreType is not None:
            namespaceprefix_ = self.CustomAssertionScoreType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CustomAssertionScoreType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustomAssertionScoreType>%s</%sCustomAssertionScoreType>%s' % (namespaceprefix_,
                                                                                             self.gds_encode(
                                                                                                 self.gds_format_string(
                                                                                                     quote_xml(
                                                                                                         self.CustomAssertionScoreType),
                                                                                                     input_name='CustomAssertionScoreType')),
                                                                                             namespaceprefix_, eol_))
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Value', node)
        if value is not None and 'Value' not in already_processed:
            already_processed.add('Value')
            self.Value = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CustomAssertionScoreType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CustomAssertionScoreType')
            value_ = self.gds_validate_string(value_, node, 'CustomAssertionScoreType')
            self.CustomAssertionScoreType = value_
            self.CustomAssertionScoreType_nsprefix_ = child_.prefix
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'


# end class CustomAssertionScoreType


class AttributeSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, MeasureTraitAttributeType=None, Attribute=None, Citation=None, XRef=None, Comment=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MeasureTraitAttributeType = MeasureTraitAttributeType
        self.MeasureTraitAttributeType_nsprefix_ = None
        self.Attribute = Attribute
        self.Attribute_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeSetType.subclass:
            return AttributeSetType.subclass(*args_, **kwargs_)
        else:
            return AttributeSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MeasureTraitAttributeType(self):
        return self.MeasureTraitAttributeType

    def set_MeasureTraitAttributeType(self, MeasureTraitAttributeType):
        self.MeasureTraitAttributeType = MeasureTraitAttributeType

    def get_Attribute(self):
        return self.Attribute

    def set_Attribute(self, Attribute):
        self.Attribute = Attribute

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def add_Comment(self, value):
        self.Comment.append(value)

    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)

    def replace_Comment_at(self, index, value):
        self.Comment[index] = value

    def hasContent_(self):
        if (
                self.MeasureTraitAttributeType is not None or
                self.Attribute is not None or
                self.Citation or
                self.XRef or
                self.Comment
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeSetType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AttributeSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AttributeSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AttributeSetType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AttributeSetType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeSetType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeasureTraitAttributeType is not None:
            namespaceprefix_ = self.MeasureTraitAttributeType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MeasureTraitAttributeType_nsprefix_) else ''
            self.MeasureTraitAttributeType.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                  name_='MeasureTraitAttributeType', pretty_print=pretty_print)
        if self.Attribute is not None:
            namespaceprefix_ = self.Attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.Attribute_nsprefix_) else ''
            self.Attribute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Attribute',
                                  pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            Comment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                            pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MeasureTraitAttributeType':
            obj_ = MeasureTraitAttributeTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasureTraitAttributeType = obj_
            obj_.original_tagname_ = 'MeasureTraitAttributeType'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'


# end class AttributeSetType


class MeasureTraitAttributeTypeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureTraitAttributeTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureTraitAttributeTypeType.subclass:
            return MeasureTraitAttributeTypeType.subclass(*args_, **kwargs_)
        else:
            return MeasureTraitAttributeTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureTraitAttributeTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasureTraitAttributeTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='MeasureTraitAttributeTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='MeasureTraitAttributeTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='MeasureTraitAttributeTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='MeasureTraitAttributeTypeType', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class MeasureTraitAttributeTypeType


class MeasureSetTypeType(GeneratedsSuper):
    """The name or id of measureset_type in
    clinvar"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureSetTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureSetTypeType.subclass:
            return MeasureSetTypeType.subclass(*args_, **kwargs_)
        else:
            return MeasureSetTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureSetTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasureSetTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeasureSetTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeasureSetTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MeasureSetTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureSetTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class MeasureSetTypeType


class MeasureType(GeneratedsSuper):
    """Measure is used to represent the sequence or analyte being
    measured to evaluate a relationship to the trait. This can be a gene, a
    variation, a protein, etc. The measure must be unambiguously defined. That
    definition may be supplied either by a unique name or symbol or expression,
    a sequence location, or an identifier in a public database such as a GeneID
    or an HGNC id."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, id=None, ncbi_id=None, id_status=None, uid=None, MeasureType_member=None, Name=None, Symbol=None,
                 AttributeSet=None, CytogeneticLocation=None, SequenceLocation=None, MeasureRelationship=None,
                 Citation=None, XRef=None, Comment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.MeasureType = MeasureType_member
        self.MeasureType_nsprefix_ = None
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        self.Name_nsprefix_ = None
        if Symbol is None:
            self.Symbol = []
        else:
            self.Symbol = Symbol
        self.Symbol_nsprefix_ = None
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        self.AttributeSet_nsprefix_ = None
        self.CytogeneticLocation = CytogeneticLocation
        self.CytogeneticLocation_nsprefix_ = None
        if SequenceLocation is None:
            self.SequenceLocation = []
        else:
            self.SequenceLocation = SequenceLocation
        self.SequenceLocation_nsprefix_ = None
        if MeasureRelationship is None:
            self.MeasureRelationship = []
        else:
            self.MeasureRelationship = MeasureRelationship
        self.MeasureRelationship_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureType.subclass:
            return MeasureType.subclass(*args_, **kwargs_)
        else:
            return MeasureType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MeasureType(self):
        return self.MeasureType

    def set_MeasureType(self, MeasureType):
        self.MeasureType = MeasureType

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def add_Name(self, value):
        self.Name.append(value)

    def insert_Name_at(self, index, value):
        self.Name.insert(index, value)

    def replace_Name_at(self, index, value):
        self.Name[index] = value

    def get_Symbol(self):
        return self.Symbol

    def set_Symbol(self, Symbol):
        self.Symbol = Symbol

    def add_Symbol(self, value):
        self.Symbol.append(value)

    def insert_Symbol_at(self, index, value):
        self.Symbol.insert(index, value)

    def replace_Symbol_at(self, index, value):
        self.Symbol[index] = value

    def get_AttributeSet(self):
        return self.AttributeSet

    def set_AttributeSet(self, AttributeSet):
        self.AttributeSet = AttributeSet

    def add_AttributeSet(self, value):
        self.AttributeSet.append(value)

    def insert_AttributeSet_at(self, index, value):
        self.AttributeSet.insert(index, value)

    def replace_AttributeSet_at(self, index, value):
        self.AttributeSet[index] = value

    def get_CytogeneticLocation(self):
        return self.CytogeneticLocation

    def set_CytogeneticLocation(self, CytogeneticLocation):
        self.CytogeneticLocation = CytogeneticLocation

    def get_SequenceLocation(self):
        return self.SequenceLocation

    def set_SequenceLocation(self, SequenceLocation):
        self.SequenceLocation = SequenceLocation

    def add_SequenceLocation(self, value):
        self.SequenceLocation.append(value)

    def insert_SequenceLocation_at(self, index, value):
        self.SequenceLocation.insert(index, value)

    def replace_SequenceLocation_at(self, index, value):
        self.SequenceLocation[index] = value

    def get_MeasureRelationship(self):
        return self.MeasureRelationship

    def set_MeasureRelationship(self, MeasureRelationship):
        self.MeasureRelationship = MeasureRelationship

    def add_MeasureRelationship(self, value):
        self.MeasureRelationship.append(value)

    def insert_MeasureRelationship_at(self, index, value):
        self.MeasureRelationship.insert(index, value)

    def replace_MeasureRelationship_at(self, index, value):
        self.MeasureRelationship[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.MeasureType is not None or
                self.Name or
                self.Symbol or
                self.AttributeSet or
                self.CytogeneticLocation is not None or
                self.SequenceLocation or
                self.MeasureRelationship or
                self.Citation or
                self.XRef or
                self.Comment is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeasureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeasureType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MeasureType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeasureType is not None:
            namespaceprefix_ = self.MeasureType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MeasureType_nsprefix_) else ''
            self.MeasureType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MeasureType',
                                    pretty_print=pretty_print)
        for Name_ in self.Name:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            Name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        for Symbol_ in self.Symbol:
            namespaceprefix_ = self.Symbol_nsprefix_ + ':' if (UseCapturedNS_ and self.Symbol_nsprefix_) else ''
            Symbol_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Symbol',
                           pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            namespaceprefix_ = self.AttributeSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AttributeSet_nsprefix_) else ''
            AttributeSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AttributeSet',
                                 pretty_print=pretty_print)
        if self.CytogeneticLocation is not None:
            namespaceprefix_ = self.CytogeneticLocation_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.CytogeneticLocation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCytogeneticLocation>%s</%sCytogeneticLocation>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.CytogeneticLocation), input_name='CytogeneticLocation')),
                                                                                   namespaceprefix_, eol_))
        for SequenceLocation_ in self.SequenceLocation:
            namespaceprefix_ = self.SequenceLocation_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SequenceLocation_nsprefix_) else ''
            SequenceLocation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SequenceLocation',
                                     pretty_print=pretty_print)
        for MeasureRelationship_ in self.MeasureRelationship:
            namespaceprefix_ = self.MeasureRelationship_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MeasureRelationship_nsprefix_) else ''
            MeasureRelationship_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MeasureRelationship',
                                        pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        if self.Comment is not None:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            self.Comment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MeasureType':
            obj_ = MeasureTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasureType = obj_
            obj_.original_tagname_ = 'MeasureType'
        elif nodeName_ == 'Name':
            obj_ = SetElementSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Symbol':
            obj_ = SetElementSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Symbol.append(obj_)
            obj_.original_tagname_ = 'Symbol'
        elif nodeName_ == 'AttributeSet':
            obj_ = AttributeSetType5.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'CytogeneticLocation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CytogeneticLocation')
            value_ = self.gds_validate_string(value_, node, 'CytogeneticLocation')
            self.CytogeneticLocation = value_
            self.CytogeneticLocation_nsprefix_ = child_.prefix
        elif nodeName_ == 'SequenceLocation':
            obj_ = SequenceLocationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SequenceLocation.append(obj_)
            obj_.original_tagname_ = 'SequenceLocation'
        elif nodeName_ == 'MeasureRelationship':
            obj_ = MeasureRelationshipType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasureRelationship.append(obj_)
            obj_.original_tagname_ = 'MeasureRelationship'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'


# end class MeasureType


class MeasureTypeType(GeneratedsSuper):
    """The name or id of measure_type in
    clinvar"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureTypeType.subclass:
            return MeasureTypeType.subclass(*args_, **kwargs_)
        else:
            return MeasureTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureTypeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasureTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeasureTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeasureTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MeasureTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class MeasureTypeType


class AttributeSetType5(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, MeasureAttributeType=None, Attribute=None, Citation=None, XRef=None, Comment=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MeasureAttributeType = MeasureAttributeType
        self.MeasureAttributeType_nsprefix_ = None
        self.Attribute = Attribute
        self.Attribute_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeSetType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeSetType5.subclass:
            return AttributeSetType5.subclass(*args_, **kwargs_)
        else:
            return AttributeSetType5(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MeasureAttributeType(self):
        return self.MeasureAttributeType

    def set_MeasureAttributeType(self, MeasureAttributeType):
        self.MeasureAttributeType = MeasureAttributeType

    def get_Attribute(self):
        return self.Attribute

    def set_Attribute(self, Attribute):
        self.Attribute = Attribute

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def hasContent_(self):
        if (
                self.MeasureAttributeType is not None or
                self.Attribute is not None or
                self.Citation or
                self.XRef or
                self.Comment is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeSetType5',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AttributeSetType5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AttributeSetType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AttributeSetType5',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AttributeSetType5'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeSetType5',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeasureAttributeType is not None:
            namespaceprefix_ = self.MeasureAttributeType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MeasureAttributeType_nsprefix_) else ''
            self.MeasureAttributeType.export(outfile, level, namespaceprefix_, namespacedef_='',
                                             name_='MeasureAttributeType', pretty_print=pretty_print)
        if self.Attribute is not None:
            namespaceprefix_ = self.Attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.Attribute_nsprefix_) else ''
            self.Attribute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Attribute',
                                  pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        if self.Comment is not None:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            self.Comment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MeasureAttributeType':
            obj_ = MeasureAttributeTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasureAttributeType = obj_
            obj_.original_tagname_ = 'MeasureAttributeType'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'


# end class AttributeSetType5


class MeasureAttributeTypeType(GeneratedsSuper):
    """The name or id of measure_attr_type in
    clinvar"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureAttributeTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureAttributeTypeType.subclass:
            return MeasureAttributeTypeType.subclass(*args_, **kwargs_)
        else:
            return MeasureAttributeTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureAttributeTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasureAttributeTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeasureAttributeTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeasureAttributeTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='MeasureAttributeTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureAttributeTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class MeasureAttributeTypeType


class MeasureRelationshipType(GeneratedsSuper):
    """MeasureRelationship is used to represent
    relationships to genes or other objects."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, id=None, ncbi_id=None, id_status=None, uid=None, MeasureRelationshipType_member=None, Name=None,
                 Symbol=None, AttributeSet=None, Citation=None, XRef=None, Comment=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.MeasureRelationshipType = MeasureRelationshipType_member
        self.MeasureRelationshipType_nsprefix_ = None
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        self.Name_nsprefix_ = None
        if Symbol is None:
            self.Symbol = []
        else:
            self.Symbol = Symbol
        self.Symbol_nsprefix_ = None
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        self.AttributeSet_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureRelationshipType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureRelationshipType.subclass:
            return MeasureRelationshipType.subclass(*args_, **kwargs_)
        else:
            return MeasureRelationshipType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MeasureRelationshipType(self):
        return self.MeasureRelationshipType

    def set_MeasureRelationshipType(self, MeasureRelationshipType):
        self.MeasureRelationshipType = MeasureRelationshipType

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def add_Name(self, value):
        self.Name.append(value)

    def insert_Name_at(self, index, value):
        self.Name.insert(index, value)

    def replace_Name_at(self, index, value):
        self.Name[index] = value

    def get_Symbol(self):
        return self.Symbol

    def set_Symbol(self, Symbol):
        self.Symbol = Symbol

    def add_Symbol(self, value):
        self.Symbol.append(value)

    def insert_Symbol_at(self, index, value):
        self.Symbol.insert(index, value)

    def replace_Symbol_at(self, index, value):
        self.Symbol[index] = value

    def get_AttributeSet(self):
        return self.AttributeSet

    def set_AttributeSet(self, AttributeSet):
        self.AttributeSet = AttributeSet

    def add_AttributeSet(self, value):
        self.AttributeSet.append(value)

    def insert_AttributeSet_at(self, index, value):
        self.AttributeSet.insert(index, value)

    def replace_AttributeSet_at(self, index, value):
        self.AttributeSet[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def add_Comment(self, value):
        self.Comment.append(value)

    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)

    def replace_Comment_at(self, index, value):
        self.Comment[index] = value

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.MeasureRelationshipType is not None or
                self.Name or
                self.Symbol or
                self.AttributeSet or
                self.Citation or
                self.XRef or
                self.Comment
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureRelationshipType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasureRelationshipType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeasureRelationshipType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeasureRelationshipType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MeasureRelationshipType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureRelationshipType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeasureRelationshipType is not None:
            namespaceprefix_ = self.MeasureRelationshipType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MeasureRelationshipType_nsprefix_) else ''
            self.MeasureRelationshipType.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                name_='MeasureRelationshipType', pretty_print=pretty_print)
        for Name_ in self.Name:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            Name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        for Symbol_ in self.Symbol:
            namespaceprefix_ = self.Symbol_nsprefix_ + ':' if (UseCapturedNS_ and self.Symbol_nsprefix_) else ''
            Symbol_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Symbol',
                           pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            namespaceprefix_ = self.AttributeSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AttributeSet_nsprefix_) else ''
            AttributeSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AttributeSet',
                                 pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            Comment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                            pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MeasureRelationshipType':
            obj_ = MeasureRelationshipTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasureRelationshipType = obj_
            obj_.original_tagname_ = 'MeasureRelationshipType'
        elif nodeName_ == 'Name':
            obj_ = SetElementSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Symbol':
            obj_ = SetElementSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Symbol.append(obj_)
            obj_.original_tagname_ = 'Symbol'
        elif nodeName_ == 'AttributeSet':
            obj_ = AttributeSetType6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'


# end class MeasureRelationshipType


class MeasureRelationshipTypeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureRelationshipTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureRelationshipTypeType.subclass:
            return MeasureRelationshipTypeType.subclass(*args_, **kwargs_)
        else:
            return MeasureRelationshipTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureRelationshipTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasureRelationshipTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeasureRelationshipTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='MeasureRelationshipTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='MeasureRelationshipTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureRelationshipTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class MeasureRelationshipTypeType


class AttributeSetType6(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, MeasureRelationshipAttributeType=None, Attribute=None, Citation=None, XRef=None, Comment=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MeasureRelationshipAttributeType = MeasureRelationshipAttributeType
        self.MeasureRelationshipAttributeType_nsprefix_ = None
        self.Attribute = Attribute
        self.Attribute_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeSetType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeSetType6.subclass:
            return AttributeSetType6.subclass(*args_, **kwargs_)
        else:
            return AttributeSetType6(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_MeasureRelationshipAttributeType(self):
        return self.MeasureRelationshipAttributeType

    def set_MeasureRelationshipAttributeType(self, MeasureRelationshipAttributeType):
        self.MeasureRelationshipAttributeType = MeasureRelationshipAttributeType

    def get_Attribute(self):
        return self.Attribute

    def set_Attribute(self, Attribute):
        self.Attribute = Attribute

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def add_Comment(self, value):
        self.Comment.append(value)

    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)

    def replace_Comment_at(self, index, value):
        self.Comment[index] = value

    def hasContent_(self):
        if (
                self.MeasureRelationshipAttributeType is not None or
                self.Attribute is not None or
                self.Citation or
                self.XRef or
                self.Comment
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeSetType6',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AttributeSetType6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AttributeSetType6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AttributeSetType6',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AttributeSetType6'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeSetType6',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeasureRelationshipAttributeType is not None:
            namespaceprefix_ = self.MeasureRelationshipAttributeType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.MeasureRelationshipAttributeType_nsprefix_) else ''
            self.MeasureRelationshipAttributeType.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                         name_='MeasureRelationshipAttributeType',
                                                         pretty_print=pretty_print)
        if self.Attribute is not None:
            namespaceprefix_ = self.Attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.Attribute_nsprefix_) else ''
            self.Attribute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Attribute',
                                  pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            Comment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                            pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MeasureRelationshipAttributeType':
            obj_ = MeasureRelationshipAttributeTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeasureRelationshipAttributeType = obj_
            obj_.original_tagname_ = 'MeasureRelationshipAttributeType'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'


# end class AttributeSetType6


class MeasureRelationshipAttributeTypeType(GeneratedsSuper):
    """The name or id of
    measure_attr_type in clinvar"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureRelationshipAttributeTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureRelationshipAttributeTypeType.subclass:
            return MeasureRelationshipAttributeTypeType.subclass(*args_, **kwargs_)
        else:
            return MeasureRelationshipAttributeTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='',
               name_='MeasureRelationshipAttributeTypeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasureRelationshipAttributeTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='MeasureRelationshipAttributeTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='MeasureRelationshipAttributeTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='MeasureRelationshipAttributeTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='MeasureRelationshipAttributeTypeType', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class MeasureRelationshipAttributeTypeType


class MeasureSetAttributeTypeType(GeneratedsSuper):
    """The name or id of measure_set_attr_type in
    clinvar"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasureSetAttributeTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasureSetAttributeTypeType.subclass:
            return MeasureSetAttributeTypeType.subclass(*args_, **kwargs_)
        else:
            return MeasureSetAttributeTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureSetAttributeTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasureSetAttributeTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeasureSetAttributeTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='MeasureSetAttributeTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='MeasureSetAttributeTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeasureSetAttributeTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class MeasureSetAttributeTypeType


class TraitSetTypeType(GeneratedsSuper):
    """The name or id of trait_set_type in clinvar"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TraitSetTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TraitSetTypeType.subclass:
            return TraitSetTypeType.subclass(*args_, **kwargs_)
        else:
            return TraitSetTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitSetTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TraitSetTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TraitSetTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TraitSetTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TraitSetTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitSetTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class TraitSetTypeType


class TraitSetTypeType7(GeneratedsSuper):
    """The name or id of trait_set_type in clinvar"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TraitSetTypeType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TraitSetTypeType7.subclass:
            return TraitSetTypeType7.subclass(*args_, **kwargs_)
        else:
            return TraitSetTypeType7(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitSetTypeType7',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TraitSetTypeType7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TraitSetTypeType7')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TraitSetTypeType7',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TraitSetTypeType7'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitSetTypeType7',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class TraitSetTypeType7


class TraitSetAttributeTypeType(GeneratedsSuper):
    """The name or id of tset_attr_type in clinvar"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TraitSetAttributeTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TraitSetAttributeTypeType.subclass:
            return TraitSetAttributeTypeType.subclass(*args_, **kwargs_)
        else:
            return TraitSetAttributeTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitSetAttributeTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TraitSetAttributeTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TraitSetAttributeTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TraitSetAttributeTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='TraitSetAttributeTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitSetAttributeTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class TraitSetAttributeTypeType


class TraitTypeType(GeneratedsSuper):
    """The name or id of trait_type in clinvar"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TraitTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TraitTypeType.subclass:
            return TraitTypeType.subclass(*args_, **kwargs_)
        else:
            return TraitTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitTypeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TraitTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TraitTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TraitTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TraitTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class TraitTypeType


class AttributeSetType8(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, TraitAttributeType=None, Attribute=None, Citation=None, XRef=None, Comment=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TraitAttributeType = TraitAttributeType
        self.TraitAttributeType_nsprefix_ = None
        self.Attribute = Attribute
        self.Attribute_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeSetType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeSetType8.subclass:
            return AttributeSetType8.subclass(*args_, **kwargs_)
        else:
            return AttributeSetType8(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_TraitAttributeType(self):
        return self.TraitAttributeType

    def set_TraitAttributeType(self, TraitAttributeType):
        self.TraitAttributeType = TraitAttributeType

    def get_Attribute(self):
        return self.Attribute

    def set_Attribute(self, Attribute):
        self.Attribute = Attribute

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def add_Comment(self, value):
        self.Comment.append(value)

    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)

    def replace_Comment_at(self, index, value):
        self.Comment[index] = value

    def hasContent_(self):
        if (
                self.TraitAttributeType is not None or
                self.Attribute is not None or
                self.Citation or
                self.XRef or
                self.Comment
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeSetType8',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AttributeSetType8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AttributeSetType8')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AttributeSetType8',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AttributeSetType8'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeSetType8',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TraitAttributeType is not None:
            namespaceprefix_ = self.TraitAttributeType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TraitAttributeType_nsprefix_) else ''
            self.TraitAttributeType.export(outfile, level, namespaceprefix_, namespacedef_='',
                                           name_='TraitAttributeType', pretty_print=pretty_print)
        if self.Attribute is not None:
            namespaceprefix_ = self.Attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.Attribute_nsprefix_) else ''
            self.Attribute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Attribute',
                                  pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            Comment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                            pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TraitAttributeType':
            obj_ = TraitAttributeTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TraitAttributeType = obj_
            obj_.original_tagname_ = 'TraitAttributeType'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'


# end class AttributeSetType8


class TraitAttributeTypeType(GeneratedsSuper):
    """The name or id of trait_attr_type in
    clinvar"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TraitAttributeTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TraitAttributeTypeType.subclass:
            return TraitAttributeTypeType.subclass(*args_, **kwargs_)
        else:
            return TraitAttributeTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitAttributeTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TraitAttributeTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TraitAttributeTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TraitAttributeTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TraitAttributeTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitAttributeTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class TraitAttributeTypeType


class TraitRelationshipType(GeneratedsSuper):
    """TraitRelationship is used to represent relationships among
    traits. In the relational model, this is captured in the tset and tsubset
    tables. The type of relationship is captured in TraitRelationshipType."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, id=None, ncbi_id=None, id_status=None, uid=None, TraitRelationshipType_member=None, Name=None,
                 Symbol=None, AttributeSet=None, Citation=None, XRef=None, Comment=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.TraitRelationshipType = TraitRelationshipType_member
        self.TraitRelationshipType_nsprefix_ = None
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        self.Name_nsprefix_ = None
        if Symbol is None:
            self.Symbol = []
        else:
            self.Symbol = Symbol
        self.Symbol_nsprefix_ = None
        if AttributeSet is None:
            self.AttributeSet = []
        else:
            self.AttributeSet = AttributeSet
        self.AttributeSet_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TraitRelationshipType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TraitRelationshipType.subclass:
            return TraitRelationshipType.subclass(*args_, **kwargs_)
        else:
            return TraitRelationshipType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_TraitRelationshipType(self):
        return self.TraitRelationshipType

    def set_TraitRelationshipType(self, TraitRelationshipType):
        self.TraitRelationshipType = TraitRelationshipType

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def add_Name(self, value):
        self.Name.append(value)

    def insert_Name_at(self, index, value):
        self.Name.insert(index, value)

    def replace_Name_at(self, index, value):
        self.Name[index] = value

    def get_Symbol(self):
        return self.Symbol

    def set_Symbol(self, Symbol):
        self.Symbol = Symbol

    def add_Symbol(self, value):
        self.Symbol.append(value)

    def insert_Symbol_at(self, index, value):
        self.Symbol.insert(index, value)

    def replace_Symbol_at(self, index, value):
        self.Symbol[index] = value

    def get_AttributeSet(self):
        return self.AttributeSet

    def set_AttributeSet(self, AttributeSet):
        self.AttributeSet = AttributeSet

    def add_AttributeSet(self, value):
        self.AttributeSet.append(value)

    def insert_AttributeSet_at(self, index, value):
        self.AttributeSet.insert(index, value)

    def replace_AttributeSet_at(self, index, value):
        self.AttributeSet[index] = value

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                self.TraitRelationshipType is not None or
                self.Name or
                self.Symbol or
                self.AttributeSet or
                self.Citation or
                self.XRef or
                self.Comment is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitRelationshipType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TraitRelationshipType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TraitRelationshipType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TraitRelationshipType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TraitRelationshipType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitRelationshipType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TraitRelationshipType is not None:
            namespaceprefix_ = self.TraitRelationshipType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TraitRelationshipType_nsprefix_) else ''
            self.TraitRelationshipType.export(outfile, level, namespaceprefix_, namespacedef_='',
                                              name_='TraitRelationshipType', pretty_print=pretty_print)
        for Name_ in self.Name:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            Name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name', pretty_print=pretty_print)
        for Symbol_ in self.Symbol:
            namespaceprefix_ = self.Symbol_nsprefix_ + ':' if (UseCapturedNS_ and self.Symbol_nsprefix_) else ''
            Symbol_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Symbol',
                           pretty_print=pretty_print)
        for AttributeSet_ in self.AttributeSet:
            namespaceprefix_ = self.AttributeSet_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AttributeSet_nsprefix_) else ''
            AttributeSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AttributeSet',
                                 pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        if self.Comment is not None:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            self.Comment.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                                pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TraitRelationshipType':
            obj_ = TraitRelationshipTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TraitRelationshipType = obj_
            obj_.original_tagname_ = 'TraitRelationshipType'
        elif nodeName_ == 'Name':
            obj_ = SetElementSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Symbol':
            obj_ = SetElementSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Symbol.append(obj_)
            obj_.original_tagname_ = 'Symbol'
        elif nodeName_ == 'AttributeSet':
            obj_ = AttributeSetType9.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AttributeSet.append(obj_)
            obj_.original_tagname_ = 'AttributeSet'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'


# end class TraitRelationshipType


class TraitRelationshipTypeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TraitRelationshipTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TraitRelationshipTypeType.subclass:
            return TraitRelationshipTypeType.subclass(*args_, **kwargs_)
        else:
            return TraitRelationshipTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitRelationshipTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TraitRelationshipTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TraitRelationshipTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TraitRelationshipTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='TraitRelationshipTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitRelationshipTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class TraitRelationshipTypeType


class AttributeSetType9(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, TraitRelationshipAttributeType=None, Attribute=None, Citation=None, XRef=None, Comment=None,
                 gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TraitRelationshipAttributeType = TraitRelationshipAttributeType
        self.TraitRelationshipAttributeType_nsprefix_ = None
        self.Attribute = Attribute
        self.Attribute_nsprefix_ = None
        if Citation is None:
            self.Citation = []
        else:
            self.Citation = Citation
        self.Citation_nsprefix_ = None
        if XRef is None:
            self.XRef = []
        else:
            self.XRef = XRef
        self.XRef_nsprefix_ = None
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Comment_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeSetType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeSetType9.subclass:
            return AttributeSetType9.subclass(*args_, **kwargs_)
        else:
            return AttributeSetType9(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_TraitRelationshipAttributeType(self):
        return self.TraitRelationshipAttributeType

    def set_TraitRelationshipAttributeType(self, TraitRelationshipAttributeType):
        self.TraitRelationshipAttributeType = TraitRelationshipAttributeType

    def get_Attribute(self):
        return self.Attribute

    def set_Attribute(self, Attribute):
        self.Attribute = Attribute

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def add_Citation(self, value):
        self.Citation.append(value)

    def insert_Citation_at(self, index, value):
        self.Citation.insert(index, value)

    def replace_Citation_at(self, index, value):
        self.Citation[index] = value

    def get_XRef(self):
        return self.XRef

    def set_XRef(self, XRef):
        self.XRef = XRef

    def add_XRef(self, value):
        self.XRef.append(value)

    def insert_XRef_at(self, index, value):
        self.XRef.insert(index, value)

    def replace_XRef_at(self, index, value):
        self.XRef[index] = value

    def get_Comment(self):
        return self.Comment

    def set_Comment(self, Comment):
        self.Comment = Comment

    def add_Comment(self, value):
        self.Comment.append(value)

    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)

    def replace_Comment_at(self, index, value):
        self.Comment[index] = value

    def hasContent_(self):
        if (
                self.TraitRelationshipAttributeType is not None or
                self.Attribute is not None or
                self.Citation or
                self.XRef or
                self.Comment
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeSetType9',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AttributeSetType9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AttributeSetType9')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AttributeSetType9',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AttributeSetType9'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeSetType9',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TraitRelationshipAttributeType is not None:
            namespaceprefix_ = self.TraitRelationshipAttributeType_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.TraitRelationshipAttributeType_nsprefix_) else ''
            self.TraitRelationshipAttributeType.export(outfile, level, namespaceprefix_, namespacedef_='',
                                                       name_='TraitRelationshipAttributeType',
                                                       pretty_print=pretty_print)
        if self.Attribute is not None:
            namespaceprefix_ = self.Attribute_nsprefix_ + ':' if (UseCapturedNS_ and self.Attribute_nsprefix_) else ''
            self.Attribute.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Attribute',
                                  pretty_print=pretty_print)
        for Citation_ in self.Citation:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            Citation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                             pretty_print=pretty_print)
        for XRef_ in self.XRef:
            namespaceprefix_ = self.XRef_nsprefix_ + ':' if (UseCapturedNS_ and self.XRef_nsprefix_) else ''
            XRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XRef', pretty_print=pretty_print)
        for Comment_ in self.Comment:
            namespaceprefix_ = self.Comment_nsprefix_ + ':' if (UseCapturedNS_ and self.Comment_nsprefix_) else ''
            Comment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comment',
                            pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TraitRelationshipAttributeType':
            obj_ = TraitRelationshipAttributeTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TraitRelationshipAttributeType = obj_
            obj_.original_tagname_ = 'TraitRelationshipAttributeType'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation.append(obj_)
            obj_.original_tagname_ = 'Citation'
        elif nodeName_ == 'XRef':
            obj_ = XrefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XRef.append(obj_)
            obj_.original_tagname_ = 'XRef'
        elif nodeName_ == 'Comment':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'


# end class AttributeSetType9


class TraitRelationshipAttributeTypeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TraitRelationshipAttributeTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TraitRelationshipAttributeTypeType.subclass:
            return TraitRelationshipAttributeTypeType.subclass(*args_, **kwargs_)
        else:
            return TraitRelationshipAttributeTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TraitRelationshipAttributeTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TraitRelationshipAttributeTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_,
                              name_='TraitRelationshipAttributeTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_,
                                name_='TraitRelationshipAttributeTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='',
                         name_='TraitRelationshipAttributeTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='',
                       name_='TraitRelationshipAttributeTypeType', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class TraitRelationshipAttributeTypeType


class SampleDescriptionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Description=None, Citation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Description = Description
        self.Description_nsprefix_ = None
        self.Citation = Citation
        self.Citation_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SampleDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SampleDescriptionType.subclass:
            return SampleDescriptionType.subclass(*args_, **kwargs_)
        else:
            return SampleDescriptionType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Description(self):
        return self.Description

    def set_Description(self, Description):
        self.Description = Description

    def get_Citation(self):
        return self.Citation

    def set_Citation(self, Citation):
        self.Citation = Citation

    def hasContent_(self):
        if (
                self.Description is not None or
                self.Citation is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SampleDescriptionType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SampleDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SampleDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SampleDescriptionType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SampleDescriptionType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SampleDescriptionType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            namespaceprefix_ = self.Description_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.Description_nsprefix_) else ''
            self.Description.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Description',
                                    pretty_print=pretty_print)
        if self.Citation is not None:
            namespaceprefix_ = self.Citation_nsprefix_ + ':' if (UseCapturedNS_ and self.Citation_nsprefix_) else ''
            self.Citation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Citation',
                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Description':
            obj_ = CommentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Citation':
            obj_ = CitationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Citation = obj_
            obj_.original_tagname_ = 'Citation'


# end class SampleDescriptionType


class SpeciesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, TaxonomyId=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TaxonomyId = _cast(int, TaxonomyId)
        self.TaxonomyId_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpeciesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpeciesType.subclass:
            return SpeciesType.subclass(*args_, **kwargs_)
        else:
            return SpeciesType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_TaxonomyId(self):
        return self.TaxonomyId

    def set_TaxonomyId(self, TaxonomyId):
        self.TaxonomyId = TaxonomyId

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpeciesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpeciesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpeciesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpeciesType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpeciesType'):
        if self.TaxonomyId is not None and 'TaxonomyId' not in already_processed:
            already_processed.add('TaxonomyId')
            outfile.write(' TaxonomyId="%s"' % self.gds_format_integer(self.TaxonomyId, input_name='TaxonomyId'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpeciesType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TaxonomyId', node)
        if value is not None and 'TaxonomyId' not in already_processed:
            already_processed.add('TaxonomyId')
            self.TaxonomyId = self.gds_parse_integer(value, node, 'TaxonomyId')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class SpeciesType


class AgeType(GeneratedsSuper):
    """Age can be a single value or a range, defined by the use of
    type."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, age_unit=None, type_=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.age_unit = _cast(None, age_unit)
        self.age_unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgeType.subclass:
            return AgeType.subclass(*args_, **kwargs_)
        else:
            return AgeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_age_unit(self):
        return self.age_unit

    def set_age_unit(self, age_unit):
        self.age_unit = age_unit

    def get_type(self):
        return self.type_

    def set_type(self, type_):
        self.type_ = type_

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AgeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AgeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AgeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AgeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AgeType'):
        if self.age_unit is not None and 'age_unit' not in already_processed:
            already_processed.add('age_unit')
            outfile.write(' age_unit=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.age_unit), input_name='age_unit')),))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(
                ' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AgeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('age_unit', node)
        if value is not None and 'age_unit' not in already_processed:
            already_processed.add('age_unit')
            self.age_unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class AgeType


class GenotypeSetTypeType(GeneratedsSuper):
    """The name or id of measureset_type in
    clinvar"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, val_type=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.val_type = _cast(None, val_type)
        self.val_type_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenotypeSetTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenotypeSetTypeType.subclass:
            return GenotypeSetTypeType.subclass(*args_, **kwargs_)
        else:
            return GenotypeSetTypeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_val_type(self):
        return self.val_type

    def set_val_type(self, val_type):
        self.val_type = val_type

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_typeIdName(self, value):
        # Validate type typeIdName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['id', 'name']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIdName' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GenotypeSetTypeType',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenotypeSetTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenotypeSetTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GenotypeSetTypeType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GenotypeSetTypeType'):
        if self.val_type is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            outfile.write(' val_type=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.val_type), input_name='val_type')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GenotypeSetTypeType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('val_type', node)
        if value is not None and 'val_type' not in already_processed:
            already_processed.add('val_type')
            self.val_type = value
            self.validate_typeIdName(self.val_type)  # validate type typeIdName

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class GenotypeSetTypeType


class PersonType10(GeneratedsSuper):
    """The person submitting the data. Internally, represented in the
    entered_by fields."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, PersonID=None, Name=None, SubmitterHandle=None, AccountInfo=None, gds_collector_=None,
                 **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.PersonID = _cast(int, PersonID)
        self.PersonID_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.SubmitterHandle = SubmitterHandle
        self.SubmitterHandle_nsprefix_ = None
        self.AccountInfo = AccountInfo
        self.AccountInfo_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PersonType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PersonType10.subclass:
            return PersonType10.subclass(*args_, **kwargs_)
        else:
            return PersonType10(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_SubmitterHandle(self):
        return self.SubmitterHandle

    def set_SubmitterHandle(self, SubmitterHandle):
        self.SubmitterHandle = SubmitterHandle

    def get_AccountInfo(self):
        return self.AccountInfo

    def set_AccountInfo(self, AccountInfo):
        self.AccountInfo = AccountInfo

    def get_PersonID(self):
        return self.PersonID

    def set_PersonID(self, PersonID):
        self.PersonID = PersonID

    def hasContent_(self):
        if (
                self.Name is not None or
                self.SubmitterHandle is not None or
                self.AccountInfo is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PersonType10', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PersonType10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PersonType10')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PersonType10',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PersonType10'):
        if self.PersonID is not None and 'PersonID' not in already_processed:
            already_processed.add('PersonID')
            outfile.write(' PersonID="%s"' % self.gds_format_integer(self.PersonID, input_name='PersonID'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PersonType10',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            self.Name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Name',
                             pretty_print=pretty_print)
        if self.SubmitterHandle is not None:
            namespaceprefix_ = self.SubmitterHandle_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SubmitterHandle_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubmitterHandle>%s</%sSubmitterHandle>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.SubmitterHandle), input_name='SubmitterHandle')),
                                                                           namespaceprefix_, eol_))
        if self.AccountInfo is not None:
            namespaceprefix_ = self.AccountInfo_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.AccountInfo_nsprefix_) else ''
            self.AccountInfo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AccountInfo',
                                    pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('PersonID', node)
        if value is not None and 'PersonID' not in already_processed:
            already_processed.add('PersonID')
            self.PersonID = self.gds_parse_integer(value, node, 'PersonID')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Name':
            obj_ = NameType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'SubmitterHandle':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SubmitterHandle')
            value_ = self.gds_validate_string(value_, node, 'SubmitterHandle')
            self.SubmitterHandle = value_
            self.SubmitterHandle_nsprefix_ = child_.prefix
        elif nodeName_ == 'AccountInfo':
            obj_ = typeAccount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AccountInfo = obj_
            obj_.original_tagname_ = 'AccountInfo'


# end class PersonType10


class NameType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, First=None, Last=None, Middle=None, Suffix=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.First = First
        self.First_nsprefix_ = None
        self.Last = Last
        self.Last_nsprefix_ = None
        self.Middle = Middle
        self.Middle_nsprefix_ = None
        self.Suffix = Suffix
        self.Suffix_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameType.subclass:
            return NameType.subclass(*args_, **kwargs_)
        else:
            return NameType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_First(self):
        return self.First

    def set_First(self, First):
        self.First = First

    def get_Last(self):
        return self.Last

    def set_Last(self, Last):
        self.Last = Last

    def get_Middle(self):
        return self.Middle

    def set_Middle(self, Middle):
        self.Middle = Middle

    def get_Suffix(self):
        return self.Suffix

    def set_Suffix(self, Suffix):
        self.Suffix = Suffix

    def hasContent_(self):
        if (
                self.First is not None or
                self.Last is not None or
                self.Middle is not None or
                self.Suffix is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NameType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NameType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NameType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NameType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NameType',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.First is not None:
            namespaceprefix_ = self.First_nsprefix_ + ':' if (UseCapturedNS_ and self.First_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFirst>%s</%sFirst>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.First), input_name='First')),
            namespaceprefix_, eol_))
        if self.Last is not None:
            namespaceprefix_ = self.Last_nsprefix_ + ':' if (UseCapturedNS_ and self.Last_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLast>%s</%sLast>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Last), input_name='Last')),
            namespaceprefix_, eol_))
        if self.Middle is not None:
            namespaceprefix_ = self.Middle_nsprefix_ + ':' if (UseCapturedNS_ and self.Middle_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMiddle>%s</%sMiddle>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Middle), input_name='Middle')),
            namespaceprefix_, eol_))
        if self.Suffix is not None:
            namespaceprefix_ = self.Suffix_nsprefix_ + ':' if (UseCapturedNS_ and self.Suffix_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSuffix>%s</%sSuffix>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Suffix), input_name='Suffix')),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'First':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'First')
            value_ = self.gds_validate_string(value_, node, 'First')
            self.First = value_
            self.First_nsprefix_ = child_.prefix
        elif nodeName_ == 'Last':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Last')
            value_ = self.gds_validate_string(value_, node, 'Last')
            self.Last = value_
            self.Last_nsprefix_ = child_.prefix
        elif nodeName_ == 'Middle':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Middle')
            value_ = self.gds_validate_string(value_, node, 'Middle')
            self.Middle = value_
            self.Middle_nsprefix_ = child_.prefix
        elif nodeName_ == 'Suffix':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Suffix')
            value_ = self.gds_validate_string(value_, node, 'Suffix')
            self.Suffix = value_
            self.Suffix_nsprefix_ = child_.prefix


# end class NameType


class OrganizationType11(GeneratedsSuper):
    """Need to be able to identify the organization or extrn_src for
    who is making this assertion"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Name=None, Institution=None, Department=None, SubmitterHandle=None, OrganizationCategory='lab',
                 NCBIOrganizationID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Institution = Institution
        self.Institution_nsprefix_ = None
        self.Department = Department
        self.Department_nsprefix_ = None
        self.SubmitterHandle = SubmitterHandle
        self.SubmitterHandle_nsprefix_ = None
        self.OrganizationCategory = OrganizationCategory
        self.validate_OrganizationCategoryList(self.OrganizationCategory)
        self.OrganizationCategory_nsprefix_ = None
        self.NCBIOrganizationID = NCBIOrganizationID
        self.NCBIOrganizationID_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganizationType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganizationType11.subclass:
            return OrganizationType11.subclass(*args_, **kwargs_)
        else:
            return OrganizationType11(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_Institution(self):
        return self.Institution

    def set_Institution(self, Institution):
        self.Institution = Institution

    def get_Department(self):
        return self.Department

    def set_Department(self, Department):
        self.Department = Department

    def get_SubmitterHandle(self):
        return self.SubmitterHandle

    def set_SubmitterHandle(self, SubmitterHandle):
        self.SubmitterHandle = SubmitterHandle

    def get_OrganizationCategory(self):
        return self.OrganizationCategory

    def set_OrganizationCategory(self, OrganizationCategory):
        self.OrganizationCategory = OrganizationCategory

    def get_NCBIOrganizationID(self):
        return self.NCBIOrganizationID

    def set_NCBIOrganizationID(self, NCBIOrganizationID):
        self.NCBIOrganizationID = NCBIOrganizationID

    def validate_OrganizationCategoryList(self, value):
        result = True
        # Validate type OrganizationCategoryList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['lab', 'LSDB', 'clinic', 'resource', 'consortium', 'patient registry', 'other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OrganizationCategoryList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False
        return result

    def hasContent_(self):
        if (
                self.Name is not None or
                self.Institution is not None or
                self.Department is not None or
                self.SubmitterHandle is not None or
                self.OrganizationCategory != "lab" or
                self.NCBIOrganizationID is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OrganizationType11',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrganizationType11')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrganizationType11')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OrganizationType11',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OrganizationType11'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OrganizationType11',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')),
            namespaceprefix_, eol_))
        if self.Institution is not None:
            namespaceprefix_ = self.Institution_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.Institution_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstitution>%s</%sInstitution>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.Institution), input_name='Institution')), namespaceprefix_, eol_))
        if self.Department is not None:
            namespaceprefix_ = self.Department_nsprefix_ + ':' if (UseCapturedNS_ and self.Department_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDepartment>%s</%sDepartment>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.Department), input_name='Department')), namespaceprefix_, eol_))
        if self.SubmitterHandle is not None:
            namespaceprefix_ = self.SubmitterHandle_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.SubmitterHandle_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubmitterHandle>%s</%sSubmitterHandle>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.SubmitterHandle), input_name='SubmitterHandle')),
                                                                           namespaceprefix_, eol_))
        if self.OrganizationCategory is not None:
            namespaceprefix_ = self.OrganizationCategory_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.OrganizationCategory_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganizationCategory>%s</%sOrganizationCategory>%s' % (namespaceprefix_, self.gds_encode(
                self.gds_format_string(quote_xml(self.OrganizationCategory), input_name='OrganizationCategory')),
                                                                                     namespaceprefix_, eol_))
        if self.NCBIOrganizationID is not None:
            namespaceprefix_ = self.NCBIOrganizationID_nsprefix_ + ':' if (
                        UseCapturedNS_ and self.NCBIOrganizationID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNCBIOrganizationID>%s</%sNCBIOrganizationID>%s' % (
            namespaceprefix_, self.gds_format_integer(self.NCBIOrganizationID, input_name='NCBIOrganizationID'),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
        elif nodeName_ == 'Institution':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Institution')
            value_ = self.gds_validate_string(value_, node, 'Institution')
            self.Institution = value_
            self.Institution_nsprefix_ = child_.prefix
        elif nodeName_ == 'Department':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Department')
            value_ = self.gds_validate_string(value_, node, 'Department')
            self.Department = value_
            self.Department_nsprefix_ = child_.prefix
        elif nodeName_ == 'SubmitterHandle':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SubmitterHandle')
            value_ = self.gds_validate_string(value_, node, 'SubmitterHandle')
            self.SubmitterHandle = value_
            self.SubmitterHandle_nsprefix_ = child_.prefix
        elif nodeName_ == 'OrganizationCategory':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'OrganizationCategory')
            value_ = self.gds_validate_string(value_, node, 'OrganizationCategory')
            self.OrganizationCategory = value_
            self.OrganizationCategory_nsprefix_ = child_.prefix
            # validate type OrganizationCategoryList
            self.validate_OrganizationCategoryList(self.OrganizationCategory)
        elif nodeName_ == 'NCBIOrganizationID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'NCBIOrganizationID')
            ival_ = self.gds_validate_integer(ival_, node, 'NCBIOrganizationID')
            self.NCBIOrganizationID = ival_
            self.NCBIOrganizationID_nsprefix_ = child_.prefix


# end class OrganizationType11


class InstitutionType(GeneratedsSuper):
    """Not required, name may be sufficient for
    some organizations. To be used if an organization is part of a larger
    institution."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, cv_id=0, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.cv_id = _cast(int, cv_id)
        self.cv_id_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstitutionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstitutionType.subclass:
            return InstitutionType.subclass(*args_, **kwargs_)
        else:
            return InstitutionType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_cv_id(self):
        return self.cv_id

    def set_cv_id(self, cv_id):
        self.cv_id = cv_id

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InstitutionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InstitutionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InstitutionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InstitutionType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InstitutionType'):
        if self.cv_id != 0 and 'cv_id' not in already_processed:
            already_processed.add('cv_id')
            outfile.write(' cv_id="%s"' % self.gds_format_integer(self.cv_id, input_name='cv_id'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='InstitutionType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cv_id', node)
        if value is not None and 'cv_id' not in already_processed:
            already_processed.add('cv_id')
            self.cv_id = self.gds_parse_integer(value, node, 'cv_id')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class InstitutionType


class StateType(GeneratedsSuper):
    """List of states is in db."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, id=None, ncbi_id=None, id_status=None, uid=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StateType.subclass:
            return StateType.subclass(*args_, **kwargs_)
        else:
            return StateType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StateType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StateType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StateType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StateType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StateType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class StateType


class CountryType(GeneratedsSuper):
    """List of countries is in db. Needs to be on the
    list."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, id=None, ncbi_id=None, id_status=None, uid=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(int, id)
        self.id_nsprefix_ = None
        self.ncbi_id = _cast(int, ncbi_id)
        self.ncbi_id_nsprefix_ = None
        self.id_status = _cast(None, id_status)
        self.id_status_nsprefix_ = None
        self.uid = _cast(None, uid)
        self.uid_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CountryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CountryType.subclass:
            return CountryType.subclass(*args_, **kwargs_)
        else:
            return CountryType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    def get_ncbi_id(self):
        return self.ncbi_id

    def set_ncbi_id(self, ncbi_id):
        self.ncbi_id = ncbi_id

    def get_id_status(self):
        return self.id_status

    def set_id_status(self, id_status):
        self.id_status = id_status

    def get_uid(self):
        return self.uid

    def set_uid(self, uid):
        self.uid = uid

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def validate_StatusTypeList(self, value):
        # Validate type StatusTypeList, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value,
                                                                                                  "lineno": lineno, })
                return False
            value = value
            enumerations = ['novel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message(
                    'Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on StatusTypeList' % {
                        "value": encode_str_2_3(value), "lineno": lineno})
                result = False

    def hasContent_(self):
        if (
                (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CountryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CountryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CountryType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CountryType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CountryType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.ncbi_id is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            outfile.write(' ncbi_id="%s"' % self.gds_format_integer(self.ncbi_id, input_name='ncbi_id'))
        if self.id_status is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            outfile.write(' id_status=%s' % (
            self.gds_encode(self.gds_format_string(quote_attrib(self.id_status), input_name='id_status')),))
        if self.uid is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            outfile.write(
                ' uid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uid), input_name='uid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CountryType',
                       fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = self.gds_parse_integer(value, node, 'id')
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ncbi_id', node)
        if value is not None and 'ncbi_id' not in already_processed:
            already_processed.add('ncbi_id')
            self.ncbi_id = self.gds_parse_integer(value, node, 'ncbi_id')
            if self.ncbi_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id_status', node)
        if value is not None and 'id_status' not in already_processed:
            already_processed.add('id_status')
            self.id_status = value
            self.validate_StatusTypeList(self.id_status)  # validate type StatusTypeList
        value = find_attr_value_('uid', node)
        if value is not None and 'uid' not in already_processed:
            already_processed.add('uid')
            self.uid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class CountryType


class NameType12(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, First=None, Last=None, Middle=None, Prefix=None, Suffix=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.First = First
        self.First_nsprefix_ = None
        self.Last = Last
        self.Last_nsprefix_ = None
        self.Middle = Middle
        self.Middle_nsprefix_ = None
        self.Prefix = Prefix
        self.Prefix_nsprefix_ = None
        self.Suffix = Suffix
        self.Suffix_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NameType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameType12.subclass:
            return NameType12.subclass(*args_, **kwargs_)
        else:
            return NameType12(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_First(self):
        return self.First

    def set_First(self, First):
        self.First = First

    def get_Last(self):
        return self.Last

    def set_Last(self, Last):
        self.Last = Last

    def get_Middle(self):
        return self.Middle

    def set_Middle(self, Middle):
        self.Middle = Middle

    def get_Prefix(self):
        return self.Prefix

    def set_Prefix(self, Prefix):
        self.Prefix = Prefix

    def get_Suffix(self):
        return self.Suffix

    def set_Suffix(self, Suffix):
        self.Suffix = Suffix

    def hasContent_(self):
        if (
                self.First is not None or
                self.Last is not None or
                self.Middle is not None or
                self.Prefix is not None or
                self.Suffix is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NameType12', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NameType12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NameType12')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NameType12',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NameType12'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NameType12',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.First is not None:
            namespaceprefix_ = self.First_nsprefix_ + ':' if (UseCapturedNS_ and self.First_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFirst>%s</%sFirst>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.First), input_name='First')),
            namespaceprefix_, eol_))
        if self.Last is not None:
            namespaceprefix_ = self.Last_nsprefix_ + ':' if (UseCapturedNS_ and self.Last_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLast>%s</%sLast>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Last), input_name='Last')),
            namespaceprefix_, eol_))
        if self.Middle is not None:
            namespaceprefix_ = self.Middle_nsprefix_ + ':' if (UseCapturedNS_ and self.Middle_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMiddle>%s</%sMiddle>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Middle), input_name='Middle')),
            namespaceprefix_, eol_))
        if self.Prefix is not None:
            namespaceprefix_ = self.Prefix_nsprefix_ + ':' if (UseCapturedNS_ and self.Prefix_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrefix>%s</%sPrefix>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Prefix), input_name='Prefix')),
            namespaceprefix_, eol_))
        if self.Suffix is not None:
            namespaceprefix_ = self.Suffix_nsprefix_ + ':' if (UseCapturedNS_ and self.Suffix_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSuffix>%s</%sSuffix>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Suffix), input_name='Suffix')),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'First':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'First')
            value_ = self.gds_validate_string(value_, node, 'First')
            self.First = value_
            self.First_nsprefix_ = child_.prefix
        elif nodeName_ == 'Last':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Last')
            value_ = self.gds_validate_string(value_, node, 'Last')
            self.Last = value_
            self.Last_nsprefix_ = child_.prefix
        elif nodeName_ == 'Middle':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Middle')
            value_ = self.gds_validate_string(value_, node, 'Middle')
            self.Middle = value_
            self.Middle_nsprefix_ = child_.prefix
        elif nodeName_ == 'Prefix':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Prefix')
            value_ = self.gds_validate_string(value_, node, 'Prefix')
            self.Prefix = value_
            self.Prefix_nsprefix_ = child_.prefix
        elif nodeName_ == 'Suffix':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Suffix')
            value_ = self.gds_validate_string(value_, node, 'Suffix')
            self.Suffix = value_
            self.Suffix_nsprefix_ = child_.prefix


# end class NameType12


class DegreeType13(DegreeType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DegreeType

    def __init__(self, Name=None, Qualifier=None, Display=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DegreeType13, self).__init__(Name, Qualifier, **kwargs_)
        self.Display = _cast(bool, Display)
        self.Display_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DegreeType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DegreeType13.subclass:
            return DegreeType13.subclass(*args_, **kwargs_)
        else:
            return DegreeType13(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Display(self):
        return self.Display

    def set_Display(self, Display):
        self.Display = Display

    def hasContent_(self):
        if (
                super(DegreeType13, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DegreeType13', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DegreeType13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DegreeType13')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DegreeType13',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DegreeType13'):
        super(DegreeType13, self).exportAttributes(outfile, level, already_processed, namespaceprefix_,
                                                   name_='DegreeType13')
        if self.Display is not None and 'Display' not in already_processed:
            already_processed.add('Display')
            outfile.write(' Display="%s"' % self.gds_format_boolean(self.Display, input_name='Display'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DegreeType13',
                       fromsubclass_=False, pretty_print=True):
        super(DegreeType13, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True,
                                                 pretty_print=pretty_print)

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Display', node)
        if value is not None and 'Display' not in already_processed:
            already_processed.add('Display')
            if value in ('true', '1'):
                self.Display = True
            elif value in ('false', '0'):
                self.Display = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(DegreeType13, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DegreeType13, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class DegreeType13


class CredentialType14(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Display=None, Name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.Display = _cast(bool, Display)
        self.Display_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CredentialType14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CredentialType14.subclass:
            return CredentialType14.subclass(*args_, **kwargs_)
        else:
            return CredentialType14(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    def get_Display(self):
        return self.Display

    def set_Display(self, Display):
        self.Display = Display

    def hasContent_(self):
        if (
                self.Name is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CredentialType14',
               pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CredentialType14')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CredentialType14')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CredentialType14',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CredentialType14'):
        if self.Display is not None and 'Display' not in already_processed:
            already_processed.add('Display')
            outfile.write(' Display="%s"' % self.gds_format_boolean(self.Display, input_name='Display'))

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CredentialType14',
                       fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            namespaceprefix_ = self.Name_nsprefix_ + ':' if (UseCapturedNS_ and self.Name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (
            namespaceprefix_, self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')),
            namespaceprefix_, eol_))

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Display', node)
        if value is not None and 'Display' not in already_processed:
            already_processed.add('Display')
            if value in ('true', '1'):
                self.Display = True
            elif value in ('false', '0'):
                self.Display = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'Name')
            value_ = self.gds_validate_string(value_, node, 'Name')
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix


# end class CredentialType14


class Name(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Name)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Name.subclass:
            return Name.subclass(*args_, **kwargs_)
        else:
            return Name(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Name', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Name')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Name')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Name',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Name'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Name', fromsubclass_=False,
                       pretty_print=True):
        pass

    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass


# end class Name


GDSClassesMapping = {
    'ClinvarSubmissionSet': SubmissionSetType,
}

USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for prefix, uri in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'typeContactInfo'
        rootClass = typeContactInfo
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'typeContactInfo'
        rootClass = typeContactInfo
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode = parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'typeContactInfo'
        rootClass = typeContactInfo
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'typeContactInfo'
        rootClass = typeContactInfo
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from clinvar import *\n\n')
        sys.stdout.write('import clinvar as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    # import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

__all__ = [
    "AcronymType",
    "AddressType",
    "AgeType",
    "AlleleDescType",
    "AssertionType4",
    "AssertionTypeType",
    "AttributeBundleType",
    "AttributeDecimalType",
    "AttributeSetType",
    "AttributeSetType5",
    "AttributeSetType6",
    "AttributeSetType8",
    "AttributeSetType9",
    "AttributeType",
    "AttributeTypeType",
    "AttributeTypeType1",
    "AttributeTypeType2",
    "AttributeTypeType3",
    "CertificationType",
    "CitationType",
    "CitationTypeType",
    "ClinVarDeletionType",
    "ClinicalSignificanceType",
    "ClinvarSubmissionAccType",
    "ClinvarSubmissionAccTypeType",
    "ClinvarSubmissionIDType",
    "Co_occurrenceType",
    "CommentType",
    "ContactType",
    "CountryType",
    "CredentialType",
    "CredentialType14",
    "CustomAssertionScoreType",
    "DegreeType",
    "DegreeType13",
    "ElementValueType",
    "ElementValueTypeType",
    "FamilyInfo",
    "GenotypeSetType",
    "GenotypeSetTypeType",
    "IDType",
    "IndicationType",
    "InstitutionType",
    "LabCertificationType",
    "MeasureAttributeTypeType",
    "MeasureRelationshipAttributeTypeType",
    "MeasureRelationshipType",
    "MeasureRelationshipTypeType",
    "MeasureSetAttributeSetType",
    "MeasureSetAttributeTypeType",
    "MeasureSetType",
    "MeasureSetTypeType",
    "MeasureTraitAttributeTypeType",
    "MeasureTraitType",
    "MeasureType",
    "MeasureTypeType",
    "MethodAttributeType",
    "MethodAttributeTypeType",
    "MethodType",
    "MethodTypeType",
    "NameType",
    "NameType12",
    "ObsAttributeTypeType",
    "ObsDecAttributeTypeType",
    "ObsMethodAttributeType",
    "ObsMethodAttributeTypeType",
    "ObservationSet",
    "ObservedDataType",
    "OrgIDType",
    "OrgType",
    "OrganizationType",
    "OrganizationType11",
    "PersonCertificationType",
    "PersonType",
    "PersonType10",
    "PersonnelType",
    "SampleDescriptionType",
    "SampleType",
    "SequenceLocationType",
    "SetElementSetType",
    "SoftwareSet",
    "SpeciesType",
    "StateType",
    "SubmissionSetType",
    "SubmissionType",
    "SubmitterType",
    "TraitAttributeTypeType",
    "TraitRelationshipAttributeTypeType",
    "TraitRelationshipType",
    "TraitRelationshipTypeType",
    "TraitSetAttributeSetType",
    "TraitSetAttributeTypeType",
    "TraitSetType",
    "TraitSetTypeType",
    "TraitSetTypeType7",
    "TraitType",
    "TraitTypeType",
    "TypeType",
    "XrefType",
    "typeAccessionSet",
    "typeAccount",
    "typeContactInfo"
]
